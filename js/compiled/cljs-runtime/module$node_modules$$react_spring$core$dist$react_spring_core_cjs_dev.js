shadow$provide.module$node_modules$$react_spring$core$dist$react_spring_core_cjs_dev=function(global,require,module,exports){function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i],key;for(key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};return _extends.apply(this,arguments)}function callProp(value,...args){return shared.is.fun(value)?value(...args):value}function getForwardProps(props){const forward=
{};let count=0;shared.eachProp(props,(value,prop)=>{RESERVED_PROPS[prop]||(forward[prop]=value,count++)});if(count)return forward}function inferTo(props){const to=getForwardProps(props);if(to){const out={to};shared.eachProp(props,(val,key)=>key in to||(out[key]=val));return out}return _extends({},props)}function computeGoal(value){value=shared.getFluidValue(value);return shared.is.arr(value)?value.map(computeGoal):shared.isAnimatedString(value)?shared.Globals.createStringInterpolator({range:[0,1],
output:[value,value]})(1):value}function hasProps(props){for(const _ in props)return!0;return!1}function isAsyncTo(to){return shared.is.fun(to)||shared.is.arr(to)&&shared.is.obj(to[0])}function detachRefs(ctrl,ref){var _ctrl$ref;null==(_ctrl$ref=ctrl.ref)?void 0:_ctrl$ref.delete(ctrl);null==ref?void 0:ref.delete(ctrl)}function replaceRef(ctrl,ref){if(ref&&ctrl.ref!==ref){var _ctrl$ref2;null==(_ctrl$ref2=ctrl.ref)?void 0:_ctrl$ref2.delete(ctrl);ref.add(ctrl);ctrl.ref=ref}}function mergeConfig(config,
newConfig,defaultConfig){defaultConfig&&(defaultConfig=_extends({},defaultConfig),sanitizeConfig(defaultConfig,newConfig),newConfig=_extends({},defaultConfig,newConfig));sanitizeConfig(config,newConfig);Object.assign(config,newConfig);for(const key in defaults$jscomp$0)null==config[key]&&(config[key]=defaults$jscomp$0[key]);let {mass,frequency,damping}=config;shared.is.und(frequency)||(.01>frequency&&(frequency=.01),0>damping&&(damping=0),config.tension=Math.pow(2*Math.PI/frequency,2)*mass,config.friction=
4*Math.PI*damping*mass/frequency);return config}function sanitizeConfig(config,props){if(shared.is.und(props.decay)){const isTensionConfig=!shared.is.und(props.tension)||!shared.is.und(props.friction);!isTensionConfig&&shared.is.und(props.frequency)&&shared.is.und(props.damping)&&shared.is.und(props.mass)||(config.duration=void 0,config.decay=void 0);isTensionConfig&&(config.frequency=void 0)}else config.duration=void 0}function scheduleProps(callId,{key,props,defaultProps,state,actions}){return new Promise((resolve,
reject)=>{function onPause(){state.resumeQueue.add(onResume);state.timeouts.delete(timeout);timeout.cancel();delay=timeout.time-shared.raf.now()}function onResume(){0<delay&&!shared.Globals.skipAnimation?(state.delayed=!0,timeout=shared.raf.setTimeout(onStart,delay),state.pauseQueue.add(onPause),state.timeouts.add(timeout)):onStart()}function onStart(){state.delayed&&(state.delayed=!1);state.pauseQueue.delete(onPause);state.timeouts.delete(timeout);callId<=(state.cancelId||0)&&(cancel=!0);try{actions.start(_extends({},
props,{callId,cancel}),resolve)}catch(err){reject(err)}}var _props$cancel;let delay,timeout,cancel=matchProp(null!=(_props$cancel=props.cancel)?_props$cancel:null==defaultProps?void 0:defaultProps.cancel,key);cancel?onStart():(shared.is.und(props.pause)||(state.paused=matchProp(props.pause,key)),_props$cancel=null==defaultProps?void 0:defaultProps.pause,!0!==_props$cancel&&(_props$cancel=state.paused||matchProp(_props$cancel,key)),delay=callProp(props.delay||0,key),_props$cancel?(state.resumeQueue.add(onResume),
actions.pause()):(actions.resume(),onResume()))})}function runAsync(to,props$jscomp$0,state,target){const {callId,parentId,onRest}=props$jscomp$0,{asyncTo:prevTo,promise:prevPromise}=state;return parentId||to!==prevTo||props$jscomp$0.reset?state.promise=(async()=>{state.asyncId=callId;state.asyncTo=to;const defaultProps=getDefaultProps(props$jscomp$0,(value,key)=>"onRest"===key?void 0:value);let preventBail,bail;const bailPromise=new Promise((resolve,reject)=>(preventBail=resolve,bail=reject)),bailIfEnded=
bailSignal=>{const bailResult=callId<=(state.cancelId||0)&&getCancelledResult(target)||callId!==state.asyncId&&getFinishedResult(target,!1);if(bailResult)throw bailSignal.result=bailResult,bail(bailSignal),bailSignal;},animate=(arg1,arg2)=>{const bailSignal=new BailSignal,skipAnimationSignal=new SkipAniamtionSignal;return(async()=>{if(shared.Globals.skipAnimation)throw stopAsync(state),skipAnimationSignal.result=getFinishedResult(target,!1),bail(skipAnimationSignal),skipAnimationSignal;bailIfEnded(bailSignal);
const props=shared.is.obj(arg1)?_extends({},arg1):_extends({},arg2,{to:arg1});props.parentId=callId;shared.eachProp(defaultProps,(value,key)=>{shared.is.und(props[key])&&(props[key]=value)});const result=await target.start(props);bailIfEnded(bailSignal);state.paused&&await new Promise(resume=>{state.resumeQueue.add(resume)});return result})()};let result$jscomp$0;if(shared.Globals.skipAnimation)return stopAsync(state),getFinishedResult(target,!1);try{let animating;animating=shared.is.arr(to)?(async queue=>
{for(const props of queue)await animate(props)})(to):Promise.resolve(to(animate,target.stop.bind(target)));await Promise.all([animating.then(preventBail),bailPromise]);result$jscomp$0=getFinishedResult(target.get(),!0,!1)}catch(err){if(err instanceof BailSignal)result$jscomp$0=err.result;else if(err instanceof SkipAniamtionSignal)result$jscomp$0=err.result;else throw err;}finally{callId==state.asyncId&&(state.asyncId=parentId,state.asyncTo=parentId?prevTo:void 0,state.promise=parentId?prevPromise:
void 0)}shared.is.fun(onRest)&&shared.raf.batchedUpdates(()=>{onRest(result$jscomp$0,target,target.item)});return result$jscomp$0})():prevPromise}function stopAsync(state,cancelId){shared.flush(state.timeouts,t=>t.cancel());state.pauseQueue.clear();state.resumeQueue.clear();state.asyncId=state.asyncTo=state.promise=void 0;cancelId&&(state.cancelId=cancelId)}function checkFinished(target,to){to=computeGoal(to);target=computeGoal(target.get());return shared.isEqual(target,to)}function createLoopUpdate(props,
loop=props.loop,to=props.to){var loopRet=callProp(loop);if(loopRet){loopRet=!0!==loopRet&&inferTo(loopRet);const reset=!loopRet||loopRet.reset;return createUpdate(_extends({},props,{loop,default:!1,pause:void 0,to:!(loopRet||props).reverse||isAsyncTo(to)?to:void 0,from:reset?props.from:void 0,reset},loopRet))}}function createUpdate(props){const {to,from}=props=inferTo(props),keys=new Set;shared.is.obj(to)&&findDefined(to,keys);shared.is.obj(from)&&findDefined(from,keys);props.keys=keys.size?Array.from(keys):
null;return props}function findDefined(values,keys){shared.eachProp(values,(value,key)=>null!=value&&keys.add(key))}function mergeActiveFn(target,props,type){var JSCompiler_temp_const=target.animation;props[type]!==getDefaultProp(props,type)?(props=props[type],target=target.key,target=shared.is.obj(props)?target&&props[target]:props):target=void 0;JSCompiler_temp_const[type]=target}function sendEvent(target,type,...args){var _target$animation$typ,_target$animation,_target$defaultProps$,_target$defaultProps;
null==(_target$animation$typ=(_target$animation=target.animation)[type])?void 0:_target$animation$typ.call(_target$animation,...args);null==(_target$defaultProps$=(_target$defaultProps=target.defaultProps)[type])?void 0:_target$defaultProps$.call(_target$defaultProps,...args)}function flushUpdateQueue(ctrl,queue){return Promise.all(queue.map(props=>flushUpdate(ctrl,props))).then(results=>getCombinedResult(ctrl,results))}async function flushUpdate(ctrl,props$jscomp$0,isLoop){const {keys,to,from,loop,
onRest,onResolve}=props$jscomp$0,defaults=shared.is.obj(props$jscomp$0.default)&&props$jscomp$0.default;loop&&(props$jscomp$0.loop=!1);!1===to&&(props$jscomp$0.to=null);!1===from&&(props$jscomp$0.from=null);const asyncTo=shared.is.arr(to)||shared.is.fun(to)?to:void 0;asyncTo?(props$jscomp$0.to=void 0,props$jscomp$0.onRest=void 0,defaults&&(defaults.onRest=void 0)):shared.each(BATCHED_EVENTS,key=>{const handler=props$jscomp$0[key];if(shared.is.fun(handler)){const queue=ctrl._events[key];props$jscomp$0[key]=
({finished,cancelled})=>{const result=queue.get(handler);result?(finished||(result.finished=!1),cancelled&&(result.cancelled=!0)):queue.set(handler,{value:null,finished:finished||!1,cancelled:cancelled||!1})};defaults&&(defaults[key]=props$jscomp$0[key])}});const state=ctrl._state;props$jscomp$0.pause===!state.paused?(state.paused=props$jscomp$0.pause,shared.flushCalls(props$jscomp$0.pause?state.pauseQueue:state.resumeQueue)):state.paused&&(props$jscomp$0.pause=!0);const promises=(keys||Object.keys(ctrl.springs)).map(key=>
ctrl.springs[key].start(props$jscomp$0)),cancel=!0===props$jscomp$0.cancel||!0===getDefaultProp(props$jscomp$0,"cancel");(asyncTo||cancel&&state.asyncId)&&promises.push(scheduleProps(++ctrl._lastAsyncId,{props:props$jscomp$0,state,actions:{pause:shared.noop,resume:shared.noop,start(props,resolve){cancel?(stopAsync(state,ctrl._lastAsyncId),resolve(getCancelledResult(ctrl))):(props.onRest=onRest,resolve(runAsync(asyncTo,props,state,ctrl)))}}}));state.paused&&await new Promise(resume=>{state.resumeQueue.add(resume)});
const result$jscomp$0=getCombinedResult(ctrl,await Promise.all(promises));if(loop&&result$jscomp$0.finished&&(!isLoop||!result$jscomp$0.noop)&&(isLoop=createLoopUpdate(props$jscomp$0,loop,to)))return prepareKeys(ctrl,[isLoop]),flushUpdate(ctrl,isLoop,!0);onResolve&&shared.raf.batchedUpdates(()=>onResolve(result$jscomp$0,ctrl,ctrl.item));return result$jscomp$0}function getSprings(ctrl,props$jscomp$0){const springs=_extends({},ctrl.springs);props$jscomp$0&&shared.each(shared.toArray(props$jscomp$0),
props=>{shared.is.und(props.keys)&&(props=createUpdate(props));shared.is.obj(props.to)||(props=_extends({},props,{to:void 0}));prepareSprings(springs,props,key=>createSpring(key))});setSprings(ctrl,springs);return springs}function setSprings(ctrl,springs){shared.eachProp(springs,(spring,key)=>{ctrl.springs[key]||(ctrl.springs[key]=spring,shared.addFluidObserver(spring,ctrl))})}function createSpring(key,observer){const spring=new SpringValue;spring.key=key;observer&&shared.addFluidObserver(spring,
observer);return spring}function prepareSprings(springs,props,create){props.keys&&shared.each(props.keys,key=>{(springs[key]||(springs[key]=create(key)))._prepareNode(props)})}function prepareKeys(ctrl,queue){shared.each(queue,props=>{prepareSprings(ctrl.springs,props,key=>createSpring(key,ctrl))})}function _objectWithoutPropertiesLoose(source,excluded){if(null==source)return{};var target={},sourceKeys=Object.keys(source),i;for(i=0;i<sourceKeys.length;i++){var key=sourceKeys[i];0<=excluded.indexOf(key)||
(target[key]=source[key])}return target}function useSprings(length,props,deps){function declareUpdates(startIndex,endIndex){for(;startIndex<endIndex;startIndex++){var ctrl=ctrls.current[startIndex]||(ctrls.current[startIndex]=new Controller(null,state.flush)),update=propsFn?propsFn(startIndex,ctrl):props[startIndex];update&&(ctrl=startIndex,update=createUpdate(update),shared.is.und(update.default)&&(update.default=getDefaultProps(update)),updates$jscomp$0[ctrl]=update)}}const propsFn=shared.is.fun(props)&&
props;propsFn&&!deps&&(deps=[]);const ref=React.useMemo(()=>propsFn||3==arguments.length?SpringRef$jscomp$0():void 0,[]),layoutId=React.useRef(0),forceUpdate=shared.useForceUpdate(),state=React.useMemo(()=>({ctrls:[],queue:[],flush(ctrl,updates){const springs=getSprings(ctrl,updates);return 0<layoutId.current&&!state.queue.length&&!Object.keys(springs).some(key=>!ctrl.springs[key])?flushUpdateQueue(ctrl,updates):new Promise(resolve=>{setSprings(ctrl,springs);state.queue.push(()=>{resolve(flushUpdateQueue(ctrl,
updates))});forceUpdate()})}}),[]),ctrls=React.useRef([...state.ctrls]),updates$jscomp$0=[],prevLength=shared.usePrev(length)||0;React.useMemo(()=>{shared.each(ctrls.current.slice(length,prevLength),ctrl=>{detachRefs(ctrl,ref);ctrl.stop(!0)});ctrls.current.length=length;declareUpdates(prevLength,length)},[length]);React.useMemo(()=>{declareUpdates(0,Math.min(prevLength,length))},deps);deps=ctrls.current.map((ctrl,i)=>getSprings(ctrl,updates$jscomp$0[i]));const context=React.useContext(SpringContext),
prevContext=shared.usePrev(context),hasContext=context!==prevContext&&hasProps(context);shared.useIsomorphicLayoutEffect(()=>{layoutId.current++;state.ctrls=ctrls.current;const {queue}=state;queue.length&&(state.queue=[],shared.each(queue,cb=>cb()));shared.each(ctrls.current,(ctrl,i)=>{null==ref?void 0:ref.add(ctrl);hasContext&&ctrl.start({default:context});if(i=updates$jscomp$0[i])replaceRef(ctrl,i.ref),ctrl.ref?ctrl.queue.push(i):ctrl.start(i)})});shared.useOnce(()=>()=>{shared.each(state.ctrls,
ctrl=>ctrl.stop(!0))});deps=deps.map(x=>_extends({},x));return ref?[deps,ref]:deps}function useSpring(props,deps){const isFn=shared.is.fun(props),[[values],ref]=useSprings(1,isFn?props:[props],isFn?deps||[]:deps);return isFn||2==arguments.length?[values,ref]:values}function useTrail(length,propsArg$jscomp$0,deps){var _passedRef;const propsFn=shared.is.fun(propsArg$jscomp$0)&&propsArg$jscomp$0;propsFn&&!deps&&(deps=[]);let reverse=!0,passedRef=void 0;const result=useSprings(length,(i,ctrl)=>{i=propsFn?
propsFn(i,ctrl):propsArg$jscomp$0;passedRef=i.ref;reverse=reverse&&i.reverse;return i},deps||[{}]),ref=null!=(_passedRef=passedRef)?_passedRef:result[1];shared.useIsomorphicLayoutEffect(()=>{shared.each(ref.current,(ctrl,i)=>{(i=ref.current[i+(reverse?1:-1)])?ctrl.start({to:i.springs}):ctrl.start()})},deps);if(propsFn||3==arguments.length)return ref._getProps=(propsArg,ctrl,i)=>{if(propsArg=shared.is.fun(propsArg)?propsArg(i,ctrl):propsArg){if(i=ref.current[i+(propsArg.reverse?1:-1)])propsArg.to=
i.springs;return propsArg}},result;ref.start=propsArg=>{const results=[];shared.each(ref.current,(ctrl,i)=>{const props=shared.is.fun(propsArg)?propsArg(i,ctrl):propsArg;(i=ref.current[i+(reverse?1:-1)])?results.push(ctrl.start(_extends({},props,{to:i.springs}))):results.push(ctrl.start(_extends({},props)))});return results};return result[0]}function useTransition(data,props,deps){const propsFn=shared.is.fun(props)&&props,{reset,sort,trail=0,expires=!0,exitBeforeEnter=!1,onDestroyed,ref:propsRef,
config:propsConfig}=propsFn?propsFn():props,ref=React.useMemo(()=>propsFn||3==arguments.length?SpringRef$jscomp$0():void 0,[]),items=shared.toArray(data),transitions$jscomp$0=[],usedTransitions=React.useRef(null),prevTransitions=reset?null:usedTransitions.current;shared.useIsomorphicLayoutEffect(()=>{usedTransitions.current=transitions$jscomp$0});shared.useOnce(()=>{shared.each(transitions$jscomp$0,t=>{null==ref?void 0:ref.add(t.ctrl);t.ctrl.ref=ref});return()=>{shared.each(usedTransitions.current,
t=>{t.expired&&clearTimeout(t.expirationId);detachRefs(t.ctrl,ref);t.ctrl.stop(!0)})}});const keys=getKeys(items,propsFn?propsFn():props,prevTransitions),expired=reset&&usedTransitions.current||[];shared.useIsomorphicLayoutEffect(()=>shared.each(expired,({ctrl,item,key})=>{detachRefs(ctrl,ref);callProp(onDestroyed,item,key)}));const reused=[];prevTransitions&&shared.each(prevTransitions,(t,i)=>{t.expired?(clearTimeout(t.expirationId),expired.push(t)):(i=reused[i]=keys.indexOf(t.key),~i&&(transitions$jscomp$0[i]=
t))});shared.each(items,(item,i)=>{transitions$jscomp$0[i]||(transitions$jscomp$0[i]={key:keys[i],item,phase:TransitionPhase$jscomp$0.MOUNT,ctrl:new Controller},transitions$jscomp$0[i].ctrl.item=item)});if(reused.length){let i=-1;const {leave}=propsFn?propsFn():props;shared.each(reused,(keyIndex,prevIndex)=>{prevIndex=prevTransitions[prevIndex];~keyIndex?(i=transitions$jscomp$0.indexOf(prevIndex),transitions$jscomp$0[i]=_extends({},prevIndex,{item:items[keyIndex]})):leave&&transitions$jscomp$0.splice(++i,
0,prevIndex)})}shared.is.fun(sort)&&transitions$jscomp$0.sort((a,b)=>sort(a.item,b.item));let delay=-trail;const forceUpdate=shared.useForceUpdate(),defaultProps=getDefaultProps(props),changes=new Map,exitingTransitions=React.useRef(new Map),forceChange=React.useRef(!1);shared.each(transitions$jscomp$0,(t$jscomp$1,i)=>{const key=t$jscomp$1.key;var prevPhase=t$jscomp$1.phase,p=propsFn?propsFn():props,propsDelay=callProp(p.delay||0,key);if(prevPhase==TransitionPhase$jscomp$0.MOUNT){var to=p.enter;prevPhase=
TransitionPhase$jscomp$0.ENTER}else if(to=0>keys.indexOf(key),prevPhase!=TransitionPhase$jscomp$0.LEAVE)if(to)to=p.leave,prevPhase=TransitionPhase$jscomp$0.LEAVE;else if(to=p.update)prevPhase=TransitionPhase$jscomp$0.UPDATE;else return;else{if(to)return;to=p.enter;prevPhase=TransitionPhase$jscomp$0.ENTER}to=callProp(to,t$jscomp$1.item,i);to=shared.is.obj(to)?inferTo(to):{to};to.config||(to.config=callProp(propsConfig||defaultProps.config,t$jscomp$1.item,i,prevPhase));delay+=trail;p=_extends({},defaultProps,
{delay:propsDelay+delay,ref:propsRef,immediate:p.immediate,reset:!1},to);prevPhase==TransitionPhase$jscomp$0.ENTER&&shared.is.und(p.from)&&(propsDelay=propsFn?propsFn():props,propsDelay=shared.is.und(propsDelay.initial)||prevTransitions?propsDelay.from:propsDelay.initial,p.from=callProp(propsDelay,t$jscomp$1.item,i));const {onResolve}=p;p.onResolve=result=>{callProp(onResolve,result);const transitions=usedTransitions.current,t$jscomp$0=transitions.find(t=>t.key===key);if(t$jscomp$0&&(!result.cancelled||
t$jscomp$0.phase==TransitionPhase$jscomp$0.UPDATE)&&t$jscomp$0.ctrl.idle){result=transitions.every(t=>t.ctrl.idle);if(t$jscomp$0.phase==TransitionPhase$jscomp$0.LEAVE){var expiry=callProp(expires,t$jscomp$0.item);if(!1!==expiry&&(expiry=!0===expiry?0:expiry,t$jscomp$0.expired=!0,!result&&0<expiry)){2147483647>=expiry&&(t$jscomp$0.expirationId=setTimeout(forceUpdate,expiry));return}}result&&transitions.some(t=>t.expired)&&(exitingTransitions.current.delete(t$jscomp$0),exitBeforeEnter&&(forceChange.current=
!0),forceUpdate())}};i=getSprings(t$jscomp$1.ctrl,p);prevPhase===TransitionPhase$jscomp$0.LEAVE&&exitBeforeEnter?exitingTransitions.current.set(t$jscomp$1,{phase:prevPhase,springs:i,payload:p}):changes.set(t$jscomp$1,{phase:prevPhase,springs:i,payload:p})});const context=React.useContext(SpringContext);data=shared.usePrev(context);const hasContext=context!==data&&hasProps(context);shared.useIsomorphicLayoutEffect(()=>{hasContext&&shared.each(transitions$jscomp$0,t=>{t.ctrl.start({default:context})})},
[context]);shared.each(changes,(_,t)=>{exitingTransitions.current.size&&(_=transitions$jscomp$0.findIndex(state=>state.key===t.key),transitions$jscomp$0.splice(_,1))});shared.useIsomorphicLayoutEffect(()=>{shared.each(exitingTransitions.current.size?exitingTransitions.current:changes,({phase,payload},t)=>{const {ctrl}=t;t.phase=phase;null==ref?void 0:ref.add(ctrl);hasContext&&phase==TransitionPhase$jscomp$0.ENTER&&ctrl.start({default:context});payload&&(replaceRef(ctrl,payload.ref),!ctrl.ref&&!ref||
forceChange.current?(ctrl.start(payload),forceChange.current&&(forceChange.current=!1)):ctrl.update(payload))})},reset?void 0:deps);deps=render=>React__namespace.createElement(React__namespace.Fragment,null,transitions$jscomp$0.map((t,i)=>{const {springs}=changes.get(t)||t.ctrl;return(i=render(_extends({},springs),t.item,t,i))&&i.type?React__namespace.createElement(i.type,_extends({},i.props,{key:shared.is.str(t.key)||shared.is.num(t.key)?t.key:t.ctrl.id,ref:i.ref})):i}));return ref?[deps,ref]:deps}
function getKeys(items,{key,keys=key},prevTransitions){if(null===keys){const reused=new Set;return items.map(item=>{const t$jscomp$0=prevTransitions&&prevTransitions.find(t=>t.item===item&&t.phase!==TransitionPhase$jscomp$0.LEAVE&&!reused.has(t));return t$jscomp$0?(reused.add(t$jscomp$0),t$jscomp$0.key):nextKey++})}return shared.is.und(keys)?items:shared.is.fun(keys)?items.map(keys):shared.toArray(keys)}function isIdle(source){return!1!==source.idle}function checkIdle(active){return!active.size||
Array.from(active).every(isIdle)}function becomeIdle(self){self.idle||(self.idle=!0,shared.each(animated$1.getPayload(self),node=>{node.done=!0}),shared.callFluidObservers(self,{type:"idle",parent:self}))}Object.defineProperty(exports,"__esModule",{value:!0});var shared=require("module$node_modules$$react_spring$shared$dist$react_spring_shared_cjs"),React=require("module$node_modules$react$index"),animated$1=require("module$node_modules$$react_spring$animated$dist$react_spring_animated_cjs"),animated=
require("module$node_modules$$react_spring$types$animated"),interpolation=require("module$node_modules$$react_spring$types$interpolation"),React__namespace=function(e){if(e&&e.__esModule)return e;var n=Object.create(null);e&&Object.keys(e).forEach(function(k){if("default"!==k){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:function(){return e[k]}})}});n["default"]=e;return Object.freeze(n)}(React);const matchProp=(value,key)=>!0===value||!!(key&&value&&
(shared.is.fun(value)?value(key):shared.toArray(value).includes(key))),getDefaultProp=(props,key)=>!0===props.default?props[key]:props.default?props.default[key]:void 0,noopTransform=value=>value,getDefaultProps=(props,transform=noopTransform)=>{var keys=DEFAULT_PROPS;props.default&&!0!==props.default&&(props=props.default,keys=Object.keys(props));const defaults={};for(const key of keys)keys=transform(props[key],key),shared.is.und(keys)||(defaults[key]=keys);return defaults},DEFAULT_PROPS="config onProps onStart onChange onPause onResume onRest".split(" "),
RESERVED_PROPS={config:1,from:1,to:1,ref:1,loop:1,reset:1,pause:1,cancel:1,reverse:1,immediate:1,default:1,delay:1,onProps:1,onStart:1,onChange:1,onPause:1,onResume:1,onRest:1,onResolve:1,items:1,trail:1,sort:1,expires:1,initial:1,enter:1,update:1,leave:1,children:1,onDestroyed:1,keys:1,callId:1,parentId:1};global={default:{tension:170,friction:26},gentle:{tension:120,friction:14},wobbly:{tension:180,friction:12},stiff:{tension:210,friction:20},slow:{tension:280,friction:60},molasses:{tension:280,
friction:120}};const c4=2*Math.PI/3,c5=2*Math.PI/4.5,bounceOut=x=>x<1/2.75?7.5625*x*x:x<2/2.75?7.5625*(x-=1.5/2.75)*x+.75:x<2.5/2.75?7.5625*(x-=2.25/2.75)*x+.9375:7.5625*(x-=2.625/2.75)*x+.984375;require={linear:x=>x,easeInQuad:x=>x*x,easeOutQuad:x=>1-(1-x)*(1-x),easeInOutQuad:x=>.5>x?2*x*x:1-Math.pow(-2*x+2,2)/2,easeInCubic:x=>x*x*x,easeOutCubic:x=>1-Math.pow(1-x,3),easeInOutCubic:x=>.5>x?4*x*x*x:1-Math.pow(-2*x+2,3)/2,easeInQuart:x=>x*x*x*x,easeOutQuart:x=>1-Math.pow(1-x,4),easeInOutQuart:x=>.5>
x?8*x*x*x*x:1-Math.pow(-2*x+2,4)/2,easeInQuint:x=>x*x*x*x*x,easeOutQuint:x=>1-Math.pow(1-x,5),easeInOutQuint:x=>.5>x?16*x*x*x*x*x:1-Math.pow(-2*x+2,5)/2,easeInSine:x=>1-Math.cos(x*Math.PI/2),easeOutSine:x=>Math.sin(x*Math.PI/2),easeInOutSine:x=>-(Math.cos(Math.PI*x)-1)/2,easeInExpo:x=>0===x?0:Math.pow(2,10*x-10),easeOutExpo:x=>1===x?1:1-Math.pow(2,-10*x),easeInOutExpo:x=>0===x?0:1===x?1:.5>x?Math.pow(2,20*x-10)/2:(2-Math.pow(2,-20*x+10))/2,easeInCirc:x=>1-Math.sqrt(1-Math.pow(x,2)),easeOutCirc:x=>
Math.sqrt(1-Math.pow(x-1,2)),easeInOutCirc:x=>.5>x?(1-Math.sqrt(1-Math.pow(2*x,2)))/2:(Math.sqrt(1-Math.pow(-2*x+2,2))+1)/2,easeInBack:x=>2.70158*x*x*x-1.70158*x*x,easeOutBack:x=>1+2.70158*Math.pow(x-1,3)+1.70158*Math.pow(x-1,2),easeInOutBack:x=>.5>x?Math.pow(2*x,2)*(7.189819*x-2.5949095)/2:(Math.pow(2*x-2,2)*(3.5949095*(2*x-2)+2.5949095)+2)/2,easeInElastic:x=>0===x?0:1===x?1:-Math.pow(2,10*x-10)*Math.sin((10*x-10.75)*c4),easeOutElastic:x=>0===x?0:1===x?1:Math.pow(2,-10*x)*Math.sin((10*x-.75)*c4)+
1,easeInOutElastic:x=>0===x?0:1===x?1:.5>x?-(Math.pow(2,20*x-10)*Math.sin((20*x-11.125)*c5))/2:Math.pow(2,-20*x+10)*Math.sin((20*x-11.125)*c5)/2+1,easeInBounce:x=>1-bounceOut(1-x),easeOutBounce:bounceOut,easeInOutBounce:x=>.5>x?(1-bounceOut(1-2*x))/2:(1+bounceOut(2*x-1))/2};const defaults$jscomp$0=_extends({},global.default,{mass:1,damping:1,easing:require.linear,clamp:!1});class AnimationConfig{constructor(){this.mass=this.damping=this.frequency=this.friction=this.tension=void 0;this.velocity=0;
this.round=this.decay=this.bounce=this.clamp=this.easing=this.duration=this.progress=this.precision=this.restVelocity=void 0;Object.assign(this,defaults$jscomp$0)}}const emptyArray=[];class Animation{constructor(){this.changed=!1;this.values=emptyArray;this.toValues=null;this.fromValues=emptyArray;this.from=this.to=void 0;this.config=new AnimationConfig;this.immediate=!1}}const getCombinedResult=(target,results)=>1==results.length?results[0]:results.some(result=>result.cancelled)?getCancelledResult(target.get()):
results.every(result=>result.noop)?{value:target.get(),noop:!0,finished:!0,cancelled:!1}:getFinishedResult(target.get(),results.every(result=>result.finished)),getFinishedResult=(value,finished,cancelled=!1)=>({value,finished,cancelled}),getCancelledResult=value=>({value,cancelled:!0,finished:!1});class BailSignal extends Error{constructor(){super("An async animation has been interrupted. You see this error because you forgot to use `await` or `.catch(...)` on its returned promise.");this.result=
void 0}}class SkipAniamtionSignal extends Error{constructor(){super("SkipAnimationSignal");this.result=void 0}}let nextId$1=1;class FrameValue extends shared.FluidValue{constructor(...args){super(...args);this.id=nextId$1++;this.key=void 0;this._priority=0}get priority(){return this._priority}set priority(priority){this._priority!=priority&&(this._priority=priority,this._onPriorityChange(priority))}get(){const node=animated$1.getAnimated(this);return node&&node.getValue()}to(...args){return shared.Globals.to(this,
args)}interpolate(...args){shared.deprecateInterpolate();return shared.Globals.to(this,args)}toJSON(){return this.get()}observerAdded(count){1==count&&this._attach()}observerRemoved(count){0==count&&this._detach()}_attach(){}_detach(){}_onChange(value,idle=!1){shared.callFluidObservers(this,{type:"change",parent:this,value,idle})}_onPriorityChange(priority){this.idle||shared.frameLoop.sort(this);shared.callFluidObservers(this,{type:"priority",parent:this,priority})}}const $P=Symbol.for("SpringPhase");
class SpringValue extends FrameValue{constructor(arg1,arg2){super();this.key=void 0;this.animation=new Animation;this.queue=void 0;this.defaultProps={};this._state={paused:!1,delayed:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};this._pendingCalls=new Set;this._memoizedDuration=this._lastToId=this._lastCallId=0;shared.is.und(arg1)&&shared.is.und(arg2)||(arg1=shared.is.obj(arg1)?_extends({},arg1):_extends({},arg2,{from:arg1}),shared.is.und(arg1.default)&&(arg1.default=!0),this.start(arg1))}get idle(){return!(0<
(this[$P]&2)||this._state.asyncTo)||0<(this[$P]&4)}get goal(){return shared.getFluidValue(this.animation.to)}get velocity(){const node$jscomp$0=animated$1.getAnimated(this);return node$jscomp$0 instanceof animated$1.AnimatedValue?node$jscomp$0.lastVelocity||0:node$jscomp$0.getPayload().map(node=>node.lastVelocity||0)}get hasAnimated(){return 0<(this[$P]&1)}get isAnimating(){return 0<(this[$P]&2)}get isPaused(){return 0<(this[$P]&4)}get isDelayed(){return this._state.delayed}advance(dt){let idle=!0,
changed=!1;const anim=this.animation;let {config,toValues}=anim;const payload=animated$1.getPayload(anim.to);!payload&&shared.hasFluidValue(anim.to)&&(toValues=shared.toArray(shared.getFluidValue(anim.to)));anim.values.forEach((node,i)=>{if(!node.done){var to=node.constructor==animated$1.AnimatedString?1:payload?payload[i].lastPosition:toValues[i],finished=anim.immediate,position=to;if(!finished){position=node.lastPosition;if(0>=config.tension){node.done=!0;return}var elapsed=node.elapsedTime+=dt,
from=anim.fromValues[i],v0=null!=node.v0?node.v0:node.v0=shared.is.arr(config.velocity)?config.velocity[i]:config.velocity,precision=config.precision||(from==to?.005:Math.min(1,.001*Math.abs(to-from)));if(shared.is.und(config.duration))if(config.decay)position=!0===config.decay?.998:config.decay,to=Math.exp(-(1-position)*elapsed),position=from+v0/(1-position)*(1-to),finished=Math.abs(node.lastPosition-position)<=precision,elapsed=v0*to;else{elapsed=null==node.lastVelocity?v0:node.lastVelocity;v0=
config.restVelocity||precision/10;const bounceFactor=config.clamp?0:config.bounce,canBounce=!shared.is.und(bounceFactor);from=from==to?0<node.v0:from<to;const numSteps=Math.ceil(dt/1);for(let n=0;n<numSteps;++n){var isMoving=Math.abs(elapsed)>v0;if(!isMoving&&(finished=Math.abs(to-position)<=precision))break;canBounce&&(isMoving=position==to||position>to==from)&&(elapsed=-elapsed*bounceFactor,position=to);elapsed+=(1E-6*-config.tension*(position-to)+.001*-config.friction*elapsed)/config.mass;position+=
1*elapsed}}else precision=1,0<config.duration&&(this._memoizedDuration!==config.duration&&(this._memoizedDuration=config.duration,0<node.durationProgress&&(node.elapsedTime=config.duration*node.durationProgress,elapsed=node.elapsedTime+=dt)),precision=(config.progress||0)+elapsed/this._memoizedDuration,precision=1<precision?1:0>precision?0:precision,node.durationProgress=precision),position=from+config.easing(precision)*(to-from),elapsed=(position-node.lastPosition)/dt,finished=1==precision;node.lastVelocity=
elapsed;Number.isNaN(position)&&(console.warn("Got NaN while animating:",this),finished=!0)}payload&&!payload[i].done&&(finished=!1);finished?node.done=!0:idle=!1;node.setValue(position,config.round)&&(changed=!0)}});const node$jscomp$0=animated$1.getAnimated(this),currVal=node$jscomp$0.getValue();if(idle){const finalVal=shared.getFluidValue(anim.to);currVal===finalVal&&!changed||config.decay?changed&&config.decay&&this._onChange(currVal):(node$jscomp$0.setValue(finalVal),this._onChange(finalVal));
this._stop()}else changed&&this._onChange(currVal)}set(value){shared.raf.batchedUpdates(()=>{this._stop();this._focus(value);this._set(value)});return this}pause(){this._update({pause:!0})}resume(){this._update({pause:!1})}finish(){if(0<(this[$P]&2)){const {to,config}=this.animation;shared.raf.batchedUpdates(()=>{this._onStart();config.decay||this._set(to,!1);this._stop()})}return this}update(props){(this.queue||(this.queue=[])).push(props);return this}start(to,arg2){shared.is.und(to)?(to=this.queue||
[],this.queue=[]):to=[shared.is.obj(to)?to:_extends({},arg2,{to})];return Promise.all(to.map(props=>this._update(props))).then(results=>getCombinedResult(this,results))}stop(cancel){const {to}=this.animation;this._focus(this.get());stopAsync(this._state,cancel&&this._lastCallId);shared.raf.batchedUpdates(()=>this._stop(to,cancel));return this}reset(){this._update({reset:!0})}eventObserved(event){"change"==event.type?this._start():"priority"==event.type&&(this.priority=event.priority+1)}_prepareNode(props){var key=
this.key||"";let {to,from}=props;to=shared.is.obj(to)?to[key]:to;if(null==to||isAsyncTo(to))to=void 0;from=shared.is.obj(from)?from[key]:from;null==from&&(from=void 0);key={to,from};0<(this[$P]&1)||(props.reverse&&([to,from]=[from,to]),from=shared.getFluidValue(from),shared.is.und(from)?animated$1.getAnimated(this)||this._set(to):this._set(from));return key}_update(_ref,isLoop){let props=_extends({},_ref);const {key,defaultProps}=this;props.default&&Object.assign(defaultProps,getDefaultProps(props,
(value,prop)=>/^on/.test(prop)?shared.is.obj(value)?key&&value[key]:value:value));mergeActiveFn(this,props,"onProps");sendEvent(this,"onProps",props,this);_ref=this._prepareNode(props);if(Object.isFrozen(this))throw Error("Cannot animate a `SpringValue` object that is frozen. Did you forget to pass your component to `animated(...)` before animating its props?");const state=this._state;return scheduleProps(++this._lastCallId,{key,props,defaultProps,state,actions:{pause:()=>{0<(this[$P]&4)||(this[$P]|=
4,shared.flushCalls(state.pauseQueue),sendEvent(this,"onPause",getFinishedResult(this,checkFinished(this,this.animation.to)),this))},resume:()=>{0<(this[$P]&4)&&(this[$P]&=-5,0<(this[$P]&2)&&this._resume(),shared.flushCalls(state.resumeQueue),sendEvent(this,"onResume",getFinishedResult(this,checkFinished(this,this.animation.to)),this))},start:this._merge.bind(this,_ref)}}).then(result=>{if(props.loop&&result.finished&&(!isLoop||!result.noop)){const nextProps=createLoopUpdate(props);if(nextProps)return this._update(nextProps,
!0)}return result})}_merge(range,props,resolve){if(props.cancel)return this.stop(!0),resolve(getCancelledResult(this));var hasToProp=!shared.is.und(range.to),hasFromProp=!shared.is.und(range.from);if(hasToProp||hasFromProp)if(props.callId>this._lastToId)this._lastToId=props.callId;else return resolve(getCancelledResult(this));const {key,defaultProps,animation:anim}=this,{to:prevTo,from:prevFrom}=anim;let {to=prevTo,from=prevFrom}=range;!hasFromProp||hasToProp||props.default&&!shared.is.und(to)||(to=
from);props.reverse&&([to,from]=[from,to]);var hasFromChanged=!shared.isEqual(from,prevFrom);hasFromChanged&&(anim.from=from);from=shared.getFluidValue(from);(range=!shared.isEqual(to,prevTo))&&this._focus(to);const hasAsyncTo=isAsyncTo(props.to),{config}=anim,{decay,velocity}=config;if(hasToProp||hasFromProp)config.velocity=0;props.config&&!hasAsyncTo&&mergeConfig(config,callProp(props.config,key),props.config!==defaultProps.config?callProp(defaultProps.config,key):void 0);hasToProp=animated$1.getAnimated(this);
if(!hasToProp||shared.is.und(to))return resolve(getFinishedResult(this,!0));const reset=shared.is.und(props.reset)?hasFromProp&&!props.default:!shared.is.und(from)&&matchProp(props.reset,key);hasFromProp=reset?from:this.get();const goal=computeGoal(to);var isAnimatable=shared.is.num(goal)||shared.is.arr(goal)||shared.isAnimatedString(goal);isAnimatable=!hasAsyncTo&&(!isAnimatable||matchProp(defaultProps.immediate||props.immediate,key));if(range){var nodeType=animated$1.getAnimatedType(to);if(nodeType!==
hasToProp.constructor)if(isAnimatable)hasToProp=this._set(goal);else throw Error(`Cannot animate between ${hasToProp.constructor.name} and ${nodeType.name}, as the "to" prop suggests`);}nodeType=hasToProp.constructor;let started=shared.hasFluidValue(to),finished=!1;if(!started){hasFromChanged=reset||!(0<(this[$P]&1))&&hasFromChanged;if(range||hasFromChanged)finished=shared.isEqual(computeGoal(hasFromProp),goal),started=!finished;(shared.isEqual(anim.immediate,isAnimatable)||isAnimatable)&&shared.isEqual(config.decay,
decay)&&shared.isEqual(config.velocity,velocity)||(started=!0)}finished&&0<(this[$P]&2)&&(anim.changed&&!reset?started=!0:started||this._stop(prevTo));if(!hasAsyncTo){if(started||shared.hasFluidValue(prevTo))anim.values=hasToProp.getPayload(),anim.toValues=shared.hasFluidValue(to)?null:nodeType==animated$1.AnimatedString?[1]:shared.toArray(goal);anim.immediate!=isAnimatable&&((anim.immediate=isAnimatable)||reset||this._set(prevTo));if(started){const {onRest}=anim;shared.each(ACTIVE_EVENTS,type=>mergeActiveFn(this,
props,type));const result=getFinishedResult(this,checkFinished(this,prevTo));shared.flushCalls(this._pendingCalls,result);this._pendingCalls.add(resolve);anim.changed&&shared.raf.batchedUpdates(()=>{anim.changed=!reset;null==onRest?void 0:onRest(result,this);reset?callProp(defaultProps.onRest,result):null==anim.onStart?void 0:anim.onStart(result,this)})}}reset&&this._set(hasFromProp);hasAsyncTo?resolve(runAsync(props.to,props,this._state,this)):started?this._start():0<(this[$P]&2)&&!range?this._pendingCalls.add(resolve):
resolve({value:hasFromProp,noop:!0,finished:!0,cancelled:!1})}_focus(value){const anim=this.animation;value!==anim.to&&(shared.getFluidObservers(this)&&this._detach(),anim.to=value,shared.getFluidObservers(this)&&this._attach())}_attach(){let priority=0;const {to}=this.animation;shared.hasFluidValue(to)&&(shared.addFluidObserver(to,this),to instanceof FrameValue&&(priority=to.priority+1));this.priority=priority}_detach(){const {to}=this.animation;shared.hasFluidValue(to)&&shared.removeFluidObserver(to,
this)}_set(arg,idle=!0){const value=shared.getFluidValue(arg);if(!shared.is.und(value)&&(arg=animated$1.getAnimated(this),!arg||!shared.isEqual(value,arg.getValue()))){const nodeType=animated$1.getAnimatedType(value);arg&&arg.constructor==nodeType?arg.setValue(value):animated$1.setAnimated(this,nodeType.create(value));arg&&shared.raf.batchedUpdates(()=>{this._onChange(value,idle)})}return animated$1.getAnimated(this)}_onStart(){const anim=this.animation;anim.changed||(anim.changed=!0,sendEvent(this,
"onStart",getFinishedResult(this,checkFinished(this,anim.to)),this))}_onChange(value,idle){idle||(this._onStart(),callProp(this.animation.onChange,value,this));callProp(this.defaultProps.onChange,value,this);super._onChange(value,idle)}_start(){const anim=this.animation;animated$1.getAnimated(this).reset(shared.getFluidValue(anim.to));anim.immediate||(anim.fromValues=anim.values.map(node=>node.lastPosition));0<(this[$P]&2)||(this[$P]|=3,0<(this[$P]&4)||this._resume())}_resume(){shared.Globals.skipAnimation?
this.finish():shared.frameLoop.start(this)}_stop(goal,cancel){if(0<(this[$P]&2)){this[$P]&=-3;const anim=this.animation;shared.each(anim.values,node=>{node.done=!0});anim.toValues&&(anim.onChange=anim.onPause=anim.onResume=void 0);shared.callFluidObservers(this,{type:"idle",parent:this});goal=cancel?getCancelledResult(this.get()):getFinishedResult(this.get(),checkFinished(this,null!=goal?goal:anim.to));shared.flushCalls(this._pendingCalls,goal);anim.changed&&(anim.changed=!1,sendEvent(this,"onRest",
goal,this))}}}const ACTIVE_EVENTS=["onStart","onRest","onChange","onPause","onResume"],BATCHED_EVENTS=["onStart","onChange","onRest"];let nextId=1;class Controller{constructor(props,flush){this.id=nextId++;this.springs={};this.queue=[];this._initialProps=this._flush=this.ref=void 0;this._lastAsyncId=0;this._active=new Set;this._changed=new Set;this._started=!1;this._item=void 0;this._state={paused:!1,pauseQueue:new Set,resumeQueue:new Set,timeouts:new Set};this._events={onStart:new Map,onChange:new Map,
onRest:new Map};this._onFrame=this._onFrame.bind(this);flush&&(this._flush=flush);props&&this.start(_extends({default:!0},props))}get idle(){return!this._state.asyncTo&&Object.values(this.springs).every(spring=>spring.idle&&!spring.isDelayed&&!spring.isPaused)}get item(){return this._item}set item(item){this._item=item}get(){const values={};this.each((spring,key)=>values[key]=spring.get());return values}set(values){for(const key in values){const value=values[key];shared.is.und(value)||this.springs[key].set(value)}}update(props){props&&
this.queue.push(createUpdate(props));return this}start(props){let {queue}=this;props?queue=shared.toArray(props).map(createUpdate):this.queue=[];if(this._flush)return this._flush(this,queue);prepareKeys(this,queue);return flushUpdateQueue(this,queue)}stop(arg,keys){arg!==!!arg&&(keys=arg);if(keys){const springs=this.springs;shared.each(shared.toArray(keys),key=>springs[key].stop(!!arg))}else stopAsync(this._state,this._lastAsyncId),this.each(spring=>spring.stop(!!arg));return this}pause(keys){if(shared.is.und(keys))this.start({pause:!0});
else{const springs=this.springs;shared.each(shared.toArray(keys),key=>springs[key].pause())}return this}resume(keys){if(shared.is.und(keys))this.start({pause:!1});else{const springs=this.springs;shared.each(shared.toArray(keys),key=>springs[key].resume())}return this}each(iterator){shared.eachProp(this.springs,iterator)}_onFrame(){const {onStart:onStart$jscomp$0,onChange:onChange$jscomp$0,onRest:onRest$jscomp$0}=this._events;var active=0<this._active.size;const changed=0<this._changed.size;if(active&&
!this._started||changed&&!this._started)this._started=!0,shared.flush(onStart$jscomp$0,([onStart,result])=>{result.value=this.get();onStart(result,this,this._item)});active=!active&&this._started;const values=changed||active&&onRest$jscomp$0.size?this.get():null;changed&&onChange$jscomp$0.size&&shared.flush(onChange$jscomp$0,([onChange,result])=>{result.value=values;onChange(result,this,this._item)});active&&(this._started=!1,shared.flush(onRest$jscomp$0,([onRest,result])=>{result.value=values;onRest(result,
this,this._item)}))}eventObserved(event){if("change"==event.type)this._changed.add(event.parent),event.idle||this._active.add(event.parent);else if("idle"==event.type)this._active.delete(event.parent);else return;shared.raf.onFrame(this._onFrame)}}const _excluded$3=["children"],SpringContext=_ref=>{let {children}=_ref;_ref=_objectWithoutPropertiesLoose(_ref,_excluded$3);var inherited=React.useContext(ctx);const pause=_ref.pause||!!inherited.pause,immediate=_ref.immediate||!!inherited.immediate;_ref=
shared.useMemoOne(()=>({pause,immediate}),[pause,immediate]);({Provider:inherited}=ctx);return React__namespace.createElement(inherited,{value:_ref},children)},ctx=function(target,init){Object.assign(target,React__namespace.createContext(init));target.Provider._context=target;return target.Consumer._context=target}(SpringContext,{});SpringContext.Provider=ctx.Provider;SpringContext.Consumer=ctx.Consumer;const SpringRef$jscomp$0=()=>{const current=[],SpringRef=function(props){shared.deprecateDirectCall();
const results=[];shared.each(current,(ctrl,i)=>{shared.is.und(props)?results.push(ctrl.start()):(i=_getProps(props,ctrl,i))&&results.push(ctrl.start(i))});return results};SpringRef.current=current;SpringRef.add=function(ctrl){current.includes(ctrl)||current.push(ctrl)};SpringRef.delete=function(ctrl){ctrl=current.indexOf(ctrl);~ctrl&&current.splice(ctrl,1)};SpringRef.pause=function(){shared.each(current,ctrl=>ctrl.pause(...arguments));return this};SpringRef.resume=function(){shared.each(current,ctrl=>
ctrl.resume(...arguments));return this};SpringRef.set=function(values){shared.each(current,ctrl=>ctrl.set(values))};SpringRef.start=function(props){const results=[];shared.each(current,(ctrl,i)=>{shared.is.und(props)?results.push(ctrl.start()):(i=this._getProps(props,ctrl,i))&&results.push(ctrl.start(i))});return results};SpringRef.stop=function(){shared.each(current,ctrl=>ctrl.stop(...arguments));return this};SpringRef.update=function(props){shared.each(current,(ctrl,i)=>ctrl.update(this._getProps(props,
ctrl,i)));return this};const _getProps=function(arg,ctrl,index){return shared.is.fun(arg)?arg(index,ctrl):arg};SpringRef._getProps=_getProps;return SpringRef},initSpringRef=()=>SpringRef$jscomp$0();let TransitionPhase$jscomp$0;(function(TransitionPhase){TransitionPhase.MOUNT="mount";TransitionPhase.ENTER="enter";TransitionPhase.UPDATE="update";TransitionPhase.LEAVE="leave"})(TransitionPhase$jscomp$0||(TransitionPhase$jscomp$0={}));let nextKey=1;const _excluded$2=["children"],_excluded$1=["items",
"children"],_excluded=["items","children"];class Interpolation extends FrameValue{constructor(source,args){super();this.key=void 0;this.idle=!0;this.calc=void 0;this._active=new Set;this.source=source;this.calc=shared.createInterpolator(...args);source=this._get();args=animated$1.getAnimatedType(source);animated$1.setAnimated(this,args.create(source))}advance(_dt){_dt=this._get();const oldValue=this.get();shared.isEqual(_dt,oldValue)||(animated$1.getAnimated(this).setValue(_dt),this._onChange(_dt,
this.idle));!this.idle&&checkIdle(this._active)&&becomeIdle(this)}_get(){const inputs=shared.is.arr(this.source)?this.source.map(shared.getFluidValue):shared.toArray(shared.getFluidValue(this.source));return this.calc(...inputs)}_start(){this.idle&&!checkIdle(this._active)&&(this.idle=!1,shared.each(animated$1.getPayload(this),node=>{node.done=!1}),shared.Globals.skipAnimation?(shared.raf.batchedUpdates(()=>this.advance()),becomeIdle(this)):shared.frameLoop.start(this))}_attach(){let priority=1;shared.each(shared.toArray(this.source),
source=>{shared.hasFluidValue(source)&&shared.addFluidObserver(source,this);source instanceof FrameValue&&(source.idle||this._active.add(source),priority=Math.max(priority,source.priority+1))});this.priority=priority;this._start()}_detach(){shared.each(shared.toArray(this.source),source=>{shared.hasFluidValue(source)&&shared.removeFluidObserver(source,this)});this._active.clear();becomeIdle(this)}eventObserved(event){"change"==event.type?event.idle?this.advance():(this._active.add(event.parent),this._start()):
"idle"==event.type?this._active.delete(event.parent):"priority"==event.type&&(this.priority=shared.toArray(this.source).reduce((highest,parent)=>Math.max(highest,(parent instanceof FrameValue?parent.priority:0)+1),0))}}shared.Globals.assign({createStringInterpolator:shared.createStringInterpolator,to:(source,args)=>new Interpolation(source,args)});module=shared.frameLoop.advance;Object.defineProperty(exports,"Globals",{enumerable:!0,get:function(){return shared.Globals}});Object.defineProperty(exports,
"createInterpolator",{enumerable:!0,get:function(){return shared.createInterpolator}});Object.defineProperty(exports,"useIsomorphicLayoutEffect",{enumerable:!0,get:function(){return shared.useIsomorphicLayoutEffect}});Object.defineProperty(exports,"useReducedMotion",{enumerable:!0,get:function(){return shared.useReducedMotion}});exports.BailSignal=BailSignal;exports.Controller=Controller;exports.FrameValue=FrameValue;exports.Interpolation=Interpolation;exports.Spring=function(_ref){let {children}=
_ref;_ref=_objectWithoutPropertiesLoose(_ref,_excluded$2);return children(useSpring(_ref))};exports.SpringContext=SpringContext;exports.SpringRef=SpringRef$jscomp$0;exports.SpringValue=SpringValue;exports.Trail=function(_ref){let {items,children}=_ref;_ref=_objectWithoutPropertiesLoose(_ref,_excluded$1);const trails=useTrail(items.length,_ref);return items.map((item,index)=>{item=children(item,index);return shared.is.fun(item)?item(trails[index]):item})};exports.Transition=function(_ref){let {items,
children}=_ref;_ref=_objectWithoutPropertiesLoose(_ref,_excluded);return useTransition(items,_ref)(children)};exports.config=global;exports.easings=require;exports.inferTo=inferTo;exports.interpolate=(source,...args)=>(shared.deprecateInterpolate(),new Interpolation(source,args));exports.to=(source,...args)=>new Interpolation(source,args);exports.update=module;exports.useChain=function(refs,timeSteps,timeFrame=1E3){shared.useIsomorphicLayoutEffect(()=>{if(timeSteps){let prevDelay=0;shared.each(refs,
(ref,i)=>{const controllers=ref.current;if(controllers.length){let delay=timeFrame*timeSteps[i];isNaN(delay)?delay=prevDelay:prevDelay=delay;shared.each(controllers,ctrl=>{shared.each(ctrl.queue,props=>{const memoizedDelayProp=props.delay;props.delay=key=>delay+callProp(memoizedDelayProp||0,key)})});ref.start()}})}else{let p=Promise.resolve();shared.each(refs,ref=>{const controllers=ref.current;if(controllers.length){const queues=controllers.map(ctrl=>{const q=ctrl.queue;ctrl.queue=[];return q});
p=p.then(()=>{shared.each(controllers,(ctrl,i)=>shared.each(queues[i]||[],update=>ctrl.queue.push(update)));return Promise.all(ref.start())})}})}})};exports.useSpring=useSpring;exports.useSpringRef=()=>React.useState(initSpringRef)[0];exports.useSprings=useSprings;exports.useTrail=useTrail;exports.useTransition=useTransition;Object.keys(animated).forEach(function(k){"default"===k||exports.hasOwnProperty(k)||Object.defineProperty(exports,k,{enumerable:!0,get:function(){return animated[k]}})});Object.keys(interpolation).forEach(function(k){"default"===
k||exports.hasOwnProperty(k)||Object.defineProperty(exports,k,{enumerable:!0,get:function(){return interpolation[k]}})})}
//# sourceMappingURL=module$node_modules$$react_spring$core$dist$react_spring_core_cjs_dev.js.map

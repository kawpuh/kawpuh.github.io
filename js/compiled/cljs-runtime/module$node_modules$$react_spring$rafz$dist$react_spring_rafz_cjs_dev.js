shadow$provide.module$node_modules$$react_spring$rafz$dist$react_spring_rafz_cjs_dev=function(global,require,module,exports){function schedule(fn,queue){sync?(queue.delete(fn),fn(0)):(queue.add(fn),start())}function start(){0>ts&&(ts=0,"demand"!==raf.frameLoop&&nativeRaf(loop))}function loop(){~ts&&(nativeRaf(loop),raf.batchedUpdates(update))}function update(){let prevTs=ts;ts=raf.now();let count=findTimeout(ts);count&&(eachSafely(timeouts.splice(0,count),t=>t.handler()),pendingCount-=count);pendingCount?
(onStartQueue.flush(),updateQueue.flush(prevTs?Math.min(64,ts-prevTs):16.667),onFrameQueue.flush(),writeQueue.flush(),onFinishQueue.flush()):ts=-1}function makeQueue(){let next=new Set,current=next;return{add(fn){pendingCount+=current!=next||next.has(fn)?0:1;next.add(fn)},delete(fn){pendingCount-=current==next&&next.has(fn)?1:0;return next.delete(fn)},flush(arg){current.size&&(next=new Set,pendingCount-=current.size,eachSafely(current,fn=>fn(arg)&&next.add(fn)),pendingCount+=next.size,current=next)}}}
function eachSafely(values,each){values.forEach(value=>{try{each(value)}catch(e){raf.catch(e)}})}Object.defineProperty(exports,"__esModule",{value:!0});let updateQueue=makeQueue();const raf=fn=>schedule(fn,updateQueue);let writeQueue=makeQueue();raf.write=fn=>schedule(fn,writeQueue);let onStartQueue=makeQueue();raf.onStart=fn=>schedule(fn,onStartQueue);let onFrameQueue=makeQueue();raf.onFrame=fn=>schedule(fn,onFrameQueue);let onFinishQueue=makeQueue();raf.onFinish=fn=>schedule(fn,onFinishQueue);let timeouts=
[];raf.setTimeout=(handler,ms)=>{ms=raf.now()+ms;let cancel=()=>{let i=timeouts.findIndex(t=>t.cancel==cancel);~i&&timeouts.splice(i,1);pendingCount-=~i?1:0};handler={time:ms,handler,cancel};timeouts.splice(findTimeout(ms),0,handler);pendingCount+=1;start();return handler};let findTimeout=time=>~(~timeouts.findIndex(t=>t.time>time)||~timeouts.length);raf.cancel=fn=>{onStartQueue.delete(fn);onFrameQueue.delete(fn);onFinishQueue.delete(fn);updateQueue.delete(fn);writeQueue.delete(fn)};raf.sync=fn=>
{sync=!0;raf.batchedUpdates(fn);sync=!1};raf.throttle=fn=>{function queuedFn(){try{fn(...lastArgs)}finally{lastArgs=null}}function throttled(...args){lastArgs=args;raf.onStart(queuedFn)}let lastArgs;throttled.handler=fn;throttled.cancel=()=>{onStartQueue.delete(queuedFn);lastArgs=null};return throttled};let nativeRaf="undefined"!=typeof window?window.requestAnimationFrame:()=>{};raf.use=impl=>nativeRaf=impl;raf.now="undefined"!=typeof performance?()=>performance.now():Date.now;raf.batchedUpdates=
fn=>fn();raf.catch=console.error;raf.frameLoop="always";raf.advance=()=>{"demand"!==raf.frameLoop?console.warn("Cannot call the manual advancement of rafz whilst frameLoop is not set as demand"):update()};let ts=-1,pendingCount=0,sync=!1;exports.__raf={count(){return pendingCount},isRunning(){return 0<=ts},clear(){ts=-1;timeouts=[];onStartQueue=makeQueue();updateQueue=makeQueue();onFrameQueue=makeQueue();writeQueue=makeQueue();onFinishQueue=makeQueue();pendingCount=0}};exports.raf=raf}
//# sourceMappingURL=module$node_modules$$react_spring$rafz$dist$react_spring_rafz_cjs_dev.js.map

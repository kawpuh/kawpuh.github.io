shadow$provide.module$node_modules$$react_three$fiber$dist$index_8539ced2_cjs_dev=function(global,require,module,exports){function _interopNamespace(e){if(e&&e.__esModule)return e;var n=Object.create(null);e&&Object.keys(e).forEach(function(k){if("default"!==k){var d=Object.getOwnPropertyDescriptor(e,k);Object.defineProperty(n,k,d.get?d:{enumerable:!0,get:function(){return e[k]}})}});n["default"]=e;return Object.freeze(n)}function useMutableCallback(fn){const ref=React__namespace.useRef(fn);useIsomorphicLayoutEffect(()=>
void(ref.current=fn),[fn]);return ref}function calculateDpr(dpr){const target="undefined"!==typeof window?window.devicePixelRatio:1;return Array.isArray(dpr)?Math.min(Math.max(dpr[0],target),dpr[1]):dpr}function buildGraph(object){const data={nodes:{},materials:{}};object&&object.traverse(obj=>{obj.name&&(data.nodes[obj.name]=obj);obj.material&&!data.materials[obj.material.name]&&(data.materials[obj.material.name]=obj.material)});return data}function dispose$jscomp$0(obj){obj.dispose&&"Scene"!==obj.type&&
obj.dispose();for(const p in obj)null==p.dispose?void 0:p.dispose(),delete obj[p]}function prepare(object,state){if(null!=state&&state.primitive||!object.__r3f)object.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...state};return object}function resolve(instance,key$jscomp$0){var target=instance;return key$jscomp$0.includes("-")?(target=key$jscomp$0.split("-"),key$jscomp$0=target.pop(),target=target.reduce((acc,key)=>acc[key],instance),
{target,key:key$jscomp$0}):{target,key:key$jscomp$0}}function attach$jscomp$0(parent,child,type){if(is.str(type)){if(INDEX_REGEX.test(type)){const root=type.replace(INDEX_REGEX,""),{target,key}=resolve(parent,root);Array.isArray(target[key])||(target[key]=[])}const {target:target$jscomp$0,key:key$jscomp$0}=resolve(parent,type);child.__r3f.previousAttach=target$jscomp$0[key$jscomp$0];target$jscomp$0[key$jscomp$0]=child}else child.__r3f.previousAttach=type(parent,child)}function detach(parent,child,
type){var _child$__r3f,_child$__r3f2;if(is.str(type)){const {target,key}=resolve(parent,type);parent=child.__r3f.previousAttach;void 0===parent?delete target[key]:target[key]=parent}else null==(_child$__r3f=child.__r3f)?void 0:null==_child$__r3f.previousAttach?void 0:_child$__r3f.previousAttach(parent,child);null==(_child$__r3f2=child.__r3f)?!0:delete _child$__r3f2.previousAttach}function diffProps(instance,{children:cN,key:kN,ref:rN,...props},{children:cP,key:kP,ref:rP,...previous}={},remove=!1){var _instance$__r3f;
cN=null!=(_instance$__r3f=null==instance?void 0:instance.__r3f)?_instance$__r3f:{};_instance$__r3f=Object.entries(props);const changes=[];if(remove)for(remove=Object.keys(previous),kN=0;kN<remove.length;kN++)props.hasOwnProperty(remove[kN])||_instance$__r3f.unshift([remove[kN],"__defaultremove"]);_instance$__r3f.forEach(([key,value])=>{var _instance$__r3f2;if(!(null!=(_instance$__r3f2=instance.__r3f)&&_instance$__r3f2.primitive&&"object"===key||is.equ(value,previous[key]))){if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key))return changes.push([key,
value,!0,[]]);_instance$__r3f2=[];key.includes("-")&&(_instance$__r3f2=key.split("-"));changes.push([key,value,!1,_instance$__r3f2]);for(const prop in props)value=props[prop],prop.startsWith(`${key}-`)&&changes.push([prop,value,!1,prop.split("-")])}});remove={...props};cN.memoizedProps&&cN.memoizedProps.args&&(remove.args=cN.memoizedProps.args);cN.memoizedProps&&cN.memoizedProps.attach&&(remove.attach=cN.memoizedProps.attach);return{memoized:remove,changes}}function applyProps$1(instance,data){var _instance$__r3f3,
_root$getState,_instance$__r3f4;const localState=null!=(_instance$__r3f3=instance.__r3f)?_instance$__r3f3:{};_instance$__r3f3=localState.root;_instance$__r3f3=null!=(_root$getState=null==_instance$__r3f3?void 0:null==_instance$__r3f3.getState?void 0:_instance$__r3f3.getState())?_root$getState:{};const {memoized,changes}=data&&data.memoized&&data.changes?data:diffProps(instance,data);data=localState.eventCount;instance.__r3f&&(instance.__r3f.memoizedProps=memoized);for(_root$getState=0;_root$getState<
changes.length;_root$getState++){let [key$jscomp$0,value,isEvent,keys]=changes[_root$getState];var currentInstance=instance;let targetProp=currentInstance[key$jscomp$0];if(keys.length&&(targetProp=keys.reduce((acc,key)=>acc[key],instance),!targetProp||!targetProp.set)){const [name,...reverseEntries]=keys.reverse();currentInstance=reverseEntries.reverse().reduce((acc,key)=>acc[key],instance);key$jscomp$0=name}if("__defaultremove"===value)if(targetProp&&targetProp.constructor){var _memoized$args;value=
new targetProp.constructor(...(null!=(_memoized$args=memoized.args)?_memoized$args:[]))}else if(currentInstance.constructor){var _currentInstance$__r;const defaultClassCall=new currentInstance.constructor(...(null!=(_currentInstance$__r=currentInstance.__r3f.memoizedProps.args)?_currentInstance$__r:[]));value=defaultClassCall[targetProp];defaultClassCall.dispose&&defaultClassCall.dispose()}else value=0;isEvent?(value?localState.handlers[key$jscomp$0]=value:delete localState.handlers[key$jscomp$0],
localState.eventCount=Object.keys(localState.handlers).length):targetProp&&targetProp.set&&(targetProp.copy||targetProp instanceof THREE__namespace.Layers)?Array.isArray(value)?targetProp.fromArray?targetProp.fromArray(value):targetProp.set(...value):targetProp.copy&&value&&value.constructor&&targetProp.constructor.name===value.constructor.name?targetProp.copy(value):void 0!==value&&(currentInstance=targetProp instanceof THREE__namespace.Color,!currentInstance&&targetProp.setScalar?targetProp.setScalar(value):
targetProp instanceof THREE__namespace.Layers&&value instanceof THREE__namespace.Layers?targetProp.mask=value.mask:targetProp.set(value),"ColorManagement"in THREE__namespace||_instance$__r3f3.linear||!currentInstance||targetProp.convertSRGBToLinear()):(currentInstance[key$jscomp$0]=value,!_instance$__r3f3.linear&&currentInstance[key$jscomp$0]instanceof THREE__namespace.Texture&&(currentInstance[key$jscomp$0].encoding=THREE__namespace.sRGBEncoding));invalidateInstance(instance)}localState.parent&&
_instance$__r3f3.internal&&instance.raycast&&data!==localState.eventCount&&(_memoized$args=_instance$__r3f3.internal.interaction.indexOf(instance),-1<_memoized$args&&_instance$__r3f3.internal.interaction.splice(_memoized$args,1),localState.eventCount&&_instance$__r3f3.internal.interaction.push(instance));changes.length&&null!=(_instance$__r3f4=instance.__r3f)&&_instance$__r3f4.parent&&updateInstance(instance);return instance}function invalidateInstance(instance){var _instance$__r3f5,_instance$__r3f5$root;
(instance=null==(_instance$__r3f5=instance.__r3f)?void 0:null==(_instance$__r3f5$root=_instance$__r3f5.root)?void 0:null==_instance$__r3f5$root.getState?void 0:_instance$__r3f5$root.getState())&&0===instance.internal.frames&&instance.invalidate()}function updateInstance(instance){null==instance.onUpdate?void 0:instance.onUpdate(instance)}function updateCamera(camera,size){camera.manual||(camera&&camera.isOrthographicCamera?(camera.left=size.width/-2,camera.right=size.width/2,camera.top=size.height/
2,camera.bottom=size.height/-2):camera.aspect=size.width/size.height,camera.updateProjectionMatrix(),camera.updateMatrixWorld())}function setDeep(obj,value,keys){const key$jscomp$0=keys.pop();return keys.reduce((acc,key)=>acc[key],obj)[key$jscomp$0]=value}function makeId(event){return(event.eventObject||event.object).uuid+"/"+event.index+event.instanceId}function releaseInternalPointerCapture(capturedMap,obj,captures,pointerId){const captureData=captures.get(obj);captureData&&(captures.delete(obj),
0===captures.size&&(capturedMap.delete(pointerId),captureData.target.releasePointerCapture(pointerId)))}function removeInteractivity(store,object){const {internal}=store.getState();internal.interaction=internal.interaction.filter(o=>o!==object);internal.initialHits=internal.initialHits.filter(o=>o!==object);internal.hovered.forEach((value,key)=>{value.eventObject!==object&&value.object!==object||internal.hovered.delete(key)});internal.capturedMap.forEach((captures,pointerId)=>{releaseInternalPointerCapture(internal.capturedMap,
object,captures,pointerId)})}function createSubs(callback,subs){const sub={callback};subs.add(sub);return()=>void subs.delete(sub)}function run(effects,timestamp){if(effects.size)for(const {callback}of effects.values())callback(timestamp)}function flushGlobalEffects(type,timestamp){switch(type){case "before":return run(globalEffects,timestamp);case "after":return run(globalAfterEffects,timestamp);case "tail":return run(globalTailEffects,timestamp)}}function render$1(timestamp,state,frame){let delta=
state.clock.getDelta();"never"===state.frameloop&&"number"===typeof timestamp&&(delta=timestamp-state.clock.elapsedTime,state.clock.oldTime=state.clock.elapsedTime,state.clock.elapsedTime=timestamp);subscribers=state.internal.subscribers;for(i$jscomp$0=0;i$jscomp$0<subscribers.length;i$jscomp$0++)subscription=subscribers[i$jscomp$0],subscription.ref.current(subscription.store.getState(),delta,frame);!state.internal.priority&&state.gl.render&&state.gl.render(state.scene,state.camera);state.internal.frames=
Math.max(0,state.internal.frames-1);return"always"===state.frameloop?1:state.internal.frames}function useStore(){const store=React__namespace.useContext(context);if(!store)throw Error("R3F: Hooks can only be used within the Canvas component!");return store}function loadingFn(extensions,onProgress){return function(Proto,...input$jscomp$0){const loader=new Proto;extensions&&extensions(loader);return Promise.all(input$jscomp$0.map(input=>new Promise((res,reject)=>loader.load(input,data=>{data.scene&&
Object.assign(data,buildGraph(data.scene));res(data)},onProgress,error=>reject(Error(`Could not load ${input}: ${error.message})`))))))}}function useLoader(Proto,input,extensions,onProgress){const keys=Array.isArray(input)?input:[input];Proto=suspendReact.suspend(loadingFn(extensions,onProgress),[Proto,...keys],{equal:is.equ});return Array.isArray(input)?Proto:Proto[0]}function computeInitialSize(canvas,defaultSize){if(defaultSize)return defaultSize;if(canvas instanceof HTMLCanvasElement&&canvas.parentElement){const {width,
height,top,left}=canvas.parentElement.getBoundingClientRect();return{width,height,top,left}}return{width:0,height:0,top:0,left:0}}function createRoot(canvas){const prevRoot=roots$jscomp$0.get(canvas),prevFiber=null==prevRoot?void 0:prevRoot.fiber,prevStore=null==prevRoot?void 0:prevRoot.store;prevRoot&&console.warn("R3F.createRoot should only be called once!");const logRecoverableError="function"===typeof reportError?reportError:console.error,store=prevStore||createStore(invalidate$jscomp$0,advance$jscomp$0),
fiber=prevFiber||reconciler.createContainer(store,constants.ConcurrentRoot,null,!1,null,"",logRecoverableError,null);prevRoot||roots$jscomp$0.set(canvas,{fiber,store});let onCreated,configured=!1;return{configure(props={}){let {gl:glConfig,size:propsSize,events,onCreated:onCreatedCallback,shadows=!1,linear=!1,flat=!1,legacy=!1,orthographic=!1,frameloop="always",dpr=[1,2],performance,raycaster:raycastOptions,camera:cameraOptions,onPointerMissed}=props;props=store.getState();var gl$jscomp$0=props.gl;
props.gl||props.set({gl:gl$jscomp$0=createRendererInstance(glConfig,canvas)});var raycaster=props.raycaster;raycaster||props.set({raycaster:raycaster=new THREE__namespace.Raycaster});const {params,...options}=raycastOptions||{};is.equ(options,raycaster,shallowLoose)||applyProps(raycaster,{...options});is.equ(params,raycaster.params,shallowLoose)||applyProps(raycaster,{params:{...raycaster.params,...params}});if(!props.camera){var camera=(raycaster=cameraOptions instanceof THREE__namespace.Camera)?
cameraOptions:orthographic?new THREE__namespace.OrthographicCamera(0,0,0,0,.1,1E3):new THREE__namespace.PerspectiveCamera(75,0,.1,1E3);raycaster||(camera.position.z=5,cameraOptions&&applyProps(camera,cameraOptions),null!=cameraOptions&&cameraOptions.rotation||camera.lookAt(0,0,0));props.set({camera})}if(!props.xr){const handleXRFrame=(timestamp,frame)=>{const state=store.getState();"never"!==state.frameloop&&advance$jscomp$0(timestamp,!0,state,frame)},handleSessionChange=()=>{const state=store.getState();
state.gl.xr.enabled=state.gl.xr.isPresenting;state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting?handleXRFrame:null);state.gl.xr.isPresenting||invalidate$jscomp$0(state)};raycaster={connect(){const gl=store.getState().gl;gl.xr.addEventListener("sessionstart",handleSessionChange);gl.xr.addEventListener("sessionend",handleSessionChange)},disconnect(){const gl=store.getState().gl;gl.xr.removeEventListener("sessionstart",handleSessionChange);gl.xr.removeEventListener("sessionend",handleSessionChange)}};
gl$jscomp$0.xr&&raycaster.connect();props.set({xr:raycaster})}gl$jscomp$0.shadowMap&&((raycaster=is.boo(shadows))&&gl$jscomp$0.shadowMap.enabled!==shadows||!is.equ(shadows,gl$jscomp$0.shadowMap,shallowLoose))&&(camera=gl$jscomp$0.shadowMap.enabled,gl$jscomp$0.shadowMap.enabled=!!shadows,raycaster?gl$jscomp$0.shadowMap.type=THREE__namespace.PCFSoftShadowMap:Object.assign(gl$jscomp$0.shadowMap,shadows),camera!==gl$jscomp$0.shadowMap.enabled&&(gl$jscomp$0.shadowMap.needsUpdate=!0));"ColorManagement"in
THREE__namespace&&setDeep(THREE__namespace,legacy,["ColorManagement","legacyMode"]);raycaster=linear?THREE__namespace.LinearEncoding:THREE__namespace.sRGBEncoding;camera=flat?THREE__namespace.NoToneMapping:THREE__namespace.ACESFilmicToneMapping;gl$jscomp$0.outputEncoding!==raycaster&&(gl$jscomp$0.outputEncoding=raycaster);gl$jscomp$0.toneMapping!==camera&&(gl$jscomp$0.toneMapping=camera);props.legacy!==legacy&&props.set(()=>({legacy}));props.linear!==linear&&props.set(()=>({linear}));props.flat!==
flat&&props.set(()=>({flat}));!glConfig||is.fun(glConfig)||null!=glConfig&&glConfig.render||is.equ(glConfig,gl$jscomp$0,shallowLoose)||applyProps(gl$jscomp$0,glConfig);events&&!props.events.handlers&&props.set({events:events(store)});dpr&&props.viewport.dpr!==calculateDpr(dpr)&&props.setDpr(dpr);gl$jscomp$0=computeInitialSize(canvas,propsSize);is.equ(gl$jscomp$0,props.size,shallowLoose)||props.setSize(gl$jscomp$0.width,gl$jscomp$0.height,gl$jscomp$0.updateStyle,gl$jscomp$0.top,gl$jscomp$0.left);props.frameloop!==
frameloop&&props.setFrameloop(frameloop);props.onPointerMissed||props.set({onPointerMissed});performance&&!is.equ(performance,props.performance,shallowLoose)&&props.set(state=>({performance:{...state.performance,...performance}}));onCreated=onCreatedCallback;configured=!0;return this},render(children){configured||this.configure();reconciler.updateContainer(React__namespace.createElement(Provider,{store,children,onCreated,rootElement:canvas}),fiber,null,()=>{});return store},unmount(){unmountComponentAtNode(canvas)}}}
function Provider({store,children,onCreated,rootElement}){useIsomorphicLayoutEffect(()=>{const state$jscomp$0=store.getState();state$jscomp$0.set(state=>({internal:{...state.internal,active:!0}}));onCreated&&onCreated(state$jscomp$0);store.getState().events.connected||(null==state$jscomp$0.events.connect?void 0:state$jscomp$0.events.connect(rootElement))},[]);return React__namespace.createElement(context.Provider,{value:store},children)}function unmountComponentAtNode(canvas,callback){const root=
roots$jscomp$0.get(canvas),fiber=null==root?void 0:root.fiber;if(fiber){const state=null==root?void 0:root.store.getState();state&&(state.internal.active=!1);reconciler.updateContainer(null,fiber,null,()=>{state&&setTimeout(()=>{try{var _state$gl,_state$gl$renderLists,_state$gl2,_state$gl3;null==state.events.disconnect?void 0:state.events.disconnect();null==(_state$gl=state.gl)?void 0:null==(_state$gl$renderLists=_state$gl.renderLists)?void 0:null==_state$gl$renderLists.dispose?void 0:_state$gl$renderLists.dispose();
null==(_state$gl2=state.gl)?void 0:null==_state$gl2.forceContextLoss?void 0:_state$gl2.forceContextLoss();null!=(_state$gl3=state.gl)&&_state$gl3.xr&&state.xr.disconnect();dispose$jscomp$0(state);roots$jscomp$0.delete(canvas);callback&&callback(canvas)}catch(e){}},500)})}}function Portal({state:state$jscomp$0={},children,container}){const {events:events$jscomp$0,size,...rest}=state$jscomp$0,previousRoot=useStore(),[raycaster]=React__namespace.useState(()=>new THREE__namespace.Raycaster),[pointer]=
React__namespace.useState(()=>new THREE__namespace.Vector2),inject=React__namespace.useCallback((rootState,injectState)=>{const intersect={...rootState};Object.keys(rootState).forEach(key=>{(privateKeys.includes(key)||rootState[key]!==injectState[key])&&delete intersect[key]});let viewport=void 0;if(injectState&&size){const camera=injectState.camera;viewport=rootState.viewport.getCurrentViewport(camera,new THREE__namespace.Vector3,size);camera!==rootState.camera&&updateCamera(camera,size)}return{...intersect,
scene:container,raycaster,pointer,mouse:pointer,previousRoot,events:{...rootState.events,...(null==injectState?void 0:injectState.events),...events$jscomp$0},size:{...rootState.size,...size},viewport:{...rootState.viewport,...viewport},...rest}},[state$jscomp$0]),[usePortalStore]=React__namespace.useState(()=>{const previousState=previousRoot.getState();return create__default["default"]((set,get)=>({...previousState,scene:container,raycaster,pointer,mouse:pointer,previousRoot,events:{...previousState.events,
...events$jscomp$0},size:{...previousState.size,...size},...rest,set,get,setEvents:events=>set(state=>({...state,events:{...state.events,...events}}))}))});React__namespace.useEffect(()=>{const unsub=previousRoot.subscribe(prev=>usePortalStore.setState(state=>inject(prev,state)));return()=>{unsub();usePortalStore.destroy()}},[]);React__namespace.useEffect(()=>{usePortalStore.setState(injectState=>inject(previousRoot.getState(),injectState))},[inject]);return React__namespace.createElement(React__namespace.Fragment,
null,reconciler.createPortal(React__namespace.createElement(context.Provider,{value:usePortalStore},children),usePortalStore,null))}global=require("module$node_modules$three$build$three");module=require("module$node_modules$react$index");var constants=require("module$node_modules$react_reconciler$constants"),create=require("module$node_modules$zustand$index"),Reconciler=require("module$node_modules$react_reconciler$index"),scheduler=require("module$node_modules$$react_three$fiber$node_modules$scheduler$index"),
suspendReact=require("module$node_modules$suspend_react$dist$index_cjs"),THREE__namespace=_interopNamespace(global),React__namespace=_interopNamespace(module),create__default=create&&create.__esModule?create:{"default":create},Reconciler__default=Reconciler&&Reconciler.__esModule?Reconciler:{"default":Reconciler};require=Object.freeze({__proto__:null});var _window$document,_window$navigator;const useIsomorphicLayoutEffect="undefined"!==typeof window&&(null!=(_window$document=window.document)&&_window$document.createElement||
"ReactNative"===(null==(_window$navigator=window.navigator)?void 0:_window$navigator.product))?React__namespace.useLayoutEffect:React__namespace.useEffect;class ErrorBoundary extends React__namespace.Component{constructor(...args){super(...args);this.state={error:!1}}componentDidCatch(err){this.props.set(err)}render(){return this.state.error?null:this.props.children}}ErrorBoundary.getDerivedStateFromError=()=>({error:!0});const getRootState=obj=>{var _r3f;return null==(_r3f=obj.__r3f)?void 0:_r3f.root.getState()},
is={obj:a=>a===Object(a)&&!is.arr(a)&&"function"!==typeof a,fun:a=>"function"===typeof a,str:a=>"string"===typeof a,num:a=>"number"===typeof a,boo:a=>"boolean"===typeof a,und:a=>void 0===a,arr:a=>Array.isArray(a),equ(a,b,{arrays="shallow",objects="reference",strict=!0}={}){if(typeof a!==typeof b||!!a!==!!b)return!1;if(is.str(a)||is.num(a))return a===b;const isObj=is.obj(a);if(isObj&&"reference"===objects||(objects=is.arr(a))&&"reference"===arrays)return a===b;if((objects||isObj)&&a===b)return!0;let i;
for(i in a)if(!(i in b))return!1;for(i in strict?b:a)if(a[i]!==b[i])return!1;if(is.und(i)){if(objects&&0===a.length&&0===b.length||isObj&&0===Object.keys(a).length&&0===Object.keys(b).length)return!0;if(a!==b)return!1}return!0}},INDEX_REGEX=/-\d+$/;let catalogue={};const privateKeys="set get setSize setFrameloop setDpr events invalidate advance size viewport".split(" "),context=React__namespace.createContext(null),createStore=(invalidate,advance)=>{const rootState=create__default["default"]((set,
get)=>{function getCurrentViewport(camera=get().camera,target=defaultTarget,size=get().size){const {width,height,top,left}=size;size=width/height;target instanceof THREE__namespace.Vector3?tempTarget.copy(target):tempTarget.set(...target);target=camera.getWorldPosition(position).distanceTo(tempTarget);if(camera&&camera.isOrthographicCamera)return{width:width/camera.zoom,height:height/camera.zoom,top,left,factor:1,distance:target,aspect:size};camera=2*Math.tan(camera.fov*Math.PI/180/2)*target;const w=
width/height*camera;return{width:w,height:camera,top,left,factor:width/w,distance:target,aspect:size}}const position=new THREE__namespace.Vector3,defaultTarget=new THREE__namespace.Vector3,tempTarget=new THREE__namespace.Vector3;let performanceTimeout=void 0;const setPerformanceCurrent=current=>set(state=>({performance:{...state.performance,current}})),pointer=new THREE__namespace.Vector2;return{set,get,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,invalidate:(frames=
1)=>invalidate(get(),frames),advance:(timestamp,runGlobalEffects)=>advance(timestamp,runGlobalEffects,get()),legacy:!1,linear:!1,flat:!1,scene:prepare(new THREE__namespace.Scene),controls:null,clock:new THREE__namespace.Clock,pointer,mouse:pointer,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const state=get();performanceTimeout&&clearTimeout(performanceTimeout);state.performance.current!==state.performance.min&&setPerformanceCurrent(state.performance.min);
performanceTimeout=setTimeout(()=>setPerformanceCurrent(get().performance.max),state.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport},setEvents:events=>set(state=>({...state,events:{...state.events,...events}})),setSize:(width,height,updateStyle,top,left)=>{const camera=get().camera,size={width,height,top:top||0,left:left||0,updateStyle};set(state=>({size,viewport:{...state.viewport,
...getCurrentViewport(camera,defaultTarget,size)}}))},setDpr:dpr=>set(state=>{const resolved=calculateDpr(dpr);return{viewport:{...state.viewport,dpr:resolved,initialDpr:state.viewport.initialDpr||resolved}}}),setFrameloop:(frameloop="always")=>{const clock=get().clock;clock.stop();clock.elapsedTime=0;"never"!==frameloop&&(clock.start(),clock.elapsedTime=0);set(()=>({frameloop}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:React__namespace.createRef(),interaction:[],hovered:new Map,
subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(ref,priority,store)=>{const internal$jscomp$0=get().internal;internal$jscomp$0.priority+=0<priority?1:0;internal$jscomp$0.subscribers.push({ref,priority,store});internal$jscomp$0.subscribers=internal$jscomp$0.subscribers.sort((a,b)=>a.priority-b.priority);return()=>{const internal=get().internal;null!=internal&&internal.subscribers&&(internal.priority-=0<priority?1:0,internal.subscribers=internal.subscribers.filter(s=>
s.ref!==ref))}}}}}),state$jscomp$0=rootState.getState();let oldSize=state$jscomp$0.size,oldDpr=state$jscomp$0.viewport.dpr,oldCamera=state$jscomp$0.camera;rootState.subscribe(()=>{const {camera,size,viewport,gl,set}=rootState.getState();if(size!==oldSize||viewport.dpr!==oldDpr)oldSize=size,oldDpr=viewport.dpr,updateCamera(camera,size),gl.setPixelRatio(viewport.dpr),gl.setSize(size.width,size.height,size.updateStyle);camera!==oldCamera&&(oldCamera=camera,set(state=>({viewport:{...state.viewport,...state.viewport.getCurrentViewport(camera)}})))});
rootState.subscribe(state=>invalidate(state));return rootState};let i$jscomp$0,globalEffects=new Set,globalAfterEffects=new Set,globalTailEffects=new Set,subscribers,subscription;useLoader.preload=function(Proto,input,extensions){input=Array.isArray(input)?input:[input];return suspendReact.preload(loadingFn(extensions),[Proto,...input])};useLoader.clear=function(Proto,input){input=Array.isArray(input)?input:[input];return suspendReact.clear([Proto,...input])};const roots$jscomp$0=new Map,{invalidate:invalidate$jscomp$0,
advance:advance$jscomp$0}=function(roots){function loop(timestamp){frame$jscomp$0=requestAnimationFrame(loop);running=!0;repeat=0;flushGlobalEffects("before",timestamp);for(const root of roots.values()){var _state$gl$xr;state$jscomp$0=root.store.getState();!state$jscomp$0.internal.active||!("always"===state$jscomp$0.frameloop||0<state$jscomp$0.internal.frames)||null!=(_state$gl$xr=state$jscomp$0.gl.xr)&&_state$gl$xr.isPresenting||(repeat+=render$1(timestamp,state$jscomp$0))}flushGlobalEffects("after",
timestamp);if(0===repeat)return flushGlobalEffects("tail",timestamp),running=!1,cancelAnimationFrame(frame$jscomp$0)}function invalidate(state,frames=1){var _state$gl$xr2;if(!state)return roots.forEach(root=>invalidate(root.store.getState()),frames);null!=(_state$gl$xr2=state.gl.xr)&&_state$gl$xr2.isPresenting||!state.internal.active||"never"===state.frameloop||(state.internal.frames=Math.min(60,state.internal.frames+frames),running||(running=!0,requestAnimationFrame(loop)))}let running=!1,repeat,
frame$jscomp$0,state$jscomp$0;return{loop,invalidate,advance:function(timestamp,runGlobalEffects=!0,state,frame){runGlobalEffects&&flushGlobalEffects("before",timestamp);if(state)render$1(timestamp,state,frame);else for(const root of roots.values())render$1(timestamp,root.store.getState());runGlobalEffects&&flushGlobalEffects("after",timestamp)}}}(roots$jscomp$0),{reconciler,applyProps}=function(_roots,_getEventPriority){function createInstance(type,{args=[],attach,...props},root){let name=`${type[0].toUpperCase()}${type.slice(1)}`;
if("primitive"===type){if(void 0===props.object)throw Error("R3F: Primitives without 'object' are invalid!");type=prepare(props.object,{type,root,attach,primitive:!0})}else{const target=catalogue[name];if(!target)throw Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(args))throw Error("R3F: The args prop must be an array!");type=prepare(new target(...args),
{type,root,attach,memoizedProps:{args}})}void 0===type.__r3f.attach&&(type instanceof THREE__namespace.BufferGeometry?type.__r3f.attach="geometry":type instanceof THREE__namespace.Material&&(type.__r3f.attach="material"));"inject"!==name&&applyProps$1(type,props);return type}function appendChild(parentInstance,child){let added=!1;if(child){var _child$__r3f,_parentInstance$__r3f;null!=(_child$__r3f=child.__r3f)&&_child$__r3f.attach?attach$jscomp$0(parentInstance,child,child.__r3f.attach):child.isObject3D&&
parentInstance.isObject3D&&(parentInstance.add(child),added=!0);added||(null==(_parentInstance$__r3f=parentInstance.__r3f)?void 0:_parentInstance$__r3f.objects.push(child));child.__r3f||prepare(child,{});child.__r3f.parent=parentInstance;updateInstance(child);invalidateInstance(child)}}function insertBefore(parentInstance,child,beforeChild){var added=!1;if(child){var _child$__r3f2,_parentInstance$__r3f2;null!=(_child$__r3f2=child.__r3f)&&_child$__r3f2.attach?attach$jscomp$0(parentInstance,child,child.__r3f.attach):
child.isObject3D&&parentInstance.isObject3D&&(child.parent=parentInstance,child.dispatchEvent({type:"added"}),added=parentInstance.children.filter(sibling=>sibling!==child),beforeChild=added.indexOf(beforeChild),parentInstance.children=[...added.slice(0,beforeChild),child,...added.slice(beforeChild)],added=!0);added||(null==(_parentInstance$__r3f2=parentInstance.__r3f)?void 0:_parentInstance$__r3f2.objects.push(child));child.__r3f||prepare(child,{});child.__r3f.parent=parentInstance;updateInstance(child);
invalidateInstance(child)}}function removeRecursive(array,parent,dispose=!1){array&&[...array].forEach(child=>removeChild(parent,child,dispose))}function removeChild(parentInstance,child,dispose){if(child){var _parentInstance$__r3f3,_child$__r3f3,_child$__r3f5;child.__r3f&&(child.__r3f.parent=null);null!=(_parentInstance$__r3f3=parentInstance.__r3f)&&_parentInstance$__r3f3.objects&&(parentInstance.__r3f.objects=parentInstance.__r3f.objects.filter(x=>x!==child));if(null!=(_child$__r3f3=child.__r3f)&&
_child$__r3f3.attach)detach(parentInstance,child,child.__r3f.attach);else if(child.isObject3D&&parentInstance.isObject3D){var _child$__r3f4;parentInstance.remove(child);null!=(_child$__r3f4=child.__r3f)&&_child$__r3f4.root&&removeInteractivity(child.__r3f.root,child)}_parentInstance$__r3f3=null==(_child$__r3f5=child.__r3f)?void 0:_child$__r3f5.primitive;dispose=void 0===dispose?null!==child.dispose&&!_parentInstance$__r3f3:dispose;if(!_parentInstance$__r3f3){var _child$__r3f6;removeRecursive(null==
(_child$__r3f6=child.__r3f)?void 0:_child$__r3f6.objects,child,dispose);removeRecursive(child.children,child,dispose)}child.__r3f&&(delete child.__r3f.root,delete child.__r3f.objects,delete child.__r3f.handlers,delete child.__r3f.memoizedProps,_parentInstance$__r3f3||delete child.__r3f);dispose&&child.dispose&&"Scene"!==child.type&&scheduler.unstable_scheduleCallback(scheduler.unstable_IdlePriority,()=>{try{child.dispose()}catch(e){}});invalidateInstance(parentInstance)}}function switchInstance(instance,
type,newProps,fiber$jscomp$0){var _instance$__r3f;const parent=null==(_instance$__r3f=instance.__r3f)?void 0:_instance$__r3f.parent;if(parent){var newInstance=createInstance(type,newProps,instance.__r3f.root);if(instance.children){for(const child of instance.children)child.__r3f&&appendChild(newInstance,child);instance.children=instance.children.filter(child=>!child.__r3f)}instance.__r3f.objects.forEach(child=>appendChild(newInstance,child));instance.__r3f.objects=[];removeChild(parent,instance);
appendChild(parent,newInstance);newInstance.raycast&&newInstance.__r3f.eventCount&&newInstance.__r3f.root.getState().internal.interaction.push(newInstance);[fiber$jscomp$0,fiber$jscomp$0.alternate].forEach(fiber=>{null!==fiber&&(fiber.stateNode=newInstance,fiber.ref&&("function"===typeof fiber.ref?fiber.ref(newInstance):fiber.ref.current=newInstance))})}}_roots=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:Reconciler__default["default"]({createInstance,
removeChild,appendChild,appendInitialChild:appendChild,insertBefore,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(container,child)=>{if(child){var scene=container.getState().scene;scene.__r3f&&(scene.__r3f.root=container,appendChild(scene,child))}},removeChildFromContainer:(container,child)=>{child&&removeChild(container.getState().scene,child)},insertInContainerBefore:(container,child,beforeChild)=>{child&&beforeChild&&(container=
container.getState().scene,container.__r3f&&insertBefore(container,child,beforeChild))},getRootHostContext:()=>null,getChildHostContext:parentHostContext=>parentHostContext,finalizeInitialChildren(instance){var _instance$__r3f2;return!!(null!=(_instance$__r3f2=null==instance?void 0:instance.__r3f)?_instance$__r3f2:{}).handlers},prepareUpdate(instance,_type,oldProps,newProps){if(instance.__r3f.primitive&&newProps.object&&newProps.object!==instance)return[!0];const {args:argsNew=[],children:cN,...restNew}=
newProps,{args:argsOld=[],children:cO,...restOld}=oldProps;if(!Array.isArray(argsNew))throw Error("R3F: the args prop must be an array!");if(argsNew.some((value,index)=>value!==argsOld[index]))return[!0];instance=diffProps(instance,restNew,restOld,!0);return instance.changes.length?[!1,instance]:null},commitUpdate(instance,[reconstruct,diff],type,_oldProps,newProps,fiber){reconstruct?switchInstance(instance,type,newProps,fiber):applyProps$1(instance,diff)},commitMount(instance,_type,_props,_int){var _instance$__r3f3;
_type=null!=(_instance$__r3f3=instance.__r3f)?_instance$__r3f3:{};instance.raycast&&_type.handlers&&_type.eventCount&&instance.__r3f.root.getState().internal.interaction.push(instance)},getPublicInstance:instance=>instance,prepareForCommit:()=>null,preparePortalMount:container=>prepare(container.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(instance){var _instance$__r3f4;const {attach:type,parent}=null!=(_instance$__r3f4=instance.__r3f)?_instance$__r3f4:
{};type&&parent&&detach(parent,instance,type);instance.isObject3D&&(instance.visible=!1);invalidateInstance(instance)},unhideInstance(instance,props){var _instance$__r3f5;const {attach:type,parent}=null!=(_instance$__r3f5=instance.__r3f)?_instance$__r3f5:{};type&&parent&&attach$jscomp$0(parent,instance,type);if(instance.isObject3D&&null==props.visible||props.visible)instance.visible=!0;invalidateInstance(instance)},createTextInstance:_roots,hideTextInstance:_roots,unhideTextInstance:_roots,getCurrentEventPriority:()=>
_getEventPriority?_getEventPriority():constants.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:"undefined"!==typeof performance&&is.fun(performance.now)?performance.now:is.fun(Date.now)?Date.now:()=>0,scheduleTimeout:is.fun(setTimeout)?setTimeout:void 0,cancelTimeout:is.fun(clearTimeout)?clearTimeout:void 0}),applyProps:applyProps$1}}(roots$jscomp$0,function(){var _globalScope$event;const globalScope="undefined"!==typeof self&&
self||"undefined"!==typeof window&&window;if(!globalScope)return constants.DefaultEventPriority;switch(null==(_globalScope$event=globalScope.event)?void 0:_globalScope$event.type){case "click":case "contextmenu":case "dblclick":case "pointercancel":case "pointerdown":case "pointerup":return constants.DiscreteEventPriority;case "pointermove":case "pointerout":case "pointerover":case "pointerenter":case "pointerleave":case "wheel":return constants.ContinuousEventPriority;default:return constants.DefaultEventPriority}}),
shallowLoose={objects:"shallow",strict:!1},createRendererInstance=(gl,canvas)=>{const customRenderer="function"===typeof gl?gl(canvas):gl;return null!=customRenderer&&customRenderer.render?customRenderer:new THREE__namespace.WebGLRenderer({powerPreference:"high-performance",canvas,antialias:!0,alpha:!0,...gl})};reconciler.injectIntoDevTools({bundleType:1,rendererPackageName:"@react-three/fiber",version:React__namespace.version});_window$document=React__namespace.unstable_act;exports.Block=function({set}){useIsomorphicLayoutEffect(()=>
{set(new Promise(()=>null));return()=>set(!1)},[set]);return null};exports.ErrorBoundary=ErrorBoundary;exports.act=_window$document;exports.addAfterEffect=callback=>createSubs(callback,globalAfterEffects);exports.addEffect=callback=>createSubs(callback,globalEffects);exports.addTail=callback=>createSubs(callback,globalTailEffects);exports.advance=advance$jscomp$0;exports.applyProps=applyProps;exports.context=context;exports.createEvents=function(store){function calculateDistance(event){const {internal}=
store.getState(),dx=event.offsetX-internal.initialClick[0];event=event.offsetY-internal.initialClick[1];return Math.round(Math.sqrt(dx*dx+event*event))}function filterPointerEvents(objects){return objects.filter(obj=>["Move","Over","Enter","Out","Leave"].some(name=>{var _r3f;return null==(_r3f=obj.__r3f)?void 0:_r3f.handlers["onPointer"+name]}))}function intersect(event,filter){const state$jscomp$0=store.getState(),duplicates=new Set,intersections=[];filter=filter?filter(state$jscomp$0.internal.interaction):
state$jscomp$0.internal.interaction;for(let i=0;i<filter.length;i++){const state=getRootState(filter[i]);state&&(state.raycaster.camera=void 0)}state$jscomp$0.previousRoot||(null==state$jscomp$0.events.compute?void 0:state$jscomp$0.events.compute(event,state$jscomp$0));filter=filter.flatMap(function(obj){const state=getRootState(obj);if(!state||!state.events.enabled||null===state.raycaster.camera)return[];if(void 0===state.raycaster.camera){var _state$previousRoot;null==state.events.compute?void 0:
state.events.compute(event,state,null==(_state$previousRoot=state.previousRoot)?void 0:_state$previousRoot.getState());void 0===state.raycaster.camera&&(state.raycaster.camera=null)}return state.raycaster.camera?state.raycaster.intersectObject(obj,!0):[]}).sort((a,b)=>{const aState=getRootState(a.object),bState=getRootState(b.object);return aState&&bState?bState.events.priority-aState.events.priority||a.distance-b.distance:a.distance-b.distance}).filter(item=>{item=makeId(item);if(duplicates.has(item))return!1;
duplicates.add(item);return!0});state$jscomp$0.events.filter&&(filter=state$jscomp$0.events.filter(filter,state$jscomp$0));for(const hit of filter)for(filter=hit.object;filter;){var _r3f2;null!=(_r3f2=filter.__r3f)&&_r3f2.eventCount&&intersections.push({...hit,eventObject:filter});filter=filter.parent}if("pointerId"in event&&state$jscomp$0.internal.capturedMap.has(event.pointerId))for(let captureData of state$jscomp$0.internal.capturedMap.get(event.pointerId).values())duplicates.has(makeId(captureData.intersection))||
intersections.push(captureData.intersection);return intersections}function handleIntersects(intersections,event,delta,callback){const rootState=store.getState();if(intersections.length){var JSCompiler_object_inline_stopped_3040=!1;for(const hit of intersections){var state=getRootState(hit.object)||rootState;const {raycaster,pointer,camera,internal}=state;state=(new THREE__namespace.Vector3(pointer.x,pointer.y,0)).unproject(camera);const hasPointerCapture=id=>{var _internal$capturedMap,_internal$capturedMap2;
return null!=(_internal$capturedMap=null==(_internal$capturedMap2=internal.capturedMap.get(id))?void 0:_internal$capturedMap2.has(hit.eventObject))?_internal$capturedMap:!1},setPointerCapture=id=>{const captureData={intersection:hit,target:event.target};internal.capturedMap.has(id)?internal.capturedMap.get(id).set(hit.eventObject,captureData):internal.capturedMap.set(id,new Map([[hit.eventObject,captureData]]));event.target.setPointerCapture(id)},releasePointerCapture=id=>{const captures=internal.capturedMap.get(id);
captures&&releaseInternalPointerCapture(internal.capturedMap,hit.eventObject,captures,id)};let extractEventProps={};for(let prop in event){let property=event[prop];"function"!==typeof property&&(extractEventProps[prop]=property)}let raycastEvent={...hit,...extractEventProps,pointer,intersections,stopped:JSCompiler_object_inline_stopped_3040,delta,unprojectedPoint:state,ray:raycaster.ray,camera,stopPropagation(){var capturesForPointer="pointerId"in event&&internal.capturedMap.get(event.pointerId);
if(!capturesForPointer||capturesForPointer.has(hit.eventObject))raycastEvent.stopped=JSCompiler_object_inline_stopped_3040=!0,internal.hovered.size&&Array.from(internal.hovered.values()).find(i=>i.eventObject===hit.eventObject)&&(capturesForPointer=intersections.slice(0,intersections.indexOf(hit)),cancelPointer([...capturesForPointer,hit]))},target:{hasPointerCapture,setPointerCapture,releasePointerCapture},currentTarget:{hasPointerCapture,setPointerCapture,releasePointerCapture},nativeEvent:event};
callback(raycastEvent);if(!0===JSCompiler_object_inline_stopped_3040)break}}return intersections}function cancelPointer(intersections){const {internal}=store.getState();for(const hoveredObj of internal.hovered.values())if(!intersections.length||!intersections.find(hit=>hit.object===hoveredObj.object&&hit.index===hoveredObj.index&&hit.instanceId===hoveredObj.instanceId)){var instance=hoveredObj.eventObject.__r3f;const handlers=null==instance?void 0:instance.handlers;internal.hovered.delete(makeId(hoveredObj));
null!=instance&&instance.eventCount&&(instance={...hoveredObj,intersections},null==handlers.onPointerOut?void 0:handlers.onPointerOut(instance),null==handlers.onPointerLeave?void 0:handlers.onPointerLeave(instance))}}function pointerMissed(event,objects){for(let i=0;i<objects.length;i++){const instance=objects[i].__r3f;null==instance?void 0:null==instance.handlers.onPointerMissed?void 0:instance.handlers.onPointerMissed(event)}}return{handlePointer:function(name){switch(name){case "onPointerLeave":case "onPointerCancel":return()=>
cancelPointer([]);case "onLostPointerCapture":return event=>{const {internal}=store.getState();"pointerId"in event&&internal.capturedMap.has(event.pointerId)&&(internal.capturedMap.delete(event.pointerId),cancelPointer([]))}}return function(event){const {onPointerMissed,internal}=store.getState();internal.lastEvent.current=event;const isPointerMove="onPointerMove"===name,isClickEvent="onClick"===name||"onContextMenu"===name||"onDoubleClick"===name,hits=intersect(event,isPointerMove?filterPointerEvents:
void 0),delta=isClickEvent?calculateDistance(event):0;"onPointerDown"===name&&(internal.initialClick=[event.offsetX,event.offsetY],internal.initialHits=hits.map(hit=>hit.eventObject));isClickEvent&&!hits.length&&2>=delta&&(pointerMissed(event,internal.interaction),onPointerMissed&&onPointerMissed(event));isPointerMove&&cancelPointer(hits);handleIntersects(hits,event,delta,function(data){var eventObject=data.eventObject,instance=eventObject.__r3f,handlers=null==instance?void 0:instance.handlers;if(null!=
instance&&instance.eventCount)if(isPointerMove){if(handlers.onPointerOver||handlers.onPointerEnter||handlers.onPointerOut||handlers.onPointerLeave)eventObject=makeId(data),(instance=internal.hovered.get(eventObject))?instance.stopped&&data.stopPropagation():(internal.hovered.set(eventObject,data),null==handlers.onPointerOver?void 0:handlers.onPointerOver(data),null==handlers.onPointerEnter?void 0:handlers.onPointerEnter(data));null==handlers.onPointerMove?void 0:handlers.onPointerMove(data)}else if(handlers=
handlers[name]){if(!isClickEvent||internal.initialHits.includes(eventObject))pointerMissed(event,internal.interaction.filter(object=>!internal.initialHits.includes(object))),handlers(data)}else isClickEvent&&internal.initialHits.includes(eventObject)&&pointerMissed(event,internal.interaction.filter(object=>!internal.initialHits.includes(object)))})}}}};exports.createPortal=function(children,container,state){return React__namespace.createElement(Portal,{key:container.uuid,children,container,state})};
exports.createRoot=createRoot;exports.dispose=dispose$jscomp$0;exports.extend=objects=>void(catalogue={...catalogue,...objects});exports.flushGlobalEffects=flushGlobalEffects;exports.getRootState=getRootState;exports.invalidate=invalidate$jscomp$0;exports.isRef=obj=>obj&&obj.hasOwnProperty("current");exports.reconciler=reconciler;exports.render=function(children,canvas,config){console.warn("R3F.render is no longer supported in React 18. Use createRoot instead!");canvas=createRoot(canvas);canvas.configure(config);
return canvas.render(children)};exports.roots=roots$jscomp$0;exports.threeTypes=require;exports.unmountComponentAtNode=unmountComponentAtNode;exports.useFrame=function(callback,renderPriority=0){const store=useStore(),subscribe=store.getState().internal.subscribe,ref=useMutableCallback(callback);useIsomorphicLayoutEffect(()=>subscribe(ref,renderPriority,store),[renderPriority,subscribe,store]);return null};exports.useGraph=function(object){return React__namespace.useMemo(()=>buildGraph(object),[object])};
exports.useInstanceHandle=function(ref){const instance=React__namespace.useRef(null);useIsomorphicLayoutEffect(()=>void(instance.current=ref.current.__r3f),[ref]);return instance};exports.useIsomorphicLayoutEffect=useIsomorphicLayoutEffect;exports.useLoader=useLoader;exports.useMutableCallback=useMutableCallback;exports.useStore=useStore;exports.useThree=function(selector=state=>state,equalityFn){return useStore()(selector,equalityFn)}}
//# sourceMappingURL=module$node_modules$$react_three$fiber$dist$index_8539ced2_cjs_dev.js.map

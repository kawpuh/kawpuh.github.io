shadow$provide.module$node_modules$react_reconciler$cjs$react_reconciler_development=function(global,require,module,exports$jscomp$0){module.exports=function($$$hostConfig){function warn(format){if(!suppressWarning){for(var _len=arguments.length,args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];printWarning("warn",format,args)}}function error$jscomp$0(format){if(!suppressWarning){for(var _len2=arguments.length,args=Array(1<_len2?_len2-1:0),_key2=1;_key2<_len2;_key2++)args[_key2-
1]=arguments[_key2];printWarning("error",format,args)}}function printWarning(level,format,args){var stack=ReactSharedInternals.ReactDebugCurrentFrame.getStackAddendum();""!==stack&&(format+="%s",args=args.concat([stack]));args=args.map(function(item){return String(item)});args.unshift("Warning: "+format);Function.prototype.apply.call(console[level],console,args)}function getIteratorFn(maybeIterable){if(null===maybeIterable||"object"!==typeof maybeIterable)return null;maybeIterable=MAYBE_ITERATOR_SYMBOL&&
maybeIterable[MAYBE_ITERATOR_SYMBOL]||maybeIterable["@@iterator"];return"function"===typeof maybeIterable?maybeIterable:null}function getComponentNameFromType(type){if(null==type)return null;"number"===typeof type.tag&&error$jscomp$0("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue.");if("function"===typeof type)return type.displayName||type.name||null;if("string"===typeof type)return type;switch(type){case REACT_FRAGMENT_TYPE:return"Fragment";
case REACT_PORTAL_TYPE:return"Portal";case REACT_PROFILER_TYPE:return"Profiler";case REACT_STRICT_MODE_TYPE:return"StrictMode";case REACT_SUSPENSE_TYPE:return"Suspense";case REACT_SUSPENSE_LIST_TYPE:return"SuspenseList"}if("object"===typeof type)switch(type.$$typeof){case REACT_CONTEXT_TYPE:return(type.displayName||"Context")+".Consumer";case REACT_PROVIDER_TYPE:return(type._context.displayName||"Context")+".Provider";case REACT_FORWARD_REF_TYPE:var innerType=type.render;type=type.displayName;type||
(type=innerType.displayName||innerType.name||"",type=""!==type?"ForwardRef("+type+")":"ForwardRef");return type;case REACT_MEMO_TYPE:return innerType=type.displayName||null,null!==innerType?innerType:getComponentNameFromType(type.type)||"Memo";case REACT_LAZY_TYPE:innerType=type._payload;type=type._init;try{return getComponentNameFromType(type(innerType))}catch(x){}}return null}function getComponentNameFromFiber(fiber){var type=fiber.type;switch(fiber.tag){case 24:return"Cache";case 9:return(type.displayName||
"Context")+".Consumer";case 10:return(type._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return fiber=type.render,fiber=fiber.displayName||fiber.name||"",type.displayName||(""!==fiber?"ForwardRef("+fiber+")":"ForwardRef");case 7:return"Fragment";case 5:return type;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return getComponentNameFromType(type);case 8:return type===REACT_STRICT_MODE_TYPE?"StrictMode":"Mode";case 22:return"Offscreen";
case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof type)return type.displayName||type.name||null;if("string"===typeof type)return type}return null}function getNearestMountedFiber(fiber){var node=fiber,nearestMounted=fiber;if(fiber.alternate)for(;node.return;)node=node.return;else{fiber=node;do node=fiber,0!==(node.flags&4098)&&(nearestMounted=node.return),
fiber=node.return;while(fiber)}return 3===node.tag?nearestMounted:null}function assertIsMounted(fiber){if(getNearestMountedFiber(fiber)!==fiber)throw Error("Unable to find node on an unmounted component.");}function findCurrentFiberUsingSlowPath(fiber){var alternate=fiber.alternate;if(!alternate){alternate=getNearestMountedFiber(fiber);if(null===alternate)throw Error("Unable to find node on an unmounted component.");return alternate!==fiber?null:fiber}for(var a=fiber,b=alternate;;){var parentA=a.return;
if(null===parentA)break;var parentB=parentA.alternate;if(null===parentB){b=parentA.return;if(null!==b){a=b;continue}break}if(parentA.child===parentB.child){for(parentB=parentA.child;parentB;){if(parentB===a)return assertIsMounted(parentA),fiber;if(parentB===b)return assertIsMounted(parentA),alternate;parentB=parentB.sibling}throw Error("Unable to find node on an unmounted component.");}if(a.return!==b.return)a=parentA,b=parentB;else{for(var didFindChild=!1,_child=parentA.child;_child;){if(_child===
a){didFindChild=!0;a=parentA;b=parentB;break}if(_child===b){didFindChild=!0;b=parentA;a=parentB;break}_child=_child.sibling}if(!didFindChild){for(_child=parentB.child;_child;){if(_child===a){didFindChild=!0;a=parentB;b=parentA;break}if(_child===b){didFindChild=!0;b=parentB;a=parentA;break}_child=_child.sibling}if(!didFindChild)throw Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");}}if(a.alternate!==b)throw Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
}if(3!==a.tag)throw Error("Unable to find node on an unmounted component.");return a.stateNode.current===a?fiber:alternate}function findCurrentHostFiber(parent){parent=findCurrentFiberUsingSlowPath(parent);return null!==parent?findCurrentHostFiberImpl(parent):null}function findCurrentHostFiberImpl(node){if(5===node.tag||6===node.tag)return node;for(node=node.child;null!==node;){var match=findCurrentHostFiberImpl(node);if(null!==match)return match;node=node.sibling}return null}function findCurrentHostFiberWithNoPortalsImpl(node){if(5===
node.tag||6===node.tag)return node;for(node=node.child;null!==node;){if(4!==node.tag){var match=findCurrentHostFiberWithNoPortalsImpl(node);if(null!==match)return match}node=node.sibling}return null}function disabledLog(){}function disableLogs(){if(0===disabledDepth){prevLog=console.log;prevInfo=console.info;prevWarn=console.warn;prevError=console.error;prevGroup=console.group;prevGroupCollapsed=console.groupCollapsed;prevGroupEnd=console.groupEnd;var props={configurable:!0,enumerable:!0,value:disabledLog,
writable:!0};Object.defineProperties(console,{info:props,log:props,warn:props,error:props,group:props,groupCollapsed:props,groupEnd:props})}disabledDepth++}function reenableLogs(){disabledDepth--;if(0===disabledDepth){var props={configurable:!0,enumerable:!0,writable:!0};Object.defineProperties(console,{log:assign({},props,{value:prevLog}),info:assign({},props,{value:prevInfo}),warn:assign({},props,{value:prevWarn}),error:assign({},props,{value:prevError}),group:assign({},props,{value:prevGroup}),
groupCollapsed:assign({},props,{value:prevGroupCollapsed}),groupEnd:assign({},props,{value:prevGroupEnd})})}0>disabledDepth&&error$jscomp$0("disabledDepth fell below zero. This is a bug in React. Please file an issue.")}function describeBuiltInComponentFrame(name,source,ownerFn){if(void 0===prefix)try{throw Error();}catch(x){prefix=(source=x.stack.trim().match(/\n( *(at )?)/))&&source[1]||""}return"\n"+prefix+name}function describeNativeComponentFrame(fn,construct){if(!fn||reentry)return"";var frame=
componentFrameCache.get(fn);if(void 0!==frame)return frame;reentry=!0;frame=Error.prepareStackTrace;Error.prepareStackTrace=void 0;var previousDispatcher=ReactCurrentDispatcher.current;ReactCurrentDispatcher.current=null;disableLogs();try{if(construct)if(construct=function(){throw Error();},Object.defineProperty(construct.prototype,"props",{set:function(){throw Error();}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(construct,[])}catch(x){var control=x}Reflect.construct(fn,
[],construct)}else{try{construct.call()}catch(x){control=x}fn.call(construct.prototype)}else{try{throw Error();}catch(x){control=x}fn()}}catch(sample){if(sample&&control&&"string"===typeof sample.stack){for(var sampleLines=sample.stack.split("\n"),controlLines=control.stack.split("\n"),s=sampleLines.length-1,c=controlLines.length-1;1<=s&&0<=c&&sampleLines[s]!==controlLines[c];)c--;for(;1<=s&&0<=c;s--,c--)if(sampleLines[s]!==controlLines[c]){if(1!==s||1!==c){do if(s--,c--,0>c||sampleLines[s]!==controlLines[c]){var _frame=
"\n"+sampleLines[s].replace(" at new "," at ");fn.displayName&&_frame.includes("\x3canonymous\x3e")&&(_frame=_frame.replace("\x3canonymous\x3e",fn.displayName));"function"===typeof fn&&componentFrameCache.set(fn,_frame);return _frame}while(1<=s&&0<=c)}break}}}finally{reentry=!1,ReactCurrentDispatcher.current=previousDispatcher,reenableLogs(),Error.prepareStackTrace=frame}control=(control=fn?fn.displayName||fn.name:"")?describeBuiltInComponentFrame(control):"";"function"===typeof fn&&componentFrameCache.set(fn,
control);return control}function describeUnknownElementTypeFrameInDEV(type,source,ownerFn){if(null==type)return"";if("function"===typeof type)return source=type.prototype,describeNativeComponentFrame(type,!(!source||!source.isReactComponent));if("string"===typeof type)return describeBuiltInComponentFrame(type);switch(type){case REACT_SUSPENSE_TYPE:return describeBuiltInComponentFrame("Suspense");case REACT_SUSPENSE_LIST_TYPE:return describeBuiltInComponentFrame("SuspenseList")}if("object"===typeof type)switch(type.$$typeof){case REACT_FORWARD_REF_TYPE:return type=
describeNativeComponentFrame(type.render,!1),type;case REACT_MEMO_TYPE:return describeUnknownElementTypeFrameInDEV(type.type,source,ownerFn);case REACT_LAZY_TYPE:var payload=type._payload;type=type._init;try{return describeUnknownElementTypeFrameInDEV(type(payload),source,ownerFn)}catch(x){}}return""}function setCurrentlyValidatingElement(element){if(element){var owner=element._owner;element=describeUnknownElementTypeFrameInDEV(element.type,element._source,owner?owner.type:null);ReactDebugCurrentFrame.setExtraStackFrame(element)}else ReactDebugCurrentFrame.setExtraStackFrame(null)}
function checkPropTypes(typeSpecs,values,location,componentName,element){var has=Function.call.bind(hasOwnProperty),typeSpecName;for(typeSpecName in typeSpecs)if(has(typeSpecs,typeSpecName)){var error$1=void 0;try{if("function"!==typeof typeSpecs[typeSpecName]){var err=Error((componentName||"React class")+": "+location+" type `"+typeSpecName+"` is invalid; it must be a function, usually from the `prop-types` package, but received `"+typeof typeSpecs[typeSpecName]+"`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
err.name="Invariant Violation";throw err;}error$1=typeSpecs[typeSpecName](values,typeSpecName,componentName,location,null,"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED")}catch(ex){error$1=ex}!error$1||error$1 instanceof Error||(setCurrentlyValidatingElement(element),error$jscomp$0("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).",
componentName||"React class",location,typeSpecName,typeof error$1),setCurrentlyValidatingElement(null));error$1 instanceof Error&&!(error$1.message in loggedTypeFailures)&&(loggedTypeFailures[error$1.message]=!0,setCurrentlyValidatingElement(element),error$jscomp$0("Failed %s type: %s",location,error$1.message),setCurrentlyValidatingElement(null))}}function createCursor(defaultValue){return{current:defaultValue}}function pop(cursor,fiber){0>index$jscomp$0?error$jscomp$0("Unexpected pop."):(fiber!==
fiberStack[index$jscomp$0]&&error$jscomp$0("Unexpected Fiber popped."),cursor.current=valueStack[index$jscomp$0],valueStack[index$jscomp$0]=null,fiberStack[index$jscomp$0]=null,index$jscomp$0--)}function push(cursor,value,fiber){index$jscomp$0++;valueStack[index$jscomp$0]=cursor.current;fiberStack[index$jscomp$0]=fiber;cursor.current=value}function getMaskedContext(workInProgress,unmaskedContext){var contextTypes=workInProgress.type.contextTypes;if(!contextTypes)return emptyContextObject;var instance=
workInProgress.stateNode;if(instance&&instance.__reactInternalMemoizedUnmaskedChildContext===unmaskedContext)return instance.__reactInternalMemoizedMaskedChildContext;var context={};for(key in contextTypes)context[key]=unmaskedContext[key];var key=getComponentNameFromFiber(workInProgress)||"Unknown";checkPropTypes(contextTypes,context,"context",key);instance&&(workInProgress=workInProgress.stateNode,workInProgress.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext,workInProgress.__reactInternalMemoizedMaskedChildContext=
context);return context}function isContextProvider(type){type=type.childContextTypes;return null!==type&&void 0!==type}function popContext(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber)}function popTopLevelContextObject(fiber){pop(didPerformWorkStackCursor,fiber);pop(contextStackCursor,fiber)}function pushTopLevelContextObject(fiber,context,didChange){if(contextStackCursor.current!==emptyContextObject)throw Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
push(contextStackCursor,context,fiber);push(didPerformWorkStackCursor,didChange,fiber)}function processChildContext(fiber,type,parentContext){var instance=fiber.stateNode;type=type.childContextTypes;if("function"!==typeof instance.getChildContext)return fiber=getComponentNameFromFiber(fiber)||"Unknown",warnedAboutMissingGetChildContext[fiber]||(warnedAboutMissingGetChildContext[fiber]=!0,error$jscomp$0("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.",
fiber,fiber)),parentContext;instance=instance.getChildContext();for(var contextKey in instance)if(!(contextKey in type))throw Error((getComponentNameFromFiber(fiber)||"Unknown")+'.getChildContext(): key "'+contextKey+'" is not defined in childContextTypes.');fiber=getComponentNameFromFiber(fiber)||"Unknown";checkPropTypes(type,instance,"child context",fiber);return assign({},parentContext,instance)}function pushContextProvider(workInProgress){var instance=workInProgress.stateNode;instance=instance&&
instance.__reactInternalMemoizedMergedChildContext||emptyContextObject;previousContext=contextStackCursor.current;push(contextStackCursor,instance,workInProgress);push(didPerformWorkStackCursor,didPerformWorkStackCursor.current,workInProgress);return!0}function invalidateContextProvider(workInProgress,type,didChange){var instance=workInProgress.stateNode;if(!instance)throw Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");didChange?
(type=processChildContext(workInProgress,type,previousContext),instance.__reactInternalMemoizedMergedChildContext=type,pop(didPerformWorkStackCursor,workInProgress),pop(contextStackCursor,workInProgress),push(contextStackCursor,type,workInProgress)):pop(didPerformWorkStackCursor,workInProgress);push(didPerformWorkStackCursor,didChange,workInProgress)}function clz32Fallback(x){x>>>=0;return 0===x?32:31-(log(x)/LN2|0)|0}function getLabelForLane(lane){if(lane&1)return"Sync";if(lane&2)return"InputContinuousHydration";
if(lane&4)return"InputContinuous";if(lane&8)return"DefaultHydration";if(lane&16)return"Default";if(lane&32)return"TransitionHydration";if(lane&4194240)return"Transition";if(lane&130023424)return"Retry";if(lane&134217728)return"SelectiveHydration";if(lane&268435456)return"IdleHydration";if(lane&536870912)return"Idle";if(lane&1073741824)return"Offscreen"}function getHighestPriorityLanes(lanes){switch(lanes&-lanes){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;
case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return lanes&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return lanes&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return error$jscomp$0("Should have found matching lanes. This is a bug in React."),
lanes}}function getNextLanes(root,wipLanes){var pendingLanes=root.pendingLanes;if(0===pendingLanes)return 0;var nextLanes=0,suspendedLanes=root.suspendedLanes,pingedLanes=root.pingedLanes,nonIdlePendingLanes=pendingLanes&268435455;if(0!==nonIdlePendingLanes){var nonIdleUnblockedLanes=nonIdlePendingLanes&~suspendedLanes;0!==nonIdleUnblockedLanes?nextLanes=getHighestPriorityLanes(nonIdleUnblockedLanes):(pingedLanes&=nonIdlePendingLanes,0!==pingedLanes&&(nextLanes=getHighestPriorityLanes(pingedLanes)))}else nonIdlePendingLanes=
pendingLanes&~suspendedLanes,0!==nonIdlePendingLanes?nextLanes=getHighestPriorityLanes(nonIdlePendingLanes):0!==pingedLanes&&(nextLanes=getHighestPriorityLanes(pingedLanes));if(0===nextLanes)return 0;if(0!==wipLanes&&wipLanes!==nextLanes&&0===(wipLanes&suspendedLanes)&&(suspendedLanes=nextLanes&-nextLanes,pingedLanes=wipLanes&-wipLanes,suspendedLanes>=pingedLanes||16===suspendedLanes&&0!==(pingedLanes&4194240)))return wipLanes;0!==(nextLanes&4)&&(nextLanes|=pendingLanes&16);wipLanes=root.entangledLanes;
if(0!==wipLanes)for(root=root.entanglements,wipLanes&=nextLanes;0<wipLanes;)pendingLanes=31-clz32(wipLanes),suspendedLanes=1<<pendingLanes,nextLanes|=root[pendingLanes],wipLanes&=~suspendedLanes;return nextLanes}function computeExpirationTime(lane,currentTime){switch(lane){case 1:case 2:case 4:return currentTime+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return currentTime+
5E3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return error$jscomp$0("Should have found matching lanes. This is a bug in React."),-1}}function markStarvedLanesAsExpired(root,currentTime){for(var suspendedLanes=root.suspendedLanes,pingedLanes=root.pingedLanes,expirationTimes=root.expirationTimes,lanes=root.pendingLanes;0<lanes;){var index=31-clz32(lanes),lane=1<<index,expirationTime=expirationTimes[index];
if(-1===expirationTime){if(0===(lane&suspendedLanes)||0!==(lane&pingedLanes))expirationTimes[index]=computeExpirationTime(lane,currentTime)}else expirationTime<=currentTime&&(root.expiredLanes|=lane);lanes&=~lane}}function getLanesToRetrySynchronouslyOnError(root){root=root.pendingLanes&-1073741825;return 0!==root?root:root&1073741824?1073741824:0}function createLaneMap(initial){for(var laneMap=[],i=0;31>i;i++)laneMap.push(initial);return laneMap}function markRootUpdated(root,updateLane,eventTime){root.pendingLanes|=
updateLane;536870912!==updateLane&&(root.suspendedLanes=0,root.pingedLanes=0);root=root.eventTimes;updateLane=31-clz32(updateLane);root[updateLane]=eventTime}function markRootFinished(root,remainingLanes){var noLongerPendingLanes=root.pendingLanes&~remainingLanes;root.pendingLanes=remainingLanes;root.suspendedLanes=0;root.pingedLanes=0;root.expiredLanes&=remainingLanes;root.mutableReadLanes&=remainingLanes;root.entangledLanes&=remainingLanes;remainingLanes=root.entanglements;var eventTimes=root.eventTimes;
for(root=root.expirationTimes;0<noLongerPendingLanes;){var index=31-clz32(noLongerPendingLanes),lane=1<<index;remainingLanes[index]=0;eventTimes[index]=-1;root[index]=-1;noLongerPendingLanes&=~lane}}function markRootEntangled(root,entangledLanes){var rootEntangledLanes=root.entangledLanes|=entangledLanes;for(root=root.entanglements;rootEntangledLanes;){var index=31-clz32(rootEntangledLanes),lane=1<<index;lane&entangledLanes|root[index]&entangledLanes&&(root[index]|=entangledLanes);rootEntangledLanes&=
~lane}}function addFiberToLanesMap(root,fiber,lanes){if(isDevToolsPresent)for(root=root.pendingUpdatersLaneMap;0<lanes;){var index=31-clz32(lanes),lane=1<<index;root[index].add(fiber);lanes&=~lane}}function movePendingFibersToMemoized(root,lanes){if(isDevToolsPresent)for(var pendingUpdatersLaneMap=root.pendingUpdatersLaneMap,memoizedUpdaters=root.memoizedUpdaters;0<lanes;){var index=31-clz32(lanes);root=1<<index;index=pendingUpdatersLaneMap[index];0<index.size&&(index.forEach(function(fiber){var alternate=
fiber.alternate;null!==alternate&&memoizedUpdaters.has(alternate)||memoizedUpdaters.add(fiber)}),index.clear());lanes&=~root}}function lanesToEventPriority(lanes){lanes&=-lanes;return 1<lanes?4<lanes?0!==(lanes&268435455)?16:536870912:4:1}function injectInternals(internals){if("undefined"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__)return!1;var hook=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(hook.isDisabled)return!0;if(!hook.supportsFiber)return error$jscomp$0("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"),
!0;try{internals=assign({},internals,{getLaneLabelMap,injectProfilingHooks}),rendererID=hook.inject(internals),injectedHook=hook}catch(err){error$jscomp$0("React instrumentation encountered an error: %s.",err)}return hook.checkDCE?!0:!1}function onCommitRoot(root,eventPriority){if(injectedHook&&"function"===typeof injectedHook.onCommitFiberRoot)try{var didError=128===(root.current.flags&128);switch(eventPriority){case 1:var schedulerPriority=ImmediatePriority;break;case 4:schedulerPriority=UserBlockingPriority;
break;case 16:schedulerPriority=NormalPriority;break;case 536870912:schedulerPriority=IdlePriority;break;default:schedulerPriority=NormalPriority}injectedHook.onCommitFiberRoot(rendererID,root,schedulerPriority,didError)}catch(err){hasLoggedError||(hasLoggedError=!0,error$jscomp$0("React instrumentation encountered an error: %s",err))}}function setIsStrictModeForDevtools(newIsStrictMode){"function"===typeof unstable_yieldValue&&(unstable_setDisableYieldValue(newIsStrictMode),suppressWarning=newIsStrictMode);
if(injectedHook&&"function"===typeof injectedHook.setStrictMode)try{injectedHook.setStrictMode(rendererID,newIsStrictMode)}catch(err){hasLoggedError||(hasLoggedError=!0,error$jscomp$0("React instrumentation encountered an error: %s",err))}}function injectProfilingHooks(profilingHooks){injectedProfilingHooks=profilingHooks}function getLaneLabelMap(){for(var map=new Map,lane=1,index=0;31>index;index++){var label=getLabelForLane(lane);map.set(lane,label);lane*=2}return map}function markCommitStopped(){null!==
injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markCommitStopped&&injectedProfilingHooks.markCommitStopped()}function markComponentRenderStarted(fiber){null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentRenderStarted&&injectedProfilingHooks.markComponentRenderStarted(fiber)}function markComponentRenderStopped(){null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentRenderStopped&&injectedProfilingHooks.markComponentRenderStopped()}
function markComponentLayoutEffectUnmountStarted(fiber){null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted&&injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber)}function markComponentLayoutEffectUnmountStopped(){null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped&&injectedProfilingHooks.markComponentLayoutEffectUnmountStopped()}function markRenderStarted(lanes){null!==
injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markRenderStarted&&injectedProfilingHooks.markRenderStarted(lanes)}function markRenderStopped(){null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markRenderStopped&&injectedProfilingHooks.markRenderStopped()}function markStateUpdateScheduled(fiber,lane){null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markStateUpdateScheduled&&injectedProfilingHooks.markStateUpdateScheduled(fiber,lane)}
function is(x,y){return x===y&&(0!==x||1/x===1/y)||x!==x&&y!==y}function scheduleSyncCallback(callback){null===syncQueue?syncQueue=[callback]:syncQueue.push(callback)}function scheduleLegacySyncCallback(callback){includesLegacySyncCallbacks=!0;scheduleSyncCallback(callback)}function flushSyncCallbacks(){if(!isFlushingSyncQueue&&null!==syncQueue){isFlushingSyncQueue=!0;var i=0,previousUpdatePriority=currentUpdatePriority;try{var queue=syncQueue;for(currentUpdatePriority=1;i<queue.length;i++){var callback=
queue[i];do callback=callback(!0);while(null!==callback)}syncQueue=null;includesLegacySyncCallbacks=!1}catch(error){throw null!==syncQueue&&(syncQueue=syncQueue.slice(i+1)),scheduleCallback(ImmediatePriority,flushSyncCallbacks),error;}finally{currentUpdatePriority=previousUpdatePriority,isFlushingSyncQueue=!1}}return null}function shallowEqual(objA,objB){if(objectIs(objA,objB))return!0;if("object"!==typeof objA||null===objA||"object"!==typeof objB||null===objB)return!1;var keysA=Object.keys(objA),
keysB=Object.keys(objB);if(keysA.length!==keysB.length)return!1;for(keysB=0;keysB<keysA.length;keysB++){var currentKey=keysA[keysB];if(!hasOwnProperty.call(objB,currentKey)||!objectIs(objA[currentKey],objB[currentKey]))return!1}return!0}function describeFiber(fiber){switch(fiber.tag){case 5:return describeBuiltInComponentFrame(fiber.type);case 16:return describeBuiltInComponentFrame("Lazy");case 13:return describeBuiltInComponentFrame("Suspense");case 19:return describeBuiltInComponentFrame("SuspenseList");
case 0:case 2:case 15:return fiber=describeNativeComponentFrame(fiber.type,!1),fiber;case 11:return fiber=describeNativeComponentFrame(fiber.type.render,!1),fiber;case 1:return fiber=describeNativeComponentFrame(fiber.type,!0),fiber;default:return""}}function getStackByFiberInDevAndProd(workInProgress){try{var info="";do info+=describeFiber(workInProgress),workInProgress=workInProgress.return;while(workInProgress);return info}catch(x){return"\nError generating stack: "+x.message+"\n"+x.stack}}function getCurrentFiberStackInDev(){return null===
current$jscomp$1?"":getStackByFiberInDevAndProd(current$jscomp$1)}function resetCurrentFiber(){current$jscomp$1=ReactDebugCurrentFrame$1.getCurrentStack=null;isRendering=!1}function setCurrentFiber(fiber){ReactDebugCurrentFrame$1.getCurrentStack=getCurrentFiberStackInDev;current$jscomp$1=fiber;isRendering=!1}function resolveDefaultProps(Component,baseProps){if(Component&&Component.defaultProps){baseProps=assign({},baseProps);Component=Component.defaultProps;for(var propName in Component)void 0===
baseProps[propName]&&(baseProps[propName]=Component[propName]);return baseProps}return baseProps}function resetContextDependencies(){lastFullyObservedContext=lastContextDependency=currentlyRenderingFiber=null;isDisallowedContextReadInDEV=!1}function pushProvider(providerFiber,context,nextValue){isPrimaryRenderer?(push(valueCursor,context._currentValue,providerFiber),context._currentValue=nextValue,void 0!==context._currentRenderer&&null!==context._currentRenderer&&context._currentRenderer!==rendererSigil&&
error$jscomp$0("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."),context._currentRenderer=rendererSigil):(push(valueCursor,context._currentValue2,providerFiber),context._currentValue2=nextValue,void 0!==context._currentRenderer2&&null!==context._currentRenderer2&&context._currentRenderer2!==rendererSigil&&error$jscomp$0("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."),context._currentRenderer2=
rendererSigil)}function popProvider(context,providerFiber){var currentValue=valueCursor.current;pop(valueCursor,providerFiber);isPrimaryRenderer?context._currentValue=currentValue:context._currentValue2=currentValue}function scheduleContextWorkOnParentPath(parent,renderLanes,propagationRoot){for(;null!==parent;){var alternate=parent.alternate;(parent.childLanes&renderLanes)!==renderLanes?(parent.childLanes|=renderLanes,null!==alternate&&(alternate.childLanes|=renderLanes)):null!==alternate&&(alternate.childLanes&
renderLanes)!==renderLanes&&(alternate.childLanes|=renderLanes);if(parent===propagationRoot)break;parent=parent.return}parent!==propagationRoot&&error$jscomp$0("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.")}function prepareToReadContext(workInProgress,renderLanes){currentlyRenderingFiber=workInProgress;lastFullyObservedContext=lastContextDependency=null;workInProgress=workInProgress.dependencies;null!==workInProgress&&
null!==workInProgress.firstContext&&(0!==(workInProgress.lanes&renderLanes)&&(didReceiveUpdate=!0),workInProgress.firstContext=null)}function readContext(context){isDisallowedContextReadInDEV&&error$jscomp$0("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");var value=isPrimaryRenderer?context._currentValue:
context._currentValue2;if(lastFullyObservedContext!==context)if(context={context,memoizedValue:value,next:null},null===lastContextDependency){if(null===currentlyRenderingFiber)throw Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");lastContextDependency=context;currentlyRenderingFiber.dependencies=
{lanes:0,firstContext:context}}else lastContextDependency=lastContextDependency.next=context;return value}function initializeUpdateQueue(fiber){fiber.updateQueue={baseState:fiber.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function cloneUpdateQueue(current,workInProgress){current=current.updateQueue;workInProgress.updateQueue===current&&(workInProgress.updateQueue={baseState:current.baseState,firstBaseUpdate:current.firstBaseUpdate,
lastBaseUpdate:current.lastBaseUpdate,shared:current.shared,effects:current.effects})}function createUpdate(eventTime,lane){return{eventTime,lane,tag:UpdateState,payload:null,callback:null,next:null}}function enqueueUpdate(fiber,update,lane){lane=fiber.updateQueue;null!==lane&&(lane=lane.shared,null!==workInProgressRoot&&0!==(fiber.mode&1)&&(executionContext&RenderContext)===NoContext?(fiber=lane.interleaved,null===fiber?(update.next=update,null===interleavedQueues?interleavedQueues=[lane]:interleavedQueues.push(lane)):
(update.next=fiber.next,fiber.next=update),lane.interleaved=update):(fiber=lane.pending,null===fiber?update.next=update:(update.next=fiber.next,fiber.next=update),lane.pending=update),currentlyProcessingQueue!==lane||didWarnUpdateInsideUpdate||(error$jscomp$0("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."),didWarnUpdateInsideUpdate=!0))}function entangleTransitions(root,
fiber,lane){fiber=fiber.updateQueue;if(null!==fiber&&(fiber=fiber.shared,0!==(lane&4194240))){var queueLanes=fiber.lanes;queueLanes&=root.pendingLanes;lane|=queueLanes;fiber.lanes=lane;markRootEntangled(root,lane)}}function enqueueCapturedUpdate(workInProgress,capturedUpdate){var queue=workInProgress.updateQueue,current=workInProgress.alternate;if(null!==current&&(current=current.updateQueue,queue===current)){var newFirst=null,newLast=null;queue=queue.firstBaseUpdate;if(null!==queue){do{var clone=
{eventTime:queue.eventTime,lane:queue.lane,tag:queue.tag,payload:queue.payload,callback:queue.callback,next:null};null===newLast?newFirst=newLast=clone:newLast=newLast.next=clone;queue=queue.next}while(null!==queue);null===newLast?newFirst=newLast=capturedUpdate:newLast=newLast.next=capturedUpdate}else newFirst=newLast=capturedUpdate;queue={baseState:current.baseState,firstBaseUpdate:newFirst,lastBaseUpdate:newLast,shared:current.shared,effects:current.effects};workInProgress.updateQueue=queue;return}workInProgress=
queue.lastBaseUpdate;null===workInProgress?queue.firstBaseUpdate=capturedUpdate:workInProgress.next=capturedUpdate;queue.lastBaseUpdate=capturedUpdate}function processUpdateQueue(workInProgress,props,instance$jscomp$0,renderLanes){var queue=workInProgress.updateQueue;hasForceUpdate=!1;currentlyProcessingQueue=queue.shared;var firstBaseUpdate=queue.firstBaseUpdate,lastBaseUpdate=queue.lastBaseUpdate,pendingQueue=queue.shared.pending;if(null!==pendingQueue){queue.shared.pending=null;var lastPendingUpdate=
pendingQueue,firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=null;null===lastBaseUpdate?firstBaseUpdate=firstPendingUpdate:lastBaseUpdate.next=firstPendingUpdate;lastBaseUpdate=lastPendingUpdate;var current=workInProgress.alternate;null!==current&&(current=current.updateQueue,pendingQueue=current.lastBaseUpdate,pendingQueue!==lastBaseUpdate&&(null===pendingQueue?current.firstBaseUpdate=firstPendingUpdate:pendingQueue.next=firstPendingUpdate,current.lastBaseUpdate=lastPendingUpdate))}if(null!==
firstBaseUpdate){var newState=queue.baseState;lastBaseUpdate=0;current=firstPendingUpdate=lastPendingUpdate=null;pendingQueue=firstBaseUpdate;do{var updateLane=pendingQueue.lane,updateEventTime=pendingQueue.eventTime;if((renderLanes&updateLane)===updateLane){null!==current&&(current=current.next={eventTime:updateEventTime,lane:0,tag:pendingQueue.tag,payload:pendingQueue.payload,callback:pendingQueue.callback,next:null});a:{updateLane=workInProgress;var partialState=pendingQueue;updateEventTime=props;
var instance=instance$jscomp$0;switch(partialState.tag){case 1:partialState=partialState.payload;if("function"===typeof partialState){isDisallowedContextReadInDEV=!0;var nextState=partialState.call(instance,newState,updateEventTime);if(updateLane.mode&8){setIsStrictModeForDevtools(!0);try{partialState.call(instance,newState,updateEventTime)}finally{setIsStrictModeForDevtools(!1)}}isDisallowedContextReadInDEV=!1;newState=nextState;break a}newState=partialState;break a;case 3:updateLane.flags=updateLane.flags&
-65537|128;case UpdateState:nextState=partialState.payload;if("function"===typeof nextState){isDisallowedContextReadInDEV=!0;partialState=nextState.call(instance,newState,updateEventTime);if(updateLane.mode&8){setIsStrictModeForDevtools(!0);try{nextState.call(instance,newState,updateEventTime)}finally{setIsStrictModeForDevtools(!1)}}isDisallowedContextReadInDEV=!1}else partialState=nextState;if(null===partialState||void 0===partialState)break a;newState=assign({},newState,partialState);break a;case ForceUpdate:hasForceUpdate=
!0}}null!==pendingQueue.callback&&0!==pendingQueue.lane&&(workInProgress.flags|=64,updateLane=queue.effects,null===updateLane?queue.effects=[pendingQueue]:updateLane.push(pendingQueue))}else updateEventTime={eventTime:updateEventTime,lane:updateLane,tag:pendingQueue.tag,payload:pendingQueue.payload,callback:pendingQueue.callback,next:null},null===current?(firstPendingUpdate=current=updateEventTime,lastPendingUpdate=newState):current=current.next=updateEventTime,lastBaseUpdate|=updateLane;pendingQueue=
pendingQueue.next;if(null===pendingQueue)if(pendingQueue=queue.shared.pending,null===pendingQueue)break;else updateLane=pendingQueue,pendingQueue=updateLane.next,updateLane.next=null,queue.lastBaseUpdate=updateLane,queue.shared.pending=null}while(1);null===current&&(lastPendingUpdate=newState);queue.baseState=lastPendingUpdate;queue.firstBaseUpdate=firstPendingUpdate;queue.lastBaseUpdate=current;props=queue.shared.interleaved;if(null!==props){queue=props;do lastBaseUpdate|=queue.lane,queue=queue.next;
while(queue!==props)}else null===firstBaseUpdate&&(queue.shared.lanes=0);workInProgressRootSkippedLanes|=lastBaseUpdate;workInProgress.lanes=lastBaseUpdate;workInProgress.memoizedState=newState}currentlyProcessingQueue=null}function commitUpdateQueue(finishedWork,finishedQueue,instance){finishedWork=finishedQueue.effects;finishedQueue.effects=null;if(null!==finishedWork)for(finishedQueue=0;finishedQueue<finishedWork.length;finishedQueue++){var effect=finishedWork[finishedQueue],callback=effect.callback;
if(null!==callback){effect.callback=null;if("function"!==typeof callback)throw Error("Invalid argument passed as callback. Expected a function. Instead received: "+callback);callback.call(instance)}}}function applyDerivedStateFromProps(workInProgress,ctor,getDerivedStateFromProps,nextProps){var prevState=workInProgress.memoizedState,partialState=getDerivedStateFromProps(nextProps,prevState);if(workInProgress.mode&8){setIsStrictModeForDevtools(!0);try{partialState=getDerivedStateFromProps(nextProps,
prevState)}finally{setIsStrictModeForDevtools(!1)}}warnOnUndefinedDerivedState(ctor,partialState);ctor=null===partialState||void 0===partialState?prevState:assign({},prevState,partialState);workInProgress.memoizedState=ctor;0===workInProgress.lanes&&(workInProgress.updateQueue.baseState=ctor)}function checkShouldComponentUpdate(workInProgress,ctor,oldProps,newProps,oldState,newState,nextContext){var instance=workInProgress.stateNode;if("function"===typeof instance.shouldComponentUpdate){oldProps=
instance.shouldComponentUpdate(newProps,newState,nextContext);if(workInProgress.mode&8){setIsStrictModeForDevtools(!0);try{oldProps=instance.shouldComponentUpdate(newProps,newState,nextContext)}finally{setIsStrictModeForDevtools(!1)}}void 0===oldProps&&error$jscomp$0("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.",getComponentNameFromType(ctor)||"Component");return oldProps}return ctor.prototype&&ctor.prototype.isPureReactComponent?!shallowEqual(oldProps,
newProps)||!shallowEqual(oldState,newState):!0}function constructClassInstance(workInProgress,ctor,props){var isLegacyContextConsumer=!1,unmaskedContext=emptyContextObject;var context=ctor.contextType;if("contextType"in ctor&&null!==context&&(void 0===context||context.$$typeof!==REACT_CONTEXT_TYPE||void 0!==context._context)&&!didWarnAboutInvalidateContextType.has(ctor)){didWarnAboutInvalidateContextType.add(ctor);var addendum=void 0===context?" However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file.":
"object"!==typeof context?" However, it is set to a "+typeof context+".":context.$$typeof===REACT_PROVIDER_TYPE?" Did you accidentally pass the Context.Provider instead?":void 0!==context._context?" Did you accidentally pass the Context.Consumer instead?":" However, it is set to an object with keys {"+Object.keys(context).join(", ")+"}.";error$jscomp$0("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s",getComponentNameFromType(ctor)||
"Component",addendum)}"object"===typeof context&&null!==context?context=readContext(context):(unmaskedContext=isContextProvider(ctor)?previousContext:contextStackCursor.current,isLegacyContextConsumer=ctor.contextTypes,context=(isLegacyContextConsumer=null!==isLegacyContextConsumer&&void 0!==isLegacyContextConsumer)?getMaskedContext(workInProgress,unmaskedContext):emptyContextObject);addendum=new ctor(props,context);if(workInProgress.mode&8){setIsStrictModeForDevtools(!0);try{addendum=new ctor(props,
context)}finally{setIsStrictModeForDevtools(!1)}}props=workInProgress.memoizedState=null!==addendum.state&&void 0!==addendum.state?addendum.state:null;var instance=addendum;instance.updater=classComponentUpdater;workInProgress.stateNode=instance;instance._reactInternals=workInProgress;instance._reactInternalInstance=fakeInternalInstance;"function"===typeof ctor.getDerivedStateFromProps&&null===props&&(props=getComponentNameFromType(ctor)||"Component",didWarnAboutUninitializedState.has(props)||(didWarnAboutUninitializedState.add(props),
error$jscomp$0("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.",props,null===addendum.state?"null":"undefined",props)));if("function"===typeof ctor.getDerivedStateFromProps||"function"===typeof addendum.getSnapshotBeforeUpdate){var foundWillUpdateName=instance=props=null;"function"===
typeof addendum.componentWillMount&&!0!==addendum.componentWillMount.__suppressDeprecationWarning?props="componentWillMount":"function"===typeof addendum.UNSAFE_componentWillMount&&(props="UNSAFE_componentWillMount");"function"===typeof addendum.componentWillReceiveProps&&!0!==addendum.componentWillReceiveProps.__suppressDeprecationWarning?instance="componentWillReceiveProps":"function"===typeof addendum.UNSAFE_componentWillReceiveProps&&(instance="UNSAFE_componentWillReceiveProps");"function"===
typeof addendum.componentWillUpdate&&!0!==addendum.componentWillUpdate.__suppressDeprecationWarning?foundWillUpdateName="componentWillUpdate":"function"===typeof addendum.UNSAFE_componentWillUpdate&&(foundWillUpdateName="UNSAFE_componentWillUpdate");if(null!==props||null!==instance||null!==foundWillUpdateName){var _componentName=getComponentNameFromType(ctor)||"Component";ctor="function"===typeof ctor.getDerivedStateFromProps?"getDerivedStateFromProps()":"getSnapshotBeforeUpdate()";didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)||
(didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName),error$jscomp$0("Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n%s uses %s but also contains the following legacy lifecycles:%s%s%s\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://reactjs.org/link/unsafe-component-lifecycles",_componentName,ctor,null!==props?"\n  "+props:"",null!==instance?"\n  "+instance:"",null!==foundWillUpdateName?"\n  "+foundWillUpdateName:
""))}}isLegacyContextConsumer&&(workInProgress=workInProgress.stateNode,workInProgress.__reactInternalMemoizedUnmaskedChildContext=unmaskedContext,workInProgress.__reactInternalMemoizedMaskedChildContext=context);return addendum}function callComponentWillReceiveProps(workInProgress,instance,newProps,nextContext){var oldState=instance.state;"function"===typeof instance.componentWillReceiveProps&&instance.componentWillReceiveProps(newProps,nextContext);"function"===typeof instance.UNSAFE_componentWillReceiveProps&&
instance.UNSAFE_componentWillReceiveProps(newProps,nextContext);instance.state!==oldState&&(workInProgress=getComponentNameFromFiber(workInProgress)||"Component",didWarnAboutStateAssignmentForComponent.has(workInProgress)||(didWarnAboutStateAssignmentForComponent.add(workInProgress),error$jscomp$0("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",workInProgress)),classComponentUpdater.enqueueReplaceState(instance,
instance.state,null))}function mountClassInstance(workInProgress,ctor,newProps,renderLanes){var instance=workInProgress.stateNode,name=getComponentNameFromType(ctor)||"Component";instance.render||(ctor.prototype&&"function"===typeof ctor.prototype.render?error$jscomp$0("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?",name):error$jscomp$0("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.",
name));!instance.getInitialState||instance.getInitialState.isReactClassApproved||instance.state||error$jscomp$0("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?",name);instance.getDefaultProps&&!instance.getDefaultProps.isReactClassApproved&&error$jscomp$0("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.",
name);instance.propTypes&&error$jscomp$0("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.",name);instance.contextType&&error$jscomp$0("contextType was defined as an instance property on %s. Use a static property to define contextType instead.",name);instance.contextTypes&&error$jscomp$0("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.",name);ctor.contextType&&ctor.contextTypes&&!didWarnAboutContextTypeAndContextTypes.has(ctor)&&
(didWarnAboutContextTypeAndContextTypes.add(ctor),error$jscomp$0("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.",name));"function"===typeof instance.componentShouldUpdate&&error$jscomp$0("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",name);ctor.prototype&&ctor.prototype.isPureReactComponent&&"undefined"!==
typeof instance.shouldComponentUpdate&&error$jscomp$0("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.",getComponentNameFromType(ctor)||"A pure component");"function"===typeof instance.componentDidUnmount&&error$jscomp$0("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?",name);"function"===
typeof instance.componentDidReceiveProps&&error$jscomp$0("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().",name);"function"===typeof instance.componentWillRecieveProps&&error$jscomp$0("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",
name);"function"===typeof instance.UNSAFE_componentWillRecieveProps&&error$jscomp$0("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?",name);var hasMutatedProps=instance.props!==newProps;void 0!==instance.props&&hasMutatedProps&&error$jscomp$0("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.",name,name);instance.defaultProps&&error$jscomp$0("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.",
name,name);"function"!==typeof instance.getSnapshotBeforeUpdate||"function"===typeof instance.componentDidUpdate||didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)||(didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor),error$jscomp$0("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.",getComponentNameFromType(ctor)));"function"===typeof instance.getDerivedStateFromProps&&error$jscomp$0("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.",
name);"function"===typeof instance.getDerivedStateFromError&&error$jscomp$0("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.",name);"function"===typeof ctor.getSnapshotBeforeUpdate&&error$jscomp$0("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.",name);(hasMutatedProps=instance.state)&&("object"!==typeof hasMutatedProps||isArrayImpl(hasMutatedProps))&&
error$jscomp$0("%s.state: must be set to an object or null",name);"function"===typeof instance.getChildContext&&"object"!==typeof ctor.childContextTypes&&error$jscomp$0("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().",name);instance=workInProgress.stateNode;instance.props=newProps;instance.state=workInProgress.memoizedState;instance.refs=emptyRefsObject;initializeUpdateQueue(workInProgress);name=ctor.contextType;"object"===typeof name&&null!==name?instance.context=
readContext(name):(name=isContextProvider(ctor)?previousContext:contextStackCursor.current,instance.context=getMaskedContext(workInProgress,name));instance.state===newProps&&(name=getComponentNameFromType(ctor)||"Component",didWarnAboutDirectlyAssigningPropsToState.has(name)||(didWarnAboutDirectlyAssigningPropsToState.add(name),error$jscomp$0("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.",
name)));workInProgress.mode&8&&ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,instance);ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress,instance);instance.state=workInProgress.memoizedState;name=ctor.getDerivedStateFromProps;"function"===typeof name&&(applyDerivedStateFromProps(workInProgress,ctor,name,newProps),instance.state=workInProgress.memoizedState);"function"===typeof ctor.getDerivedStateFromProps||"function"===typeof instance.getSnapshotBeforeUpdate||
"function"!==typeof instance.UNSAFE_componentWillMount&&"function"!==typeof instance.componentWillMount||(ctor=instance.state,"function"===typeof instance.componentWillMount&&instance.componentWillMount(),"function"===typeof instance.UNSAFE_componentWillMount&&instance.UNSAFE_componentWillMount(),ctor!==instance.state&&(error$jscomp$0("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.",getComponentNameFromFiber(workInProgress)||
"Component"),classComponentUpdater.enqueueReplaceState(instance,instance.state,null)),processUpdateQueue(workInProgress,newProps,instance,renderLanes),instance.state=workInProgress.memoizedState);"function"===typeof instance.componentDidMount&&(newProps=4194308,0!==(workInProgress.mode&16)&&(newProps|=16777216),workInProgress.flags|=newProps)}function pushTreeFork(workInProgress,totalChildren){warnIfNotHydrating();forkStack[forkStackIndex++]=treeForkCount;forkStack[forkStackIndex++]=treeForkProvider;
treeForkProvider=workInProgress;treeForkCount=totalChildren}function pushTreeId(workInProgress,totalChildren,index){warnIfNotHydrating();idStack[idStackIndex++]=treeContextId;idStack[idStackIndex++]=treeContextOverflow;idStack[idStackIndex++]=treeContextProvider;treeContextProvider=workInProgress;var baseIdWithLeadingBit=treeContextId;workInProgress=treeContextOverflow;var baseLength=32-clz32(baseIdWithLeadingBit)-1;baseIdWithLeadingBit&=~(1<<baseLength);index+=1;var length=32-clz32(totalChildren)+
baseLength;if(30<length){var numberOfOverflowBits=baseLength-baseLength%5;length=(baseIdWithLeadingBit&(1<<numberOfOverflowBits)-1).toString(32);baseIdWithLeadingBit>>=numberOfOverflowBits;baseLength-=numberOfOverflowBits;treeContextId=1<<32-clz32(totalChildren)+baseLength|index<<baseLength|baseIdWithLeadingBit;treeContextOverflow=length+workInProgress}else treeContextId=1<<length|index<<baseLength|baseIdWithLeadingBit,treeContextOverflow=workInProgress}function pushMaterializedTreeId(workInProgress){warnIfNotHydrating();
null!==workInProgress.return&&(pushTreeFork(workInProgress,1),pushTreeId(workInProgress,1,0))}function popTreeContext(workInProgress){for(;workInProgress===treeForkProvider;)treeForkProvider=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null,treeForkCount=forkStack[--forkStackIndex],forkStack[forkStackIndex]=null;for(;workInProgress===treeContextProvider;)treeContextProvider=idStack[--idStackIndex],idStack[idStackIndex]=null,treeContextOverflow=idStack[--idStackIndex],idStack[idStackIndex]=
null,treeContextId=idStack[--idStackIndex],idStack[idStackIndex]=null}function warnIfNotHydrating(){isHydrating||error$jscomp$0("Expected to be hydrating. This is a bug in React. Please file an issue.")}function warnUnhydratedInstance(returnFiber,instance){switch(returnFiber.tag){case 3:didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo,instance);break;case 5:didNotHydrateInstance(returnFiber.type,returnFiber.memoizedProps,returnFiber.stateNode,instance);break;case 13:returnFiber=
returnFiber.memoizedState,null!==returnFiber.dehydrated&&didNotHydrateInstanceWithinSuspenseInstance(returnFiber.dehydrated,instance)}}function deleteHydratableInstance(returnFiber,instance){warnUnhydratedInstance(returnFiber,instance);var fiber=createFiber(5,null,null,0);fiber.elementType="DELETED";fiber.stateNode=instance;fiber.return=returnFiber;instance=returnFiber.deletions;null===instance?(returnFiber.deletions=[fiber],returnFiber.flags|=16):instance.push(fiber)}function warnNonhydratedInstance(returnFiber,
fiber){if(!didSuspend$jscomp$0)switch(returnFiber.tag){case 3:var parentContainer=returnFiber.stateNode.containerInfo;switch(fiber.tag){case 5:didNotFindHydratableInstanceWithinContainer(parentContainer,fiber.type,fiber.pendingProps);break;case 6:didNotFindHydratableTextInstanceWithinContainer(parentContainer,fiber.pendingProps);break;case 13:didNotFindHydratableSuspenseInstanceWithinContainer(parentContainer)}break;case 5:parentContainer=returnFiber.type;var parentProps=returnFiber.memoizedProps;
returnFiber=returnFiber.stateNode;switch(fiber.tag){case 5:didNotFindHydratableInstance(parentContainer,parentProps,returnFiber,fiber.type,fiber.pendingProps);break;case 6:didNotFindHydratableTextInstance(parentContainer,parentProps,returnFiber,fiber.pendingProps);break;case 13:didNotFindHydratableSuspenseInstance(parentContainer,parentProps,returnFiber)}break;case 13:if(parentContainer=returnFiber.memoizedState.dehydrated,null!==parentContainer)switch(fiber.tag){case 5:didNotFindHydratableInstanceWithinSuspenseInstance(parentContainer,
fiber.type,fiber.pendingProps);break;case 6:didNotFindHydratableTextInstanceWithinSuspenseInstance(parentContainer,fiber.pendingProps);break;case 13:didNotFindHydratableSuspenseInstanceWithinSuspenseInstance(parentContainer)}}}function tryHydrate(fiber,nextInstance){switch(fiber.tag){case 5:return nextInstance=canHydrateInstance(nextInstance,fiber.type,fiber.pendingProps),null!==nextInstance?(fiber.stateNode=nextInstance,hydrationParentFiber=fiber,nextHydratableInstance=getFirstHydratableChild(nextInstance),
!0):!1;case 6:return nextInstance=canHydrateTextInstance(nextInstance,fiber.pendingProps),null!==nextInstance?(fiber.stateNode=nextInstance,hydrationParentFiber=fiber,nextHydratableInstance=null,!0):!1;case 13:nextInstance=canHydrateSuspenseInstance(nextInstance);if(null!==nextInstance){warnIfNotHydrating();var JSCompiler_inline_result=null!==treeContextProvider?{id:treeContextId,overflow:treeContextOverflow}:null;fiber.memoizedState={dehydrated:nextInstance,treeContext:JSCompiler_inline_result,retryLane:1073741824};
JSCompiler_inline_result=createFiber(18,null,null,0);JSCompiler_inline_result.stateNode=nextInstance;JSCompiler_inline_result.return=fiber;fiber.child=JSCompiler_inline_result;hydrationParentFiber=fiber;nextHydratableInstance=null;return!0}return!1;default:return!1}}function shouldClientRenderOnMismatch(fiber){return 0!==(fiber.mode&1)&&0===(fiber.flags&128)}function throwOnHydrationMismatch(fiber){throw Error("Hydration failed because the initial UI does not match what was rendered on the server.");
}function tryToClaimNextHydratableInstance(fiber){if(isHydrating){var nextInstance=nextHydratableInstance;if(nextInstance){var firstAttemptedInstance=nextInstance;if(!tryHydrate(fiber,nextInstance)){shouldClientRenderOnMismatch(fiber)&&(warnNonhydratedInstance(hydrationParentFiber,fiber),throwOnHydrationMismatch());nextInstance=getNextHydratableSibling(firstAttemptedInstance);var prevHydrationParentFiber=hydrationParentFiber;nextInstance&&tryHydrate(fiber,nextInstance)?deleteHydratableInstance(prevHydrationParentFiber,
firstAttemptedInstance):(nextInstance=hydrationParentFiber,fiber.flags=fiber.flags&-4097|2,warnNonhydratedInstance(nextInstance,fiber),isHydrating=!1,hydrationParentFiber=fiber)}}else shouldClientRenderOnMismatch(fiber)&&(warnNonhydratedInstance(hydrationParentFiber,fiber),throwOnHydrationMismatch()),nextInstance=hydrationParentFiber,fiber.flags=fiber.flags&-4097|2,warnNonhydratedInstance(nextInstance,fiber),isHydrating=!1,hydrationParentFiber=fiber}}function popToNextHostParent(fiber){for(fiber=
fiber.return;null!==fiber&&5!==fiber.tag&&3!==fiber.tag&&13!==fiber.tag;)fiber=fiber.return;hydrationParentFiber=fiber}function popHydrationState(fiber){if(!supportsHydration||fiber!==hydrationParentFiber)return!1;if(!isHydrating)return popToNextHostParent(fiber),isHydrating=!0,!1;if(3!==fiber.tag&&(5!==fiber.tag||shouldDeleteUnhydratedTailInstances(fiber.type)&&!shouldSetTextContent(fiber.type,fiber.memoizedProps))){var nextInstance=nextHydratableInstance;if(nextInstance)if(shouldClientRenderOnMismatch(fiber))warnIfUnhydratedTailNodes(fiber),
throwOnHydrationMismatch();else for(;nextInstance;)deleteHydratableInstance(fiber,nextInstance),nextInstance=getNextHydratableSibling(nextInstance)}popToNextHostParent(fiber);if(13===fiber.tag){if(!supportsHydration)throw Error("Expected skipPastDehydratedSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");fiber=fiber.memoizedState;fiber=null!==fiber?fiber.dehydrated:null;if(!fiber)throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
nextHydratableInstance=getNextHydratableInstanceAfterSuspenseInstance(fiber)}else nextHydratableInstance=hydrationParentFiber?getNextHydratableSibling(fiber.stateNode):null;return!0}function warnIfUnhydratedTailNodes(fiber){for(var nextInstance=nextHydratableInstance;nextInstance;)warnUnhydratedInstance(fiber,nextInstance),nextInstance=getNextHydratableSibling(nextInstance)}function resetHydrationState(){supportsHydration&&(nextHydratableInstance=hydrationParentFiber=null,didSuspend$jscomp$0=isHydrating=
!1)}function queueHydrationError(error){null===hydrationErrors?hydrationErrors=[error]:hydrationErrors.push(error)}function coerceRef(returnFiber,current,element){var mixedRef=element.ref;if(null!==mixedRef&&"function"!==typeof mixedRef&&"object"!==typeof mixedRef){!(returnFiber.mode&8)||element._owner&&element._self&&element._owner.stateNode!==element._self||(returnFiber=getComponentNameFromFiber(returnFiber)||"Component",didWarnAboutStringRefs[returnFiber]||(error$jscomp$0('A string ref, "%s", has been found within a strict mode tree. String refs are a source of potential bugs and should be avoided. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref',
mixedRef),didWarnAboutStringRefs[returnFiber]=!0));if(element._owner){element=element._owner;if(element){if(1!==element.tag)throw Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");var inst=element.stateNode}if(!inst)throw Error("Missing owner for string ref "+mixedRef+". This error is likely caused by a bug in React. Please file an issue.");var resolvedInst=inst,stringRef=
""+mixedRef;if(null!==current&&null!==current.ref&&"function"===typeof current.ref&&current.ref._stringRef===stringRef)return current.ref;current=function(value){var refs=resolvedInst.refs;refs===emptyRefsObject&&(refs=resolvedInst.refs={});null===value?delete refs[stringRef]:refs[stringRef]=value};current._stringRef=stringRef;return current}if("string"!==typeof mixedRef)throw Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");if(!element._owner)throw Error("Element ref was specified as a string ("+
mixedRef+") but no owner was set. This could happen for one of the following reasons:\n1. You may be adding a ref to a function component\n2. You may be adding a ref to a component that was not created inside a component's render method\n3. You have multiple copies of React loaded\nSee https://reactjs.org/link/refs-must-have-owner for more information.");}return mixedRef}function throwOnInvalidObjectType(returnFiber,newChild){returnFiber=Object.prototype.toString.call(newChild);throw Error("Objects are not valid as a React child (found: "+
("[object Object]"===returnFiber?"object with keys {"+Object.keys(newChild).join(", ")+"}":returnFiber)+"). If you meant to render a collection of children, use an array instead.");}function warnOnFunctionType(returnFiber){returnFiber=getComponentNameFromFiber(returnFiber)||"Component";ownerHasFunctionTypeWarning[returnFiber]||(ownerHasFunctionTypeWarning[returnFiber]=!0,error$jscomp$0("Functions are not valid as a React child. This may happen if you return a Component instead of \x3cComponent /\x3e from render. Or maybe you meant to call this function rather than return it."))}
function resolveLazy(lazyType){var init=lazyType._init;return init(lazyType._payload)}function ChildReconciler(shouldTrackSideEffects){function deleteChild(returnFiber,childToDelete){if(shouldTrackSideEffects){var deletions=returnFiber.deletions;null===deletions?(returnFiber.deletions=[childToDelete],returnFiber.flags|=16):deletions.push(childToDelete)}}function deleteRemainingChildren(returnFiber,currentFirstChild){if(!shouldTrackSideEffects)return null;for(;null!==currentFirstChild;)deleteChild(returnFiber,
currentFirstChild),currentFirstChild=currentFirstChild.sibling;return null}function mapRemainingChildren(returnFiber,currentFirstChild){for(returnFiber=new Map;null!==currentFirstChild;)null!==currentFirstChild.key?returnFiber.set(currentFirstChild.key,currentFirstChild):returnFiber.set(currentFirstChild.index,currentFirstChild),currentFirstChild=currentFirstChild.sibling;return returnFiber}function useFiber(fiber,pendingProps){fiber=createWorkInProgress(fiber,pendingProps);fiber.index=0;fiber.sibling=
null;return fiber}function placeChild(newFiber,lastPlacedIndex,newIndex){newFiber.index=newIndex;if(!shouldTrackSideEffects)return newFiber.flags|=1048576,lastPlacedIndex;newIndex=newFiber.alternate;if(null!==newIndex)return newIndex=newIndex.index,newIndex<lastPlacedIndex?(newFiber.flags|=2,lastPlacedIndex):newIndex;newFiber.flags|=2;return lastPlacedIndex}function placeSingleChild(newFiber){shouldTrackSideEffects&&null===newFiber.alternate&&(newFiber.flags|=2);return newFiber}function updateTextNode(returnFiber,
current,textContent,lanes){if(null===current||6!==current.tag)return current=createFiberFromText(textContent,returnFiber.mode,lanes),current.return=returnFiber,current;current=useFiber(current,textContent);current.return=returnFiber;return current}function updateElement(returnFiber,current,element,lanes){var elementType=element.type;if(elementType===REACT_FRAGMENT_TYPE)return updateFragment(returnFiber,current,element.props.children,lanes,element.key);if(null!==current&&(current.elementType===elementType||
isCompatibleFamilyForHotReloading(current,element)||"object"===typeof elementType&&null!==elementType&&elementType.$$typeof===REACT_LAZY_TYPE&&resolveLazy(elementType)===current.type))return lanes=useFiber(current,element.props),lanes.ref=coerceRef(returnFiber,current,element),lanes.return=returnFiber,lanes._debugSource=element._source,lanes._debugOwner=element._owner,lanes;lanes=createFiberFromElement(element,returnFiber.mode,lanes);lanes.ref=coerceRef(returnFiber,current,element);lanes.return=returnFiber;
return lanes}function updatePortal(returnFiber,current,portal,lanes){if(null===current||4!==current.tag||current.stateNode.containerInfo!==portal.containerInfo||current.stateNode.implementation!==portal.implementation)return current=createFiberFromPortal(portal,returnFiber.mode,lanes),current.return=returnFiber,current;current=useFiber(current,portal.children||[]);current.return=returnFiber;return current}function updateFragment(returnFiber,current,fragment,lanes,key){if(null===current||7!==current.tag)return current=
createFiberFromFragment(fragment,returnFiber.mode,lanes,key),current.return=returnFiber,current;current=useFiber(current,fragment);current.return=returnFiber;return current}function createChild(returnFiber,newChild,lanes){if("string"===typeof newChild&&""!==newChild||"number"===typeof newChild)return newChild=createFiberFromText(""+newChild,returnFiber.mode,lanes),newChild.return=returnFiber,newChild;if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return lanes=
createFiberFromElement(newChild,returnFiber.mode,lanes),lanes.ref=coerceRef(returnFiber,null,newChild),lanes.return=returnFiber,lanes;case REACT_PORTAL_TYPE:return newChild=createFiberFromPortal(newChild,returnFiber.mode,lanes),newChild.return=returnFiber,newChild;case REACT_LAZY_TYPE:var init=newChild._init;return createChild(returnFiber,init(newChild._payload),lanes)}if(isArrayImpl(newChild)||getIteratorFn(newChild))return newChild=createFiberFromFragment(newChild,returnFiber.mode,lanes,null),newChild.return=
returnFiber,newChild;throwOnInvalidObjectType(returnFiber,newChild)}"function"===typeof newChild&&warnOnFunctionType(returnFiber);return null}function updateSlot(returnFiber,oldFiber,newChild,lanes){var key=null!==oldFiber?oldFiber.key:null;if("string"===typeof newChild&&""!==newChild||"number"===typeof newChild)return null!==key?null:updateTextNode(returnFiber,oldFiber,""+newChild,lanes);if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return newChild.key===
key?updateElement(returnFiber,oldFiber,newChild,lanes):null;case REACT_PORTAL_TYPE:return newChild.key===key?updatePortal(returnFiber,oldFiber,newChild,lanes):null;case REACT_LAZY_TYPE:return key=newChild._init,updateSlot(returnFiber,oldFiber,key(newChild._payload),lanes)}if(isArrayImpl(newChild)||getIteratorFn(newChild))return null!==key?null:updateFragment(returnFiber,oldFiber,newChild,lanes,null);throwOnInvalidObjectType(returnFiber,newChild)}"function"===typeof newChild&&warnOnFunctionType(returnFiber);
return null}function updateFromMap(existingChildren,returnFiber,newIdx,newChild,lanes){if("string"===typeof newChild&&""!==newChild||"number"===typeof newChild)return existingChildren=existingChildren.get(newIdx)||null,updateTextNode(returnFiber,existingChildren,""+newChild,lanes);if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:return existingChildren=existingChildren.get(null===newChild.key?newIdx:newChild.key)||null,updateElement(returnFiber,existingChildren,
newChild,lanes);case REACT_PORTAL_TYPE:return existingChildren=existingChildren.get(null===newChild.key?newIdx:newChild.key)||null,updatePortal(returnFiber,existingChildren,newChild,lanes);case REACT_LAZY_TYPE:var init=newChild._init;return updateFromMap(existingChildren,returnFiber,newIdx,init(newChild._payload),lanes)}if(isArrayImpl(newChild)||getIteratorFn(newChild))return existingChildren=existingChildren.get(newIdx)||null,updateFragment(returnFiber,existingChildren,newChild,lanes,null);throwOnInvalidObjectType(returnFiber,
newChild)}"function"===typeof newChild&&warnOnFunctionType(returnFiber);return null}function warnOnInvalidKey(child,knownKeys,returnFiber){if("object"!==typeof child||null===child)return knownKeys;switch(child.$$typeof){case REACT_ELEMENT_TYPE:case REACT_PORTAL_TYPE:warnForMissingKey(child,returnFiber);child=child.key;if("string"!==typeof child)break;if(null===knownKeys){knownKeys=new Set;knownKeys.add(child);break}if(!knownKeys.has(child)){knownKeys.add(child);break}error$jscomp$0("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted  the behavior is unsupported and could change in a future version.",
child);break;case REACT_LAZY_TYPE:var init=child._init;warnOnInvalidKey(init(child._payload),knownKeys,returnFiber)}return knownKeys}function reconcileChildrenArray(returnFiber,currentFirstChild,newChildren,lanes){for(var knownKeys=null,i=0;i<newChildren.length;i++)knownKeys=warnOnInvalidKey(newChildren[i],knownKeys,returnFiber);i=knownKeys=null;for(var oldFiber=currentFirstChild,newIdx=currentFirstChild=0,nextOldFiber=null;null!==oldFiber&&newIdx<newChildren.length;newIdx++){oldFiber.index>newIdx?
(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,newChildren[newIdx],lanes);if(null===newFiber){null===oldFiber&&(oldFiber=nextOldFiber);break}shouldTrackSideEffects&&oldFiber&&null===newFiber.alternate&&deleteChild(returnFiber,oldFiber);currentFirstChild=placeChild(newFiber,currentFirstChild,newIdx);null===i?knownKeys=newFiber:i.sibling=newFiber;i=newFiber;oldFiber=nextOldFiber}if(newIdx===newChildren.length)return deleteRemainingChildren(returnFiber,
oldFiber),isHydrating&&pushTreeFork(returnFiber,newIdx),knownKeys;if(null===oldFiber){for(;newIdx<newChildren.length;newIdx++)oldFiber=createChild(returnFiber,newChildren[newIdx],lanes),null!==oldFiber&&(currentFirstChild=placeChild(oldFiber,currentFirstChild,newIdx),null===i?knownKeys=oldFiber:i.sibling=oldFiber,i=oldFiber);isHydrating&&pushTreeFork(returnFiber,newIdx);return knownKeys}for(oldFiber=mapRemainingChildren(returnFiber,oldFiber);newIdx<newChildren.length;newIdx++)nextOldFiber=updateFromMap(oldFiber,
returnFiber,newIdx,newChildren[newIdx],lanes),null!==nextOldFiber&&(shouldTrackSideEffects&&null!==nextOldFiber.alternate&&oldFiber.delete(null===nextOldFiber.key?newIdx:nextOldFiber.key),currentFirstChild=placeChild(nextOldFiber,currentFirstChild,newIdx),null===i?knownKeys=nextOldFiber:i.sibling=nextOldFiber,i=nextOldFiber);shouldTrackSideEffects&&oldFiber.forEach(function(child){return deleteChild(returnFiber,child)});isHydrating&&pushTreeFork(returnFiber,newIdx);return knownKeys}function reconcileChildrenIterator(returnFiber,
currentFirstChild,newChildrenIterable,lanes){var iteratorFn=getIteratorFn(newChildrenIterable);if("function"!==typeof iteratorFn)throw Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");"function"===typeof Symbol&&"Generator"===newChildrenIterable[Symbol.toStringTag]&&(didWarnAboutGenerators||error$jscomp$0("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."),
didWarnAboutGenerators=!0);newChildrenIterable.entries===iteratorFn&&(didWarnAboutMaps||error$jscomp$0("Using Maps as children is not supported. Use an array of keyed ReactElements instead."),didWarnAboutMaps=!0);var _newChildren=iteratorFn.call(newChildrenIterable);if(_newChildren)for(var knownKeys=null,_step=_newChildren.next();!_step.done;_step=_newChildren.next())knownKeys=warnOnInvalidKey(_step.value,knownKeys,returnFiber);newChildrenIterable=iteratorFn.call(newChildrenIterable);if(null==newChildrenIterable)throw Error("An iterable object provided no iterator.");
_newChildren=iteratorFn=null;var oldFiber=currentFirstChild;knownKeys=currentFirstChild=0;var nextOldFiber=null;for(_step=newChildrenIterable.next();null!==oldFiber&&!_step.done;knownKeys++,_step=newChildrenIterable.next()){oldFiber.index>knownKeys?(nextOldFiber=oldFiber,oldFiber=null):nextOldFiber=oldFiber.sibling;var newFiber=updateSlot(returnFiber,oldFiber,_step.value,lanes);if(null===newFiber){null===oldFiber&&(oldFiber=nextOldFiber);break}shouldTrackSideEffects&&oldFiber&&null===newFiber.alternate&&
deleteChild(returnFiber,oldFiber);currentFirstChild=placeChild(newFiber,currentFirstChild,knownKeys);null===_newChildren?iteratorFn=newFiber:_newChildren.sibling=newFiber;_newChildren=newFiber;oldFiber=nextOldFiber}if(_step.done)return deleteRemainingChildren(returnFiber,oldFiber),isHydrating&&pushTreeFork(returnFiber,knownKeys),iteratorFn;if(null===oldFiber){for(;!_step.done;knownKeys++,_step=newChildrenIterable.next())_step=createChild(returnFiber,_step.value,lanes),null!==_step&&(currentFirstChild=
placeChild(_step,currentFirstChild,knownKeys),null===_newChildren?iteratorFn=_step:_newChildren.sibling=_step,_newChildren=_step);isHydrating&&pushTreeFork(returnFiber,knownKeys);return iteratorFn}for(oldFiber=mapRemainingChildren(returnFiber,oldFiber);!_step.done;knownKeys++,_step=newChildrenIterable.next())_step=updateFromMap(oldFiber,returnFiber,knownKeys,_step.value,lanes),null!==_step&&(shouldTrackSideEffects&&null!==_step.alternate&&oldFiber.delete(null===_step.key?knownKeys:_step.key),currentFirstChild=
placeChild(_step,currentFirstChild,knownKeys),null===_newChildren?iteratorFn=_step:_newChildren.sibling=_step,_newChildren=_step);shouldTrackSideEffects&&oldFiber.forEach(function(child){return deleteChild(returnFiber,child)});isHydrating&&pushTreeFork(returnFiber,knownKeys);return iteratorFn}function reconcileChildFibers(returnFiber,currentFirstChild,newChild,lanes){"object"===typeof newChild&&null!==newChild&&newChild.type===REACT_FRAGMENT_TYPE&&null===newChild.key&&(newChild=newChild.props.children);
if("object"===typeof newChild&&null!==newChild){switch(newChild.$$typeof){case REACT_ELEMENT_TYPE:a:{for(var key=newChild.key,child=currentFirstChild;null!==child;){if(child.key===key){key=newChild.type;if(key===REACT_FRAGMENT_TYPE){if(7===child.tag){deleteRemainingChildren(returnFiber,child.sibling);currentFirstChild=useFiber(child,newChild.props.children);currentFirstChild.return=returnFiber;currentFirstChild._debugSource=newChild._source;currentFirstChild._debugOwner=newChild._owner;returnFiber=
currentFirstChild;break a}}else if(child.elementType===key||isCompatibleFamilyForHotReloading(child,newChild)||"object"===typeof key&&null!==key&&key.$$typeof===REACT_LAZY_TYPE&&resolveLazy(key)===child.type){deleteRemainingChildren(returnFiber,child.sibling);currentFirstChild=useFiber(child,newChild.props);currentFirstChild.ref=coerceRef(returnFiber,child,newChild);currentFirstChild.return=returnFiber;currentFirstChild._debugSource=newChild._source;currentFirstChild._debugOwner=newChild._owner;returnFiber=
currentFirstChild;break a}deleteRemainingChildren(returnFiber,child);break}else deleteChild(returnFiber,child);child=child.sibling}newChild.type===REACT_FRAGMENT_TYPE?(currentFirstChild=createFiberFromFragment(newChild.props.children,returnFiber.mode,lanes,newChild.key),currentFirstChild.return=returnFiber,returnFiber=currentFirstChild):(lanes=createFiberFromElement(newChild,returnFiber.mode,lanes),lanes.ref=coerceRef(returnFiber,currentFirstChild,newChild),lanes.return=returnFiber,returnFiber=lanes)}return placeSingleChild(returnFiber);
case REACT_PORTAL_TYPE:a:{for(child=newChild.key;null!==currentFirstChild;){if(currentFirstChild.key===child)if(4===currentFirstChild.tag&&currentFirstChild.stateNode.containerInfo===newChild.containerInfo&&currentFirstChild.stateNode.implementation===newChild.implementation){deleteRemainingChildren(returnFiber,currentFirstChild.sibling);currentFirstChild=useFiber(currentFirstChild,newChild.children||[]);currentFirstChild.return=returnFiber;returnFiber=currentFirstChild;break a}else{deleteRemainingChildren(returnFiber,
currentFirstChild);break}else deleteChild(returnFiber,currentFirstChild);currentFirstChild=currentFirstChild.sibling}currentFirstChild=createFiberFromPortal(newChild,returnFiber.mode,lanes);currentFirstChild.return=returnFiber;returnFiber=currentFirstChild}return placeSingleChild(returnFiber);case REACT_LAZY_TYPE:return child=newChild._init,reconcileChildFibers(returnFiber,currentFirstChild,child(newChild._payload),lanes)}if(isArrayImpl(newChild))return reconcileChildrenArray(returnFiber,currentFirstChild,
newChild,lanes);if(getIteratorFn(newChild))return reconcileChildrenIterator(returnFiber,currentFirstChild,newChild,lanes);throwOnInvalidObjectType(returnFiber,newChild)}if("string"===typeof newChild&&""!==newChild||"number"===typeof newChild)return newChild=""+newChild,null!==currentFirstChild&&6===currentFirstChild.tag?(deleteRemainingChildren(returnFiber,currentFirstChild.sibling),currentFirstChild=useFiber(currentFirstChild,newChild),currentFirstChild.return=returnFiber,returnFiber=currentFirstChild):
(deleteRemainingChildren(returnFiber,currentFirstChild),currentFirstChild=createFiberFromText(newChild,returnFiber.mode,lanes),currentFirstChild.return=returnFiber,returnFiber=currentFirstChild),placeSingleChild(returnFiber);"function"===typeof newChild&&warnOnFunctionType(returnFiber);return deleteRemainingChildren(returnFiber,currentFirstChild)}return reconcileChildFibers}function requiredContext(c){if(c===NO_CONTEXT)throw Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
return c}function pushHostContainer(fiber,nextRootInstance){push(rootInstanceStackCursor,nextRootInstance,fiber);push(contextFiberStackCursor,fiber,fiber);push(contextStackCursor$1,NO_CONTEXT,fiber);nextRootInstance=getRootHostContext(nextRootInstance);pop(contextStackCursor$1,fiber);push(contextStackCursor$1,nextRootInstance,fiber)}function popHostContainer(fiber){pop(contextStackCursor$1,fiber);pop(contextFiberStackCursor,fiber);pop(rootInstanceStackCursor,fiber)}function pushHostContext(fiber){var rootInstance=
requiredContext(rootInstanceStackCursor.current),context=requiredContext(contextStackCursor$1.current);rootInstance=getChildHostContext(context,fiber.type,rootInstance);context!==rootInstance&&(push(contextFiberStackCursor,fiber,fiber),push(contextStackCursor$1,rootInstance,fiber))}function popHostContext(fiber){contextFiberStackCursor.current===fiber&&(pop(contextStackCursor$1,fiber),pop(contextFiberStackCursor,fiber))}function findFirstSuspended(row){for(var node=row;null!==node;){if(13===node.tag){var state=
node.memoizedState;if(null!==state&&(state=state.dehydrated,null===state||isSuspenseInstancePending(state)||isSuspenseInstanceFallback(state)))return node}else if(19===node.tag&&void 0!==node.memoizedProps.revealOrder){if(0!==(node.flags&128))return node}else if(null!==node.child){node.child.return=node;node=node.child;continue}if(node===row)break;for(;null===node.sibling;){if(null===node.return||node.return===row)return null;node=node.return}node.sibling.return=node.return;node=node.sibling}return null}
function resetWorkInProgressVersions(){for(var i=0;i<workInProgressSources.length;i++){var mutableSource=workInProgressSources[i];isPrimaryRenderer?mutableSource._workInProgressVersionPrimary=null:mutableSource._workInProgressVersionSecondary=null}workInProgressSources.length=0}function mountHookTypesDev(){var hookName=currentHookNameInDev;null===hookTypesDev?hookTypesDev=[hookName]:hookTypesDev.push(hookName)}function updateHookTypesDev(){var hookName=currentHookNameInDev;if(null!==hookTypesDev&&
(hookTypesUpdateIndexDev++,hookTypesDev[hookTypesUpdateIndexDev]!==hookName)){var componentName=getComponentNameFromFiber(currentlyRenderingFiber$1);if(!didWarnAboutMismatchedHooksForComponent.has(componentName)&&(didWarnAboutMismatchedHooksForComponent.add(componentName),null!==hookTypesDev)){for(var table="",i=0;i<=hookTypesUpdateIndexDev;i++){var oldHookName=hookTypesDev[i],newHookName=i===hookTypesUpdateIndexDev?hookName:oldHookName;for(oldHookName=i+1+". "+oldHookName;30>oldHookName.length;)oldHookName+=
" ";oldHookName+=newHookName+"\n";table+=oldHookName}error$jscomp$0("React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks\n\n   Previous render            Next render\n   ------------------------------------------------------\n%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n",componentName,table)}}}function checkDepsAreArrayDev(deps){void 0===
deps||null===deps||isArrayImpl(deps)||error$jscomp$0("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.",currentHookNameInDev,typeof deps)}function throwInvalidHookError(){throw Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:\n1. You might have mismatching versions of React and the renderer (such as React DOM)\n2. You might be breaking the Rules of Hooks\n3. You might have more than one copy of React in the same app\nSee https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
}function areHookInputsEqual(nextDeps,prevDeps){if(ignorePreviousDependencies)return!1;if(null===prevDeps)return error$jscomp$0("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.",currentHookNameInDev),!1;nextDeps.length!==prevDeps.length&&error$jscomp$0("The final argument passed to %s changed size between renders. The order and size of this array must remain constant.\n\nPrevious: %s\nIncoming: %s",
currentHookNameInDev,"["+prevDeps.join(", ")+"]","["+nextDeps.join(", ")+"]");for(var i=0;i<prevDeps.length&&i<nextDeps.length;i++)if(!objectIs(nextDeps[i],prevDeps[i]))return!1;return!0}function renderWithHooks(current,workInProgress,Component,props,secondArg,nextRenderLanes){renderLanes$jscomp$0=nextRenderLanes;currentlyRenderingFiber$1=workInProgress;hookTypesDev=null!==current?current._debugHookTypes:null;hookTypesUpdateIndexDev=-1;ignorePreviousDependencies=null!==current&&current.type!==workInProgress.type;
workInProgress.memoizedState=null;workInProgress.updateQueue=null;workInProgress.lanes=0;ReactCurrentDispatcher$1.current=null!==current&&null!==current.memoizedState?HooksDispatcherOnUpdateInDEV:null!==hookTypesDev?HooksDispatcherOnMountWithHookTypesInDEV:HooksDispatcherOnMountInDEV;nextRenderLanes=Component(props,secondArg);if(didScheduleRenderPhaseUpdateDuringThisPass){var numberOfReRenders=0;do{didScheduleRenderPhaseUpdateDuringThisPass=!1;localIdCounter=0;if(25<=numberOfReRenders)throw Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
numberOfReRenders+=1;ignorePreviousDependencies=!1;workInProgressHook=currentHook=null;workInProgress.updateQueue=null;hookTypesUpdateIndexDev=-1;ReactCurrentDispatcher$1.current=HooksDispatcherOnRerenderInDEV;nextRenderLanes=Component(props,secondArg)}while(didScheduleRenderPhaseUpdateDuringThisPass)}ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;workInProgress._debugHookTypes=hookTypesDev;Component=null!==currentHook&&null!==currentHook.next;renderLanes$jscomp$0=0;hookTypesDev=currentHookNameInDev=
workInProgressHook=currentHook=currentlyRenderingFiber$1=null;hookTypesUpdateIndexDev=-1;null!==current&&(current.flags&14680064)!==(workInProgress.flags&14680064)&&0!==(current.mode&1)&&error$jscomp$0("Internal React error: Expected static flag was missing. Please notify the React team.");didScheduleRenderPhaseUpdate=!1;if(Component)throw Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");return nextRenderLanes}function checkDidRenderIdHook(){var didRenderIdHook=
0!==localIdCounter;localIdCounter=0;return didRenderIdHook}function bailoutHooks(current,workInProgress,lanes){workInProgress.updateQueue=current.updateQueue;workInProgress.flags=0!==(workInProgress.mode&16)?workInProgress.flags&-50333701:workInProgress.flags&-2053;current.lanes&=~lanes}function resetHooksAfterThrow(){ReactCurrentDispatcher$1.current=ContextOnlyDispatcher;if(didScheduleRenderPhaseUpdate){for(var hook=currentlyRenderingFiber$1.memoizedState;null!==hook;){var queue=hook.queue;null!==
queue&&(queue.pending=null);hook=hook.next}didScheduleRenderPhaseUpdate=!1}renderLanes$jscomp$0=0;hookTypesDev=workInProgressHook=currentHook=currentlyRenderingFiber$1=null;hookTypesUpdateIndexDev=-1;currentHookNameInDev=null;didScheduleRenderPhaseUpdateDuringThisPass=isUpdatingOpaqueValueInRenderPhase=!1;localIdCounter=0}function mountWorkInProgressHook(){var hook={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};null===workInProgressHook?currentlyRenderingFiber$1.memoizedState=
workInProgressHook=hook:workInProgressHook=workInProgressHook.next=hook;return workInProgressHook}function updateWorkInProgressHook(){if(null===currentHook){var nextCurrentHook=currentlyRenderingFiber$1.alternate;nextCurrentHook=null!==nextCurrentHook?nextCurrentHook.memoizedState:null}else nextCurrentHook=currentHook.next;var nextWorkInProgressHook=null===workInProgressHook?currentlyRenderingFiber$1.memoizedState:workInProgressHook.next;if(null!==nextWorkInProgressHook)workInProgressHook=nextWorkInProgressHook,
currentHook=nextCurrentHook;else{if(null===nextCurrentHook)throw Error("Rendered more hooks than during the previous render.");currentHook=nextCurrentHook;nextCurrentHook={memoizedState:currentHook.memoizedState,baseState:currentHook.baseState,baseQueue:currentHook.baseQueue,queue:currentHook.queue,next:null};null===workInProgressHook?currentlyRenderingFiber$1.memoizedState=workInProgressHook=nextCurrentHook:workInProgressHook=workInProgressHook.next=nextCurrentHook}return workInProgressHook}function basicStateReducer(state,
action){return"function"===typeof action?action(state):action}function mountReducer(reducer,initialArg,init){var hook=mountWorkInProgressHook();initialArg=void 0!==init?init(initialArg):initialArg;hook.memoizedState=hook.baseState=initialArg;reducer={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:reducer,lastRenderedState:initialArg};hook.queue=reducer;reducer=reducer.dispatch=dispatchReducerAction.bind(null,currentlyRenderingFiber$1,reducer);return[hook.memoizedState,reducer]}
function updateReducer(reducer,initialArg,init){initialArg=updateWorkInProgressHook();init=initialArg.queue;if(null===init)throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");init.lastRenderedReducer=reducer;var current=currentHook,baseQueue=current.baseQueue,pendingQueue=init.pending;if(null!==pendingQueue){if(null!==baseQueue){var baseFirst=baseQueue.next;baseQueue.next=pendingQueue.next;pendingQueue.next=baseFirst}current.baseQueue!==baseQueue&&error$jscomp$0("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React.");
current.baseQueue=baseQueue=pendingQueue;init.pending=null}if(null!==baseQueue){pendingQueue=baseQueue.next;current=current.baseState;var newBaseQueueFirst=baseFirst=null,newBaseQueueLast=null,update=pendingQueue;do{var updateLane=update.lane;if((renderLanes$jscomp$0&updateLane)===updateLane)null!==newBaseQueueLast&&(newBaseQueueLast=newBaseQueueLast.next={lane:0,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null}),current=update.hasEagerState?update.eagerState:
reducer(current,update.action);else{var clone={lane:updateLane,action:update.action,hasEagerState:update.hasEagerState,eagerState:update.eagerState,next:null};null===newBaseQueueLast?(newBaseQueueFirst=newBaseQueueLast=clone,baseFirst=current):newBaseQueueLast=newBaseQueueLast.next=clone;currentlyRenderingFiber$1.lanes|=updateLane;workInProgressRootSkippedLanes|=updateLane}update=update.next}while(null!==update&&update!==pendingQueue);null===newBaseQueueLast?baseFirst=current:newBaseQueueLast.next=
newBaseQueueFirst;objectIs(current,initialArg.memoizedState)||(didReceiveUpdate=!0);initialArg.memoizedState=current;initialArg.baseState=baseFirst;initialArg.baseQueue=newBaseQueueLast;init.lastRenderedState=current}reducer=init.interleaved;if(null!==reducer){baseQueue=reducer;do pendingQueue=baseQueue.lane,currentlyRenderingFiber$1.lanes|=pendingQueue,workInProgressRootSkippedLanes|=pendingQueue,baseQueue=baseQueue.next;while(baseQueue!==reducer)}else null===baseQueue&&(init.lanes=0);return[initialArg.memoizedState,
init.dispatch]}function rerenderReducer(reducer,initialArg,init){initialArg=updateWorkInProgressHook();init=initialArg.queue;if(null===init)throw Error("Should have a queue. This is likely a bug in React. Please file an issue.");init.lastRenderedReducer=reducer;var dispatch=init.dispatch,lastRenderPhaseUpdate=init.pending,newState=initialArg.memoizedState;if(null!==lastRenderPhaseUpdate){init.pending=null;var update=lastRenderPhaseUpdate=lastRenderPhaseUpdate.next;do newState=reducer(newState,update.action),
update=update.next;while(update!==lastRenderPhaseUpdate);objectIs(newState,initialArg.memoizedState)||(didReceiveUpdate=!0);initialArg.memoizedState=newState;null===initialArg.baseQueue&&(initialArg.baseState=newState);init.lastRenderedState=newState}return[newState,dispatch]}function mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot){var fiber=currentlyRenderingFiber$1,hook=mountWorkInProgressHook();if(isHydrating){if(void 0===getServerSnapshot)throw Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
var nextSnapshot=getServerSnapshot();didWarnUncachedGetSnapshot||nextSnapshot===getServerSnapshot()||(error$jscomp$0("The result of getServerSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}else{nextSnapshot=getSnapshot();didWarnUncachedGetSnapshot||(getServerSnapshot=getSnapshot(),objectIs(nextSnapshot,getServerSnapshot)||(error$jscomp$0("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0));if(null===workInProgressRoot)throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
0!==(renderLanes$jscomp$0&30)||pushStoreConsistencyCheck(fiber,getSnapshot,nextSnapshot)}hook.memoizedState=nextSnapshot;getServerSnapshot={value:nextSnapshot,getSnapshot};hook.queue=getServerSnapshot;mountEffect(subscribeToStore.bind(null,fiber,getServerSnapshot,subscribe),[subscribe]);fiber.flags|=2048;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,fiber,getServerSnapshot,nextSnapshot,getSnapshot),void 0,null);return nextSnapshot}function updateSyncExternalStore(subscribe,getSnapshot,
getServerSnapshot){getServerSnapshot=currentlyRenderingFiber$1;var hook=updateWorkInProgressHook(),nextSnapshot=getSnapshot();if(!didWarnUncachedGetSnapshot){var cachedSnapshot=getSnapshot();objectIs(nextSnapshot,cachedSnapshot)||(error$jscomp$0("The result of getSnapshot should be cached to avoid an infinite loop"),didWarnUncachedGetSnapshot=!0)}if(cachedSnapshot=!objectIs(hook.memoizedState,nextSnapshot))hook.memoizedState=nextSnapshot,didReceiveUpdate=!0;hook=hook.queue;updateEffect(subscribeToStore.bind(null,
getServerSnapshot,hook,subscribe),[subscribe]);if(hook.getSnapshot!==getSnapshot||cachedSnapshot||null!==workInProgressHook&&workInProgressHook.memoizedState.tag&HasEffect){getServerSnapshot.flags|=2048;pushEffect(HasEffect|Passive$1,updateStoreInstance.bind(null,getServerSnapshot,hook,nextSnapshot,getSnapshot),void 0,null);if(null===workInProgressRoot)throw Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");0!==(renderLanes$jscomp$0&30)||pushStoreConsistencyCheck(getServerSnapshot,
getSnapshot,nextSnapshot)}return nextSnapshot}function pushStoreConsistencyCheck(fiber,getSnapshot,renderedSnapshot){fiber.flags|=16384;fiber={getSnapshot,value:renderedSnapshot};getSnapshot=currentlyRenderingFiber$1.updateQueue;null===getSnapshot?(getSnapshot={lastEffect:null,stores:null},currentlyRenderingFiber$1.updateQueue=getSnapshot,getSnapshot.stores=[fiber]):(renderedSnapshot=getSnapshot.stores,null===renderedSnapshot?getSnapshot.stores=[fiber]:renderedSnapshot.push(fiber))}function updateStoreInstance(fiber,
inst,nextSnapshot,getSnapshot){inst.value=nextSnapshot;inst.getSnapshot=getSnapshot;checkIfSnapshotChanged(inst)&&scheduleUpdateOnFiber(fiber,1,-1)}function subscribeToStore(fiber,inst,subscribe){return subscribe(function(){checkIfSnapshotChanged(inst)&&scheduleUpdateOnFiber(fiber,1,-1)})}function checkIfSnapshotChanged(inst){var latestGetSnapshot=inst.getSnapshot;inst=inst.value;try{var nextValue=latestGetSnapshot();return!objectIs(inst,nextValue)}catch(error){return!0}}function mountState(initialState){var hook=
mountWorkInProgressHook();"function"===typeof initialState&&(initialState=initialState());hook.memoizedState=hook.baseState=initialState;initialState={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:basicStateReducer,lastRenderedState:initialState};hook.queue=initialState;initialState=initialState.dispatch=dispatchSetState.bind(null,currentlyRenderingFiber$1,initialState);return[hook.memoizedState,initialState]}function pushEffect(tag,create,destroy,deps){tag={tag,create,destroy,
deps,next:null};create=currentlyRenderingFiber$1.updateQueue;null===create?(create={lastEffect:null,stores:null},currentlyRenderingFiber$1.updateQueue=create,create.lastEffect=tag.next=tag):(destroy=create.lastEffect,null===destroy?create.lastEffect=tag.next=tag:(deps=destroy.next,destroy.next=tag,tag.next=deps,create.lastEffect=tag));return tag}function mountRef(initialValue){var hook=mountWorkInProgressHook();initialValue={current:initialValue};return hook.memoizedState=initialValue}function mountEffectImpl(fiberFlags,
hookFlags,create,deps){var hook=mountWorkInProgressHook();currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,void 0,void 0===deps?null:deps)}function updateEffectImpl(fiberFlags,hookFlags,create,deps){var hook=updateWorkInProgressHook();deps=void 0===deps?null:deps;var destroy=void 0;if(null!==currentHook){var prevEffect=currentHook.memoizedState;destroy=prevEffect.destroy;if(null!==deps&&areHookInputsEqual(deps,prevEffect.deps)){hook.memoizedState=
pushEffect(hookFlags,create,destroy,deps);return}}currentlyRenderingFiber$1.flags|=fiberFlags;hook.memoizedState=pushEffect(HasEffect|hookFlags,create,destroy,deps)}function mountEffect(create,deps){return 0!==(currentlyRenderingFiber$1.mode&16)?mountEffectImpl(41945088,Passive$1,create,deps):mountEffectImpl(8390656,Passive$1,create,deps)}function updateEffect(create,deps){return updateEffectImpl(2048,Passive$1,create,deps)}function mountLayoutEffect(create,deps){var fiberFlags=4194308;0!==(currentlyRenderingFiber$1.mode&
16)&&(fiberFlags|=16777216);return mountEffectImpl(fiberFlags,Layout,create,deps)}function imperativeHandleEffect(create,ref){if("function"===typeof ref)return create=create(),ref(create),function(){ref(null)};if(null!==ref&&void 0!==ref)return ref.hasOwnProperty("current")||error$jscomp$0("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.","an object with keys {"+Object.keys(ref).join(", ")+"}"),create=create(),ref.current=
create,function(){ref.current=null}}function mountImperativeHandle(ref,create,deps){"function"!==typeof create&&error$jscomp$0("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",null!==create?typeof create:"null");deps=null!==deps&&void 0!==deps?deps.concat([ref]):null;var fiberFlags=4194308;0!==(currentlyRenderingFiber$1.mode&16)&&(fiberFlags|=16777216);return mountEffectImpl(fiberFlags,Layout,imperativeHandleEffect.bind(null,create,ref),
deps)}function updateImperativeHandle(ref,create,deps){"function"!==typeof create&&error$jscomp$0("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.",null!==create?typeof create:"null");deps=null!==deps&&void 0!==deps?deps.concat([ref]):null;return updateEffectImpl(4,Layout,imperativeHandleEffect.bind(null,create,ref),deps)}function mountCallback(callback,deps){mountWorkInProgressHook().memoizedState=[callback,void 0===deps?null:deps];return callback}
function updateCallback(callback,deps){var hook=updateWorkInProgressHook();deps=void 0===deps?null:deps;var prevState=hook.memoizedState;if(null!==prevState&&null!==deps&&areHookInputsEqual(deps,prevState[1]))return prevState[0];hook.memoizedState=[callback,deps];return callback}function mountMemo(nextCreate,deps){var hook=mountWorkInProgressHook();deps=void 0===deps?null:deps;nextCreate=nextCreate();hook.memoizedState=[nextCreate,deps];return nextCreate}function updateMemo(nextCreate,deps){var hook=
updateWorkInProgressHook();deps=void 0===deps?null:deps;var prevState=hook.memoizedState;if(null!==prevState&&null!==deps&&areHookInputsEqual(deps,prevState[1]))return prevState[0];nextCreate=nextCreate();hook.memoizedState=[nextCreate,deps];return nextCreate}function mountDeferredValue(value){var _mountState=mountState(value),prevValue=_mountState[0],setValue=_mountState[1];mountEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition={};try{setValue(value)}finally{ReactCurrentBatchConfig$1.transition=
prevTransition}},[value]);return prevValue}function updateDeferredValue(value){var _updateState=updateReducer(basicStateReducer),prevValue=_updateState[0],setValue=_updateState[1];updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition={};try{setValue(value)}finally{ReactCurrentBatchConfig$1.transition=prevTransition}},[value]);return prevValue}function rerenderDeferredValue(value){var _rerenderState=rerenderReducer(basicStateReducer),prevValue=
_rerenderState[0],setValue=_rerenderState[1];updateEffect(function(){var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition={};try{setValue(value)}finally{ReactCurrentBatchConfig$1.transition=prevTransition}},[value]);return prevValue}function startTransition(setPending,callback,options){options=currentUpdatePriority;currentUpdatePriority=0!==options&&4>options?options:4;setPending(!0);var prevTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition=
{};var currentTransition=ReactCurrentBatchConfig$1.transition;ReactCurrentBatchConfig$1.transition._updatedFibers=new Set;try{setPending(!1),callback()}finally{currentUpdatePriority=options,ReactCurrentBatchConfig$1.transition=prevTransition,null===prevTransition&&currentTransition._updatedFibers&&(10<currentTransition._updatedFibers.size&&warn("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."),
currentTransition._updatedFibers.clear())}}function mountTransition(){var _mountState2=mountState(!1),isPending=_mountState2[0];_mountState2=startTransition.bind(null,_mountState2[1]);mountWorkInProgressHook().memoizedState=_mountState2;return[isPending,_mountState2]}function updateTransition(){var isPending=updateReducer(basicStateReducer)[0],start=updateWorkInProgressHook().memoizedState;return[isPending,start]}function rerenderTransition(){var isPending=rerenderReducer(basicStateReducer)[0],start=
updateWorkInProgressHook().memoizedState;return[isPending,start]}function mountId(){var hook=mountWorkInProgressHook(),identifierPrefix=workInProgressRoot.identifierPrefix;if(isHydrating){var treeId=treeContextOverflow;var idWithLeadingBit=treeContextId;treeId=(idWithLeadingBit&~(1<<32-clz32(idWithLeadingBit)-1)).toString(32)+treeId;identifierPrefix=":"+identifierPrefix+"R"+treeId;treeId=localIdCounter++;0<treeId&&(identifierPrefix+="H"+treeId.toString(32));identifierPrefix+=":"}else treeId=globalClientIdCounter++,
identifierPrefix=":"+identifierPrefix+"r"+treeId.toString(32)+":";return hook.memoizedState=identifierPrefix}function dispatchReducerAction(fiber,queue,action,JSCompiler_OptimizeArgumentsArray_p4){"function"===typeof JSCompiler_OptimizeArgumentsArray_p4&&error$jscomp$0("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");JSCompiler_OptimizeArgumentsArray_p4=
requestUpdateLane(fiber);action={lane:JSCompiler_OptimizeArgumentsArray_p4,action,hasEagerState:!1,eagerState:null,next:null};isRenderPhaseUpdate(fiber)?enqueueRenderPhaseUpdate(queue,action):(enqueueUpdate$1(fiber,queue,action),action=requestEventTime(),action=scheduleUpdateOnFiber(fiber,JSCompiler_OptimizeArgumentsArray_p4,action),null!==action&&entangleTransitionUpdate(action,queue,JSCompiler_OptimizeArgumentsArray_p4));markStateUpdateScheduled(fiber,JSCompiler_OptimizeArgumentsArray_p4)}function dispatchSetState(fiber,
queue,action,JSCompiler_OptimizeArgumentsArray_p5){"function"===typeof JSCompiler_OptimizeArgumentsArray_p5&&error$jscomp$0("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");JSCompiler_OptimizeArgumentsArray_p5=requestUpdateLane(fiber);var update={lane:JSCompiler_OptimizeArgumentsArray_p5,action,hasEagerState:!1,eagerState:null,next:null};if(isRenderPhaseUpdate(fiber))enqueueRenderPhaseUpdate(queue,
update);else{enqueueUpdate$1(fiber,queue,update);var alternate=fiber.alternate;if(0===fiber.lanes&&(null===alternate||0===alternate.lanes)&&(alternate=queue.lastRenderedReducer,null!==alternate)){var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{var currentState=queue.lastRenderedState,eagerState=alternate(currentState,action);update.hasEagerState=!0;update.eagerState=eagerState;if(objectIs(eagerState,currentState))return}catch(error){}finally{ReactCurrentDispatcher$1.current=
prevDispatcher}}action=requestEventTime();action=scheduleUpdateOnFiber(fiber,JSCompiler_OptimizeArgumentsArray_p5,action);null!==action&&entangleTransitionUpdate(action,queue,JSCompiler_OptimizeArgumentsArray_p5)}markStateUpdateScheduled(fiber,JSCompiler_OptimizeArgumentsArray_p5)}function isRenderPhaseUpdate(fiber){var alternate=fiber.alternate;return fiber===currentlyRenderingFiber$1||null!==alternate&&alternate===currentlyRenderingFiber$1}function enqueueRenderPhaseUpdate(queue,update){didScheduleRenderPhaseUpdateDuringThisPass=
didScheduleRenderPhaseUpdate=!0;var pending=queue.pending;null===pending?update.next=update:(update.next=pending.next,pending.next=update);queue.pending=update}function enqueueUpdate$1(fiber,queue,update,lane){null!==workInProgressRoot&&0!==(fiber.mode&1)&&(executionContext&RenderContext)===NoContext?(fiber=queue.interleaved,null===fiber?(update.next=update,null===interleavedQueues?interleavedQueues=[queue]:interleavedQueues.push(queue)):(update.next=fiber.next,fiber.next=update),queue.interleaved=
update):(fiber=queue.pending,null===fiber?update.next=update:(update.next=fiber.next,fiber.next=update),queue.pending=update)}function entangleTransitionUpdate(root,queue,lane){if(0!==(lane&4194240)){var queueLanes=queue.lanes;queueLanes&=root.pendingLanes;lane|=queueLanes;queue.lanes=lane;markRootEntangled(root,lane)}}function startProfilerTimer(fiber){profilerStartTime=now$2();0>fiber.actualStartTime&&(fiber.actualStartTime=now$2())}function stopProfilerTimerIfRunningAndRecordDelta(fiber,overrideBaseTime){if(0<=
profilerStartTime){var elapsedTime=now$2()-profilerStartTime;fiber.actualDuration+=elapsedTime;overrideBaseTime&&(fiber.selfBaseDuration=elapsedTime);profilerStartTime=-1}}function recordLayoutEffectDuration(fiber){if(0<=layoutEffectStartTime){var elapsedTime=now$2()-layoutEffectStartTime;layoutEffectStartTime=-1;for(fiber=fiber.return;null!==fiber;){switch(fiber.tag){case 3:fiber.stateNode.effectDuration+=elapsedTime;return;case 12:fiber.stateNode.effectDuration+=elapsedTime;return}fiber=fiber.return}}}
function recordPassiveEffectDuration(fiber){if(0<=passiveEffectStartTime){var elapsedTime=now$2()-passiveEffectStartTime;passiveEffectStartTime=-1;for(fiber=fiber.return;null!==fiber;){switch(fiber.tag){case 3:fiber=fiber.stateNode;null!==fiber&&(fiber.passiveEffectDuration+=elapsedTime);return;case 12:fiber=fiber.stateNode;null!==fiber&&(fiber.passiveEffectDuration+=elapsedTime);return}fiber=fiber.return}}}function startLayoutEffectTimer(){layoutEffectStartTime=now$2()}function transferActualDuration(fiber){for(var child=
fiber.child;child;)fiber.actualDuration+=child.actualDuration,child=child.sibling}function createCapturedValue(value,source){return{value,source,stack:getStackByFiberInDevAndProd(source)}}function logCapturedError(boundary,errorInfo){try{var error=errorInfo.value,source=errorInfo.source,stack=errorInfo.stack;errorInfo=null!==stack?stack:"";if(null!=error&&error._suppressLogging){if(1===boundary.tag)return;console.error(error)}var componentName=source?getComponentNameFromFiber(source):null;error=componentName?
"The above error occurred in the \x3c"+componentName+"\x3e component:":"The above error occurred in one of your React components:";var errorBoundaryMessage=3===boundary.tag?"Consider adding an error boundary to your tree to customize error handling behavior.\nVisit https://reactjs.org/link/error-boundaries to learn more about error boundaries.":"React will try to recreate this component tree from scratch using the error boundary you provided, "+((getComponentNameFromFiber(boundary)||"Anonymous")+
".");console.error(error+"\n"+errorInfo+"\n\n"+errorBoundaryMessage)}catch(e){setTimeout(function(){throw e;})}}function createRootErrorUpdate(fiber,errorInfo,lane){lane=createUpdate(-1,lane);lane.tag=3;lane.payload={element:null};var error=errorInfo.value;lane.callback=function(){hasUncaughtError||(hasUncaughtError=!0,firstUncaughtError=error);logCapturedError(fiber,errorInfo)};return lane}function createClassErrorUpdate(fiber,errorInfo,lane){lane=createUpdate(-1,lane);lane.tag=3;var getDerivedStateFromError=
fiber.type.getDerivedStateFromError;if("function"===typeof getDerivedStateFromError){var error$1=errorInfo.value;lane.payload=function(){return getDerivedStateFromError(error$1)};lane.callback=function(){markFailedErrorBoundaryForHotReloading(fiber);logCapturedError(fiber,errorInfo)}}var inst=fiber.stateNode;null!==inst&&"function"===typeof inst.componentDidCatch&&(lane.callback=function(){markFailedErrorBoundaryForHotReloading(fiber);logCapturedError(fiber,errorInfo);"function"!==typeof getDerivedStateFromError&&
(null===legacyErrorBoundariesThatAlreadyFailed?legacyErrorBoundariesThatAlreadyFailed=new Set([this]):legacyErrorBoundariesThatAlreadyFailed.add(this));var stack=errorInfo.stack;this.componentDidCatch(errorInfo.value,{componentStack:null!==stack?stack:""});"function"===typeof getDerivedStateFromError||0===(fiber.lanes&1)&&error$jscomp$0("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.",getComponentNameFromFiber(fiber)||
"Unknown")});return lane}function attachPingListener(root,wakeable,lanes){var pingCache=root.pingCache;if(null===pingCache){pingCache=root.pingCache=new PossiblyWeakMap$1;var threadIDs=new Set;pingCache.set(wakeable,threadIDs)}else threadIDs=pingCache.get(wakeable),void 0===threadIDs&&(threadIDs=new Set,pingCache.set(wakeable,threadIDs));threadIDs.has(lanes)||(threadIDs.add(lanes),pingCache=pingSuspendedRoot.bind(null,root,wakeable,lanes),isDevToolsPresent&&restorePendingUpdaters(root,lanes),wakeable.then(pingCache,
pingCache))}function getNearestSuspenseBoundaryToCapture(returnFiber){do{var JSCompiler_temp;if(JSCompiler_temp=13===returnFiber.tag)JSCompiler_temp=returnFiber.memoizedState,JSCompiler_temp=null!==JSCompiler_temp?null!==JSCompiler_temp.dehydrated?!0:!1:!0;if(JSCompiler_temp)return returnFiber;returnFiber=returnFiber.return}while(null!==returnFiber);return null}function markSuspenseBoundaryShouldCapture(suspenseBoundary,returnFiber,sourceFiber,root,rootRenderLanes){if(0===(suspenseBoundary.mode&1))return suspenseBoundary===
returnFiber?suspenseBoundary.flags|=65536:(suspenseBoundary.flags|=128,sourceFiber.flags|=131072,sourceFiber.flags&=-52805,1===sourceFiber.tag&&(null===sourceFiber.alternate?sourceFiber.tag=17:(returnFiber=createUpdate(-1,1),returnFiber.tag=ForceUpdate,enqueueUpdate(sourceFiber,returnFiber))),sourceFiber.lanes|=1),suspenseBoundary;suspenseBoundary.flags|=65536;suspenseBoundary.lanes=rootRenderLanes;return suspenseBoundary}function markUpdate(workInProgress){workInProgress.flags|=4}function hadNoMutationsEffects(current,
completedWork){if(null!==current&&current.child===completedWork.child)return!0;if(0!==(completedWork.flags&16))return!1;for(current=completedWork.child;null!==current;){if(0!==(current.flags&12854)||0!==(current.subtreeFlags&12854))return!1;current=current.sibling}return!0}function cutOffTailIfNeeded(renderState,hasRenderedATailFallback){if(!isHydrating)switch(renderState.tailMode){case "hidden":hasRenderedATailFallback=renderState.tail;for(var lastTailNode=null;null!==hasRenderedATailFallback;)null!==
hasRenderedATailFallback.alternate&&(lastTailNode=hasRenderedATailFallback),hasRenderedATailFallback=hasRenderedATailFallback.sibling;null===lastTailNode?renderState.tail=null:lastTailNode.sibling=null;break;case "collapsed":lastTailNode=renderState.tail;for(var _lastTailNode=null;null!==lastTailNode;)null!==lastTailNode.alternate&&(_lastTailNode=lastTailNode),lastTailNode=lastTailNode.sibling;null===_lastTailNode?hasRenderedATailFallback||null===renderState.tail?renderState.tail=null:renderState.tail.sibling=
null:_lastTailNode.sibling=null}}function bubbleProperties(completedWork){var didBailout=null!==completedWork.alternate&&completedWork.alternate.child===completedWork.child,newChildLanes=0,subtreeFlags=0;if(didBailout)if(0!==(completedWork.mode&2)){for(var _treeBaseDuration=completedWork.selfBaseDuration,_child2=completedWork.child;null!==_child2;)newChildLanes|=_child2.lanes|_child2.childLanes,subtreeFlags|=_child2.subtreeFlags&14680064,subtreeFlags|=_child2.flags&14680064,_treeBaseDuration+=_child2.treeBaseDuration,
_child2=_child2.sibling;completedWork.treeBaseDuration=_treeBaseDuration}else for(_treeBaseDuration=completedWork.child;null!==_treeBaseDuration;)newChildLanes|=_treeBaseDuration.lanes|_treeBaseDuration.childLanes,subtreeFlags|=_treeBaseDuration.subtreeFlags&14680064,subtreeFlags|=_treeBaseDuration.flags&14680064,_treeBaseDuration.return=completedWork,_treeBaseDuration=_treeBaseDuration.sibling;else if(0!==(completedWork.mode&2)){_treeBaseDuration=completedWork.actualDuration;_child2=completedWork.selfBaseDuration;
for(var child=completedWork.child;null!==child;)newChildLanes|=child.lanes|child.childLanes,subtreeFlags|=child.subtreeFlags,subtreeFlags|=child.flags,_treeBaseDuration+=child.actualDuration,_child2+=child.treeBaseDuration,child=child.sibling;completedWork.actualDuration=_treeBaseDuration;completedWork.treeBaseDuration=_child2}else for(_treeBaseDuration=completedWork.child;null!==_treeBaseDuration;)newChildLanes|=_treeBaseDuration.lanes|_treeBaseDuration.childLanes,subtreeFlags|=_treeBaseDuration.subtreeFlags,
subtreeFlags|=_treeBaseDuration.flags,_treeBaseDuration.return=completedWork,_treeBaseDuration=_treeBaseDuration.sibling;completedWork.subtreeFlags|=subtreeFlags;completedWork.childLanes=newChildLanes;return didBailout}function completeWork(current,workInProgress,renderLanes){var newProps=workInProgress.pendingProps;popTreeContext(workInProgress);switch(workInProgress.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return bubbleProperties(workInProgress),null;case 1:return isContextProvider(workInProgress.type)&&
popContext(workInProgress),bubbleProperties(workInProgress),null;case 3:newProps=workInProgress.stateNode;popHostContainer(workInProgress);popTopLevelContextObject(workInProgress);resetWorkInProgressVersions();newProps.pendingContext&&(newProps.context=newProps.pendingContext,newProps.pendingContext=null);if(null===current||null===current.child)popHydrationState(workInProgress)?markUpdate(workInProgress):null===current||current.memoizedState.isDehydrated&&0===(workInProgress.flags&256)||(workInProgress.flags|=
1024,null!==hydrationErrors&&(queueRecoverableErrors(hydrationErrors),hydrationErrors=null));updateHostContainer(current,workInProgress);bubbleProperties(workInProgress);return null;case 5:popHostContext(workInProgress);renderLanes=requiredContext(rootInstanceStackCursor.current);var type=workInProgress.type;if(null!==current&&null!=workInProgress.stateNode)updateHostComponent(current,workInProgress,type,newProps,renderLanes),current.ref!==workInProgress.ref&&(workInProgress.flags|=512,workInProgress.flags|=
2097152);else{if(!newProps){if(null===workInProgress.stateNode)throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");bubbleProperties(workInProgress);return null}current=requiredContext(contextStackCursor$1.current);if(popHydrationState(workInProgress)){if(!supportsHydration)throw Error("Expected prepareToHydrateHostInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");current=hydrateInstance(workInProgress.stateNode,
workInProgress.type,workInProgress.memoizedProps,renderLanes,current,workInProgress,!didSuspend$jscomp$0);workInProgress.updateQueue=current;null!==current&&markUpdate(workInProgress)}else{var instance=createInstance(type,newProps,renderLanes,current,workInProgress);appendAllChildren(instance,workInProgress,!1,!1);workInProgress.stateNode=instance;finalizeInitialChildren(instance,type,newProps,renderLanes,current)&&markUpdate(workInProgress)}null!==workInProgress.ref&&(workInProgress.flags|=512,workInProgress.flags|=
2097152)}bubbleProperties(workInProgress);return null;case 6:if(current&&null!=workInProgress.stateNode)updateHostText(current,workInProgress,current.memoizedProps,newProps);else{if("string"!==typeof newProps&&null===workInProgress.stateNode)throw Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");current=requiredContext(rootInstanceStackCursor.current);renderLanes=requiredContext(contextStackCursor$1.current);if(popHydrationState(workInProgress)){if(!supportsHydration)throw Error("Expected prepareToHydrateHostTextInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");
current=workInProgress.stateNode;newProps=workInProgress.memoizedProps;if(renderLanes=hydrateTextInstance(current,newProps,workInProgress,!didSuspend$jscomp$0))if(type=hydrationParentFiber,null!==type)switch(instance=0!==(type.mode&1),type.tag){case 3:didNotMatchHydratedContainerTextInstance(type.stateNode.containerInfo,current,newProps,instance);break;case 5:didNotMatchHydratedTextInstance(type.type,type.memoizedProps,type.stateNode,current,newProps,instance)}renderLanes&&markUpdate(workInProgress)}else workInProgress.stateNode=
createTextInstance(newProps,current,renderLanes,workInProgress)}bubbleProperties(workInProgress);return null;case 13:pop(suspenseStackCursor,workInProgress);newProps=workInProgress.memoizedState;if(isHydrating&&null!==nextHydratableInstance&&0!==(workInProgress.mode&1)&&0===(workInProgress.flags&128))return warnIfUnhydratedTailNodes(workInProgress),resetHydrationState(),workInProgress.flags|=98560,workInProgress;if(null!==newProps&&null!==newProps.dehydrated){renderLanes=popHydrationState(workInProgress);
if(null===current){if(!renderLanes)throw Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");if(!supportsHydration)throw Error("Expected prepareToHydrateHostSuspenseInstance() to never be called. This error is likely caused by a bug in React. Please file an issue.");current=workInProgress.memoizedState;current=null!==current?current.dehydrated:null;if(!current)throw Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
hydrateSuspenseInstance(current,workInProgress);bubbleProperties(workInProgress);0!==(workInProgress.mode&2)&&null!==newProps&&(current=workInProgress.child,null!==current&&(workInProgress.treeBaseDuration-=current.treeBaseDuration))}else resetHydrationState(),0===(workInProgress.flags&128)&&(workInProgress.memoizedState=null),workInProgress.flags|=4,bubbleProperties(workInProgress),0!==(workInProgress.mode&2)&&null!==newProps&&(current=workInProgress.child,null!==current&&(workInProgress.treeBaseDuration-=
current.treeBaseDuration));return null}null!==hydrationErrors&&(queueRecoverableErrors(hydrationErrors),hydrationErrors=null);if(0!==(workInProgress.flags&128))return workInProgress.lanes=renderLanes,0!==(workInProgress.mode&2)&&transferActualDuration(workInProgress),workInProgress;newProps=null!==newProps;renderLanes=!1;null===current?popHydrationState(workInProgress):renderLanes=null!==current.memoizedState;newProps&&!renderLanes&&(workInProgress.child.flags|=8192,0!==(workInProgress.mode&1)&&(null===
current||0!==(suspenseStackCursor.current&InvisibleParentSuspenseContext)?workInProgressRootExitStatus===RootInProgress&&(workInProgressRootExitStatus=RootSuspended):renderDidSuspendDelayIfPossible()));null!==workInProgress.updateQueue&&(workInProgress.flags|=4);bubbleProperties(workInProgress);0!==(workInProgress.mode&2)&&newProps&&(current=workInProgress.child,null!==current&&(workInProgress.treeBaseDuration-=current.treeBaseDuration));return null;case 4:return popHostContainer(workInProgress),
updateHostContainer(current,workInProgress),null===current&&preparePortalMount(workInProgress.stateNode.containerInfo),bubbleProperties(workInProgress),null;case 10:return popProvider(workInProgress.type._context,workInProgress),bubbleProperties(workInProgress),null;case 17:return isContextProvider(workInProgress.type)&&popContext(workInProgress),bubbleProperties(workInProgress),null;case 19:pop(suspenseStackCursor,workInProgress);type=workInProgress.memoizedState;if(null===type)return bubbleProperties(workInProgress),
null;newProps=0!==(workInProgress.flags&128);instance=type.rendering;if(null===instance)if(newProps)cutOffTailIfNeeded(type,!1);else{if(workInProgressRootExitStatus!==RootInProgress||null!==current&&0!==(current.flags&128))for(current=workInProgress.child;null!==current;){instance=findFirstSuspended(current);if(null!==instance){workInProgress.flags|=128;cutOffTailIfNeeded(type,!1);current=instance.updateQueue;null!==current&&(workInProgress.updateQueue=current,workInProgress.flags|=4);workInProgress.subtreeFlags=
0;current=renderLanes;for(newProps=workInProgress.child;null!==newProps;)renderLanes=newProps,instance=current,renderLanes.flags&=14680066,type=renderLanes.alternate,null===type?(renderLanes.childLanes=0,renderLanes.lanes=instance,renderLanes.child=null,renderLanes.subtreeFlags=0,renderLanes.memoizedProps=null,renderLanes.memoizedState=null,renderLanes.updateQueue=null,renderLanes.dependencies=null,renderLanes.stateNode=null,renderLanes.selfBaseDuration=0,renderLanes.treeBaseDuration=0):(renderLanes.childLanes=
type.childLanes,renderLanes.lanes=type.lanes,renderLanes.child=type.child,renderLanes.subtreeFlags=0,renderLanes.deletions=null,renderLanes.memoizedProps=type.memoizedProps,renderLanes.memoizedState=type.memoizedState,renderLanes.updateQueue=type.updateQueue,renderLanes.type=type.type,instance=type.dependencies,renderLanes.dependencies=null===instance?null:{lanes:instance.lanes,firstContext:instance.firstContext},renderLanes.selfBaseDuration=type.selfBaseDuration,renderLanes.treeBaseDuration=type.treeBaseDuration),
newProps=newProps.sibling;push(suspenseStackCursor,suspenseStackCursor.current&SubtreeSuspenseContextMask|ForceSuspenseFallback,workInProgress);return workInProgress.child}current=current.sibling}null!==type.tail&&now$1()>workInProgressRootRenderTargetTime&&(workInProgress.flags|=128,newProps=!0,cutOffTailIfNeeded(type,!1),workInProgress.lanes=4194304)}else{if(!newProps)if(current=findFirstSuspended(instance),null!==current){if(workInProgress.flags|=128,newProps=!0,current=current.updateQueue,null!==
current&&(workInProgress.updateQueue=current,workInProgress.flags|=4),cutOffTailIfNeeded(type,!0),null===type.tail&&"hidden"===type.tailMode&&!instance.alternate&&!isHydrating)return bubbleProperties(workInProgress),null}else 2*now$1()-type.renderingStartTime>workInProgressRootRenderTargetTime&&1073741824!==renderLanes&&(workInProgress.flags|=128,newProps=!0,cutOffTailIfNeeded(type,!1),workInProgress.lanes=4194304);type.isBackwards?(instance.sibling=workInProgress.child,workInProgress.child=instance):
(current=type.last,null!==current?current.sibling=instance:workInProgress.child=instance,type.last=instance)}if(null!==type.tail)return current=type.tail,type.rendering=current,type.tail=current.sibling,type.renderingStartTime=now$1(),current.sibling=null,renderLanes=suspenseStackCursor.current,renderLanes=newProps?renderLanes&SubtreeSuspenseContextMask|ForceSuspenseFallback:renderLanes&SubtreeSuspenseContextMask,push(suspenseStackCursor,renderLanes,workInProgress),current;bubbleProperties(workInProgress);
return null;case 22:case 23:return popRenderLanes(workInProgress),newProps=null!==workInProgress.memoizedState,null!==current&&null!==current.memoizedState!==newProps&&(workInProgress.flags|=8192),newProps&&0!==(workInProgress.mode&1)?0!==(subtreeRenderLanes&1073741824)&&(bubbleProperties(workInProgress),supportsMutation&&workInProgress.subtreeFlags&6&&(workInProgress.flags|=8192)):bubbleProperties(workInProgress),null;case 24:return null;case 25:return null}throw Error("Unknown unit of work tag ("+
workInProgress.tag+"). This error is likely caused by a bug in React. Please file an issue.");}function reconcileChildren(current,workInProgress,nextChildren,renderLanes){workInProgress.child=null===current?mountChildFibers(workInProgress,null,nextChildren,renderLanes):reconcileChildFibers$jscomp$0(workInProgress,current.child,nextChildren,renderLanes)}function updateForwardRef(current,workInProgress,Component,nextProps,renderLanes){if(workInProgress.type!==workInProgress.elementType){var innerPropTypes=
Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}Component=Component.render;innerPropTypes=workInProgress.ref;prepareToReadContext(workInProgress,renderLanes);markComponentRenderStarted(workInProgress);ReactCurrentOwner$1.current=workInProgress;isRendering=!0;var nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,innerPropTypes,renderLanes);var hasId=checkDidRenderIdHook();if(workInProgress.mode&8){setIsStrictModeForDevtools(!0);
try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,innerPropTypes,renderLanes),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}isRendering=!1;markComponentRenderStopped();if(null!==current&&!didReceiveUpdate)return bailoutHooks(current,workInProgress,renderLanes),bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);isHydrating&&hasId&&pushMaterializedTreeId(workInProgress);workInProgress.flags|=1;reconcileChildren(current,workInProgress,nextChildren,
renderLanes);return workInProgress.child}function updateMemoComponent(current,workInProgress,Component,nextProps,renderLanes){if(null===current){var type=Component.type;if("function"===typeof type&&!shouldConstruct$1(type)&&void 0===type.defaultProps&&null===Component.compare&&void 0===Component.defaultProps)return Component=resolveFunctionForHotReloading(type),workInProgress.tag=15,workInProgress.type=Component,validateFunctionComponentInDev(workInProgress,type),updateSimpleMemoComponent(current,
workInProgress,Component,nextProps,renderLanes);(current=type.propTypes)&&checkPropTypes(current,nextProps,"prop",getComponentNameFromType(type));nextProps=createFiberFromTypeAndProps(Component.type,null,nextProps,workInProgress,workInProgress.mode,renderLanes);nextProps.ref=workInProgress.ref;nextProps.return=workInProgress;return workInProgress.child=nextProps}type=Component.type;var _innerPropTypes=type.propTypes;_innerPropTypes&&checkPropTypes(_innerPropTypes,nextProps,"prop",getComponentNameFromType(type));
type=current.child;if(0===(current.lanes&renderLanes)&&(_innerPropTypes=type.memoizedProps,Component=Component.compare,Component=null!==Component?Component:shallowEqual,Component(_innerPropTypes,nextProps)&&current.ref===workInProgress.ref))return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);workInProgress.flags|=1;nextProps=createWorkInProgress(type,nextProps);nextProps.ref=workInProgress.ref;nextProps.return=workInProgress;return workInProgress.child=nextProps}function updateSimpleMemoComponent(current,
workInProgress,Component,nextProps,renderLanes){if(workInProgress.type!==workInProgress.elementType){var outerMemoType=workInProgress.elementType;if(outerMemoType.$$typeof===REACT_LAZY_TYPE){var lazyComponent=outerMemoType,payload=lazyComponent._payload;lazyComponent=lazyComponent._init;try{outerMemoType=lazyComponent(payload)}catch(x){outerMemoType=null}(payload=outerMemoType&&outerMemoType.propTypes)&&checkPropTypes(payload,nextProps,"prop",getComponentNameFromType(outerMemoType))}}if(null!==current&&
shallowEqual(current.memoizedProps,nextProps)&&current.ref===workInProgress.ref&&workInProgress.type===current.type)if(didReceiveUpdate=!1,0!==(current.lanes&renderLanes))0!==(current.flags&131072)&&(didReceiveUpdate=!0);else return workInProgress.lanes=current.lanes,bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);return updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes)}function updateOffscreenComponent(current,workInProgress,renderLanes){var nextProps=
workInProgress.pendingProps,nextChildren=nextProps.children,prevState=null!==current?current.memoizedState:null;if("hidden"===nextProps.mode)if(0===(workInProgress.mode&1))workInProgress.memoizedState={baseLanes:0,cachePool:null},pushRenderLanes(workInProgress,renderLanes);else if(0!==(renderLanes&1073741824))workInProgress.memoizedState={baseLanes:0,cachePool:null},pushRenderLanes(workInProgress,null!==prevState?prevState.baseLanes:renderLanes);else return current=null!==prevState?prevState.baseLanes|
renderLanes:renderLanes,workInProgress.lanes=workInProgress.childLanes=1073741824,workInProgress.memoizedState={baseLanes:current,cachePool:null},workInProgress.updateQueue=null,pushRenderLanes(workInProgress,current),null;else null!==prevState?(nextProps=prevState.baseLanes|renderLanes,workInProgress.memoizedState=null):nextProps=renderLanes,pushRenderLanes(workInProgress,nextProps);reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child}function markRef$1(current,
workInProgress){var ref=workInProgress.ref;if(null===current&&null!==ref||null!==current&&current.ref!==ref)workInProgress.flags|=512,workInProgress.flags|=2097152}function updateFunctionComponent(current,workInProgress,Component,nextProps,renderLanes){if(workInProgress.type!==workInProgress.elementType){var innerPropTypes=Component.propTypes;innerPropTypes&&checkPropTypes(innerPropTypes,nextProps,"prop",getComponentNameFromType(Component))}innerPropTypes=isContextProvider(Component)?previousContext:
contextStackCursor.current;innerPropTypes=getMaskedContext(workInProgress,innerPropTypes);prepareToReadContext(workInProgress,renderLanes);markComponentRenderStarted(workInProgress);ReactCurrentOwner$1.current=workInProgress;isRendering=!0;var nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,innerPropTypes,renderLanes);var hasId=checkDidRenderIdHook();if(workInProgress.mode&8){setIsStrictModeForDevtools(!0);try{nextChildren=renderWithHooks(current,workInProgress,Component,nextProps,
innerPropTypes,renderLanes),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}isRendering=!1;markComponentRenderStopped();if(null!==current&&!didReceiveUpdate)return bailoutHooks(current,workInProgress,renderLanes),bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);isHydrating&&hasId&&pushMaterializedTreeId(workInProgress);workInProgress.flags|=1;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child}function updateClassComponent(current,
workInProgress,Component,nextProps,renderLanes){switch(shouldErrorImpl(workInProgress)){case !1:var _instance=workInProgress.stateNode,state=(new workInProgress.type(workInProgress.memoizedProps,_instance.context)).state;_instance.updater.enqueueSetState(_instance,state,null);break;case !0:workInProgress.flags|=128,workInProgress.flags|=65536,_instance=Error("Simulated error coming from DevTools"),state=renderLanes&-renderLanes,workInProgress.lanes|=state,_instance=createClassErrorUpdate(workInProgress,
createCapturedValue(_instance,workInProgress),state),enqueueCapturedUpdate(workInProgress,_instance)}workInProgress.type!==workInProgress.elementType&&(_instance=Component.propTypes)&&checkPropTypes(_instance,nextProps,"prop",getComponentNameFromType(Component));isContextProvider(Component)?(_instance=!0,pushContextProvider(workInProgress)):_instance=!1;prepareToReadContext(workInProgress,renderLanes);if(null===workInProgress.stateNode)null!==current&&(current.alternate=null,workInProgress.alternate=
null,workInProgress.flags|=2),constructClassInstance(workInProgress,Component,nextProps),mountClassInstance(workInProgress,Component,nextProps,renderLanes),state=!0;else if(null===current){state=workInProgress.stateNode;var oldProps=workInProgress.memoizedProps;state.props=oldProps;var oldContext=state.context,contextType=Component.contextType;"object"===typeof contextType&&null!==contextType?contextType=readContext(contextType):(contextType=isContextProvider(Component)?previousContext:contextStackCursor.current,
contextType=getMaskedContext(workInProgress,contextType));var getDerivedStateFromProps=Component.getDerivedStateFromProps,hasNewLifecycles="function"===typeof getDerivedStateFromProps||"function"===typeof state.getSnapshotBeforeUpdate;hasNewLifecycles||"function"!==typeof state.UNSAFE_componentWillReceiveProps&&"function"!==typeof state.componentWillReceiveProps||(oldProps!==nextProps||oldContext!==contextType)&&callComponentWillReceiveProps(workInProgress,state,nextProps,contextType);hasForceUpdate=
!1;var oldState=workInProgress.memoizedState;state.state=oldState;processUpdateQueue(workInProgress,nextProps,state,renderLanes);oldContext=workInProgress.memoizedState;oldProps!==nextProps||oldState!==oldContext||didPerformWorkStackCursor.current||hasForceUpdate?("function"===typeof getDerivedStateFromProps&&(applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps,nextProps),oldContext=workInProgress.memoizedState),(oldProps=hasForceUpdate||checkShouldComponentUpdate(workInProgress,
Component,oldProps,nextProps,oldState,oldContext,contextType))?(hasNewLifecycles||"function"!==typeof state.UNSAFE_componentWillMount&&"function"!==typeof state.componentWillMount||("function"===typeof state.componentWillMount&&state.componentWillMount(),"function"===typeof state.UNSAFE_componentWillMount&&state.UNSAFE_componentWillMount()),"function"===typeof state.componentDidMount&&(hasNewLifecycles=4194308,0!==(workInProgress.mode&16)&&(hasNewLifecycles|=16777216),workInProgress.flags|=hasNewLifecycles)):
("function"===typeof state.componentDidMount&&(hasNewLifecycles=4194308,0!==(workInProgress.mode&16)&&(hasNewLifecycles|=16777216),workInProgress.flags|=hasNewLifecycles),workInProgress.memoizedProps=nextProps,workInProgress.memoizedState=oldContext),state.props=nextProps,state.state=oldContext,state.context=contextType,state=oldProps):("function"===typeof state.componentDidMount&&(state=4194308,0!==(workInProgress.mode&16)&&(state|=16777216),workInProgress.flags|=state),state=!1)}else{state=workInProgress.stateNode;
cloneUpdateQueue(current,workInProgress);contextType=workInProgress.memoizedProps;oldProps=workInProgress.type===workInProgress.elementType?contextType:resolveDefaultProps(workInProgress.type,contextType);state.props=oldProps;oldContext=workInProgress.pendingProps;oldState=state.context;hasNewLifecycles=Component.contextType;"object"===typeof hasNewLifecycles&&null!==hasNewLifecycles?hasNewLifecycles=readContext(hasNewLifecycles):(hasNewLifecycles=isContextProvider(Component)?previousContext:contextStackCursor.current,
hasNewLifecycles=getMaskedContext(workInProgress,hasNewLifecycles));var getDerivedStateFromProps$jscomp$0=Component.getDerivedStateFromProps;(getDerivedStateFromProps="function"===typeof getDerivedStateFromProps$jscomp$0||"function"===typeof state.getSnapshotBeforeUpdate)||"function"!==typeof state.UNSAFE_componentWillReceiveProps&&"function"!==typeof state.componentWillReceiveProps||(contextType!==oldContext||oldState!==hasNewLifecycles)&&callComponentWillReceiveProps(workInProgress,state,nextProps,
hasNewLifecycles);hasForceUpdate=!1;oldState=workInProgress.memoizedState;state.state=oldState;processUpdateQueue(workInProgress,nextProps,state,renderLanes);var newState=workInProgress.memoizedState;contextType!==oldContext||oldState!==newState||didPerformWorkStackCursor.current||hasForceUpdate?("function"===typeof getDerivedStateFromProps$jscomp$0&&(applyDerivedStateFromProps(workInProgress,Component,getDerivedStateFromProps$jscomp$0,nextProps),newState=workInProgress.memoizedState),(oldProps=hasForceUpdate||
checkShouldComponentUpdate(workInProgress,Component,oldProps,nextProps,oldState,newState,hasNewLifecycles)||!1)?(getDerivedStateFromProps||"function"!==typeof state.UNSAFE_componentWillUpdate&&"function"!==typeof state.componentWillUpdate||("function"===typeof state.componentWillUpdate&&state.componentWillUpdate(nextProps,newState,hasNewLifecycles),"function"===typeof state.UNSAFE_componentWillUpdate&&state.UNSAFE_componentWillUpdate(nextProps,newState,hasNewLifecycles)),"function"===typeof state.componentDidUpdate&&
(workInProgress.flags|=4),"function"===typeof state.getSnapshotBeforeUpdate&&(workInProgress.flags|=1024)):("function"!==typeof state.componentDidUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=4),"function"!==typeof state.getSnapshotBeforeUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=1024),workInProgress.memoizedProps=nextProps,workInProgress.memoizedState=newState),state.props=nextProps,
state.state=newState,state.context=hasNewLifecycles,state=oldProps):("function"!==typeof state.componentDidUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=4),"function"!==typeof state.getSnapshotBeforeUpdate||contextType===current.memoizedProps&&oldState===current.memoizedState||(workInProgress.flags|=1024),state=!1)}current=finishClassComponent(current,workInProgress,Component,state,_instance,renderLanes);Component=workInProgress.stateNode;state&&
Component.props!==nextProps&&(didWarnAboutReassigningProps||error$jscomp$0("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.",getComponentNameFromFiber(workInProgress)||"a component"),didWarnAboutReassigningProps=!0);return current}function finishClassComponent(current,workInProgress,Component,shouldUpdate,hasContext,renderLanes){markRef$1(current,workInProgress);var didCaptureError=0!==(workInProgress.flags&128);if(!shouldUpdate&&
!didCaptureError)return hasContext&&invalidateContextProvider(workInProgress,Component,!1),bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);shouldUpdate=workInProgress.stateNode;ReactCurrentOwner$1.current=workInProgress;if(didCaptureError&&"function"!==typeof Component.getDerivedStateFromError){var nextChildren=null;profilerStartTime=-1}else{markComponentRenderStarted(workInProgress);isRendering=!0;nextChildren=shouldUpdate.render();if(workInProgress.mode&8){setIsStrictModeForDevtools(!0);
try{shouldUpdate.render()}finally{setIsStrictModeForDevtools(!1)}}isRendering=!1;markComponentRenderStopped()}workInProgress.flags|=1;null!==current&&didCaptureError?(didCaptureError=nextChildren,workInProgress.child=reconcileChildFibers$jscomp$0(workInProgress,current.child,null,renderLanes),workInProgress.child=reconcileChildFibers$jscomp$0(workInProgress,null,didCaptureError,renderLanes)):reconcileChildren(current,workInProgress,nextChildren,renderLanes);workInProgress.memoizedState=shouldUpdate.state;
hasContext&&invalidateContextProvider(workInProgress,Component,!0);return workInProgress.child}function pushHostRootContext(workInProgress){var root=workInProgress.stateNode;root.pendingContext?pushTopLevelContextObject(workInProgress,root.pendingContext,root.pendingContext!==root.context):root.context&&pushTopLevelContextObject(workInProgress,root.context,!1);pushHostContainer(workInProgress,root.containerInfo)}function mountHostRootWithoutHydrating(current,workInProgress,nextChildren,renderLanes,
recoverableError){resetHydrationState();queueHydrationError(recoverableError);workInProgress.flags|=256;reconcileChildren(current,workInProgress,nextChildren,renderLanes);return workInProgress.child}function validateFunctionComponentInDev(workInProgress,Component){Component&&Component.childContextTypes&&error$jscomp$0("%s(...): childContextTypes cannot be defined on a function component.",Component.displayName||Component.name||"Component");if(null!==workInProgress.ref){var info="";if(null===current$jscomp$1)var ownerName=
null;else ownerName=current$jscomp$1._debugOwner,ownerName=null!==ownerName&&"undefined"!==typeof ownerName?getComponentNameFromFiber(ownerName):null;ownerName&&(info+="\n\nCheck the render method of `"+ownerName+"`.");ownerName=ownerName||"";(workInProgress=workInProgress._debugSource)&&(ownerName=workInProgress.fileName+":"+workInProgress.lineNumber);didWarnAboutFunctionRefs[ownerName]||(didWarnAboutFunctionRefs[ownerName]=!0,error$jscomp$0("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s",
info))}"function"===typeof Component.getDerivedStateFromProps&&(info=getComponentNameFromType(Component)||"Unknown",didWarnAboutGetDerivedStateOnFunctionComponent[info]||(error$jscomp$0("%s: Function components do not support getDerivedStateFromProps.",info),didWarnAboutGetDerivedStateOnFunctionComponent[info]=!0));"object"===typeof Component.contextType&&null!==Component.contextType&&(Component=getComponentNameFromType(Component)||"Unknown",didWarnAboutContextTypeOnFunctionComponent[Component]||
(error$jscomp$0("%s: Function components do not support contextType.",Component),didWarnAboutContextTypeOnFunctionComponent[Component]=!0))}function mountSuspenseOffscreenState(renderLanes){return{baseLanes:renderLanes,cachePool:null}}function updateSuspenseComponent(current,workInProgress,renderLanes){var nextProps=workInProgress.pendingProps;shouldSuspendImpl(workInProgress)&&(workInProgress.flags|=128);var suspenseContext=suspenseStackCursor.current,showFallback=!1,didSuspend=0!==(workInProgress.flags&
128),JSCompiler_temp;(JSCompiler_temp=didSuspend)||(JSCompiler_temp=null!==current&&null===current.memoizedState?!1:0!==(suspenseContext&ForceSuspenseFallback));if(JSCompiler_temp)showFallback=!0,workInProgress.flags&=-129;else if(null===current||null!==current.memoizedState)suspenseContext|=InvisibleParentSuspenseContext;suspenseContext&=SubtreeSuspenseContextMask;push(suspenseStackCursor,suspenseContext,workInProgress);if(null===current){tryToClaimNextHydratableInstance(workInProgress);current=
workInProgress.memoizedState;if(null!==current&&(current=current.dehydrated,null!==current))return 0===(workInProgress.mode&1)?(error$jscomp$0("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, \x3cApp /\x3e).render(element) or remove the Suspense components from the server rendered components."),workInProgress.lanes=1):isSuspenseInstanceFallback(current)?workInProgress.lanes=8:workInProgress.lanes=1073741824,null;suspenseContext=
nextProps.children;current=nextProps.fallback;return showFallback?(nextProps=workInProgress.mode,showFallback=workInProgress.child,suspenseContext={mode:"hidden",children:suspenseContext},0===(nextProps&1)&&null!==showFallback?(showFallback.childLanes=0,showFallback.pendingProps=suspenseContext,workInProgress.mode&2&&(showFallback.actualDuration=0,showFallback.actualStartTime=-1,showFallback.selfBaseDuration=0,showFallback.treeBaseDuration=0)):showFallback=createFiberFromOffscreen(suspenseContext,
nextProps,0,null),current=createFiberFromFragment(current,nextProps,renderLanes,null),showFallback.return=workInProgress,current.return=workInProgress,showFallback.sibling=current,workInProgress.child=showFallback,workInProgress.child.memoizedState=mountSuspenseOffscreenState(renderLanes),workInProgress.memoizedState=SUSPENDED_MARKER,current):mountSuspensePrimaryChildren(workInProgress,suspenseContext)}suspenseContext=current.memoizedState;if(null!==suspenseContext){JSCompiler_temp=suspenseContext.dehydrated;
if(null!==JSCompiler_temp){if(didSuspend){if(workInProgress.flags&256)return workInProgress.flags&=-257,retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));if(null!==workInProgress.memoizedState)return workInProgress.child=current.child,workInProgress.flags|=128,null;showFallback=nextProps.fallback;suspenseContext=workInProgress.mode;nextProps=createFiberFromOffscreen({mode:"visible",
children:nextProps.children},suspenseContext,0,null);showFallback=createFiberFromFragment(showFallback,suspenseContext,renderLanes,null);showFallback.flags|=2;nextProps.return=workInProgress;showFallback.return=workInProgress;nextProps.sibling=showFallback;workInProgress.child=nextProps;0!==(workInProgress.mode&1)&&reconcileChildFibers$jscomp$0(workInProgress,current.child,null,renderLanes);workInProgress.child.memoizedState=mountSuspenseOffscreenState(renderLanes);workInProgress.memoizedState=SUSPENDED_MARKER;
return showFallback}isHydrating&&error$jscomp$0("We should not be hydrating here. This is a bug in React. Please file a bug.");if(0===(workInProgress.mode&1))workInProgress=retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,null);else if(isSuspenseInstanceFallback(JSCompiler_temp))workInProgress=retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering."));
else if(nextProps=0!==(renderLanes&current.childLanes),didReceiveUpdate||nextProps){nextProps=workInProgressRoot;if(null!==nextProps){switch(renderLanes&-renderLanes){case 4:showFallback=2;break;case 16:showFallback=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:showFallback=32;break;case 536870912:showFallback=
268435456;break;default:showFallback=0}nextProps=0!==(showFallback&(nextProps.suspendedLanes|renderLanes))?0:showFallback;0!==nextProps&&nextProps!==suspenseContext.retryLane&&(suspenseContext.retryLane=nextProps,scheduleUpdateOnFiber(current,nextProps,-1))}renderDidSuspendDelayIfPossible();workInProgress=retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."))}else isSuspenseInstancePending(JSCompiler_temp)?
(workInProgress.flags|=128,workInProgress.child=current.child,workInProgress=retryDehydratedSuspenseBoundary.bind(null,current),registerSuspenseInstanceRetry(JSCompiler_temp,workInProgress),workInProgress=null):(renderLanes=suspenseContext.treeContext,supportsHydration&&(nextHydratableInstance=getFirstHydratableChildWithinSuspenseInstance(JSCompiler_temp),hydrationParentFiber=workInProgress,isHydrating=!0,hydrationErrors=null,didSuspend$jscomp$0=!1,null!==renderLanes&&(warnIfNotHydrating(),idStack[idStackIndex++]=
treeContextId,idStack[idStackIndex++]=treeContextOverflow,idStack[idStackIndex++]=treeContextProvider,treeContextId=renderLanes.id,treeContextOverflow=renderLanes.overflow,treeContextProvider=workInProgress)),workInProgress=mountSuspensePrimaryChildren(workInProgress,workInProgress.pendingProps.children),workInProgress.flags|=4096);return workInProgress}if(showFallback)return nextProps=updateSuspenseFallbackChildren(current,workInProgress,nextProps.children,nextProps.fallback,renderLanes),showFallback=
workInProgress.child,suspenseContext=current.child.memoizedState,showFallback.memoizedState=null===suspenseContext?mountSuspenseOffscreenState(renderLanes):{baseLanes:suspenseContext.baseLanes|renderLanes,cachePool:null},showFallback.childLanes=current.childLanes&~renderLanes,workInProgress.memoizedState=SUSPENDED_MARKER,nextProps;renderLanes=updateSuspensePrimaryChildren(current,workInProgress,nextProps.children,renderLanes);workInProgress.memoizedState=null;return renderLanes}if(showFallback)return nextProps=
updateSuspenseFallbackChildren(current,workInProgress,nextProps.children,nextProps.fallback,renderLanes),showFallback=workInProgress.child,suspenseContext=current.child.memoizedState,showFallback.memoizedState=null===suspenseContext?mountSuspenseOffscreenState(renderLanes):{baseLanes:suspenseContext.baseLanes|renderLanes,cachePool:null},showFallback.childLanes=current.childLanes&~renderLanes,workInProgress.memoizedState=SUSPENDED_MARKER,nextProps;renderLanes=updateSuspensePrimaryChildren(current,
workInProgress,nextProps.children,renderLanes);workInProgress.memoizedState=null;return renderLanes}function mountSuspensePrimaryChildren(workInProgress,primaryChildren,renderLanes){primaryChildren=createFiberFromOffscreen({mode:"visible",children:primaryChildren},workInProgress.mode,0,null);primaryChildren.return=workInProgress;return workInProgress.child=primaryChildren}function updateSuspensePrimaryChildren(current,workInProgress,primaryChildren,renderLanes){var currentPrimaryChildFragment=current.child;
current=currentPrimaryChildFragment.sibling;primaryChildren=createWorkInProgress(currentPrimaryChildFragment,{mode:"visible",children:primaryChildren});0===(workInProgress.mode&1)&&(primaryChildren.lanes=renderLanes);primaryChildren.return=workInProgress;primaryChildren.sibling=null;null!==current&&(renderLanes=workInProgress.deletions,null===renderLanes?(workInProgress.deletions=[current],workInProgress.flags|=16):renderLanes.push(current));return workInProgress.child=primaryChildren}function updateSuspenseFallbackChildren(current,
workInProgress,primaryChildren,fallbackChildren,renderLanes){var mode=workInProgress.mode;current=current.child;var currentFallbackChildFragment=current.sibling,primaryChildProps={mode:"hidden",children:primaryChildren};0===(mode&1)&&workInProgress.child!==current?(primaryChildren=workInProgress.child,primaryChildren.childLanes=0,primaryChildren.pendingProps=primaryChildProps,workInProgress.mode&2&&(primaryChildren.actualDuration=0,primaryChildren.actualStartTime=-1,primaryChildren.selfBaseDuration=
current.selfBaseDuration,primaryChildren.treeBaseDuration=current.treeBaseDuration),workInProgress.deletions=null):(primaryChildren=createWorkInProgress(current,primaryChildProps),primaryChildren.subtreeFlags=current.subtreeFlags&14680064);null!==currentFallbackChildFragment?fallbackChildren=createWorkInProgress(currentFallbackChildFragment,fallbackChildren):(fallbackChildren=createFiberFromFragment(fallbackChildren,mode,renderLanes,null),fallbackChildren.flags|=2);fallbackChildren.return=workInProgress;
primaryChildren.return=workInProgress;primaryChildren.sibling=fallbackChildren;workInProgress.child=primaryChildren;return fallbackChildren}function retrySuspenseComponentWithoutHydrating(current,workInProgress,renderLanes,recoverableError){null!==recoverableError&&queueHydrationError(recoverableError);reconcileChildFibers$jscomp$0(workInProgress,current.child,null,renderLanes);current=mountSuspensePrimaryChildren(workInProgress,workInProgress.pendingProps.children);current.flags|=2;workInProgress.memoizedState=
null;return current}function scheduleSuspenseWorkOnFiber(fiber,renderLanes,propagationRoot){fiber.lanes|=renderLanes;var alternate=fiber.alternate;null!==alternate&&(alternate.lanes|=renderLanes);scheduleContextWorkOnParentPath(fiber.return,renderLanes,propagationRoot)}function validateSuspenseListNestedChild(childSlot,index){var isAnArray=isArrayImpl(childSlot);childSlot=!isAnArray&&"function"===typeof getIteratorFn(childSlot);return isAnArray||childSlot?(isAnArray=isAnArray?"array":"iterable",error$jscomp$0("A nested %s was passed to row #%s in \x3cSuspenseList /\x3e. Wrap it in an additional SuspenseList to configure its revealOrder: \x3cSuspenseList revealOrder\x3d...\x3e ... \x3cSuspenseList revealOrder\x3d...\x3e{%s}\x3c/SuspenseList\x3e ... \x3c/SuspenseList\x3e",
isAnArray,index,isAnArray),!1):!0}function initSuspenseListRenderState(workInProgress,isBackwards,tail,lastContentRow,tailMode){var renderState=workInProgress.memoizedState;null===renderState?workInProgress.memoizedState={isBackwards,rendering:null,renderingStartTime:0,last:lastContentRow,tail,tailMode}:(renderState.isBackwards=isBackwards,renderState.rendering=null,renderState.renderingStartTime=0,renderState.last=lastContentRow,renderState.tail=tail,renderState.tailMode=tailMode)}function updateSuspenseListComponent(current,
workInProgress,renderLanes){var nextProps=workInProgress.pendingProps,revealOrder=nextProps.revealOrder,tailMode=nextProps.tail;nextProps=nextProps.children;if(void 0!==revealOrder&&"forwards"!==revealOrder&&"backwards"!==revealOrder&&"together"!==revealOrder&&!didWarnAboutRevealOrder[revealOrder])if(didWarnAboutRevealOrder[revealOrder]=!0,"string"===typeof revealOrder)switch(revealOrder.toLowerCase()){case "together":case "forwards":case "backwards":error$jscomp$0('"%s" is not a valid value for revealOrder on \x3cSuspenseList /\x3e. Use lowercase "%s" instead.',
revealOrder,revealOrder.toLowerCase());break;case "forward":case "backward":error$jscomp$0('"%s" is not a valid value for revealOrder on \x3cSuspenseList /\x3e. React uses the -s suffix in the spelling. Use "%ss" instead.',revealOrder,revealOrder.toLowerCase());break;default:error$jscomp$0('"%s" is not a supported revealOrder on \x3cSuspenseList /\x3e. Did you mean "together", "forwards" or "backwards"?',revealOrder)}else error$jscomp$0('%s is not a supported value for revealOrder on \x3cSuspenseList /\x3e. Did you mean "together", "forwards" or "backwards"?',
revealOrder);void 0===tailMode||didWarnAboutTailOptions[tailMode]||("collapsed"!==tailMode&&"hidden"!==tailMode?(didWarnAboutTailOptions[tailMode]=!0,error$jscomp$0('"%s" is not a supported value for tail on \x3cSuspenseList /\x3e. Did you mean "collapsed" or "hidden"?',tailMode)):"forwards"!==revealOrder&&"backwards"!==revealOrder&&(didWarnAboutTailOptions[tailMode]=!0,error$jscomp$0('\x3cSuspenseList tail\x3d"%s" /\x3e is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder\x3d"forwards"?',
tailMode)));a:if(("forwards"===revealOrder||"backwards"===revealOrder)&&void 0!==nextProps&&null!==nextProps&&!1!==nextProps)if(isArrayImpl(nextProps))for(var i=0;i<nextProps.length;i++){if(!validateSuspenseListNestedChild(nextProps[i],i))break a}else if(i=getIteratorFn(nextProps),"function"===typeof i){if(i=i.call(nextProps))for(var step=i.next(),_i=0;!step.done;step=i.next()){if(!validateSuspenseListNestedChild(step.value,_i))break a;_i++}}else error$jscomp$0('A single row was passed to a \x3cSuspenseList revealOrder\x3d"%s" /\x3e. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?',
revealOrder);reconcileChildren(current,workInProgress,nextProps,renderLanes);nextProps=suspenseStackCursor.current;if(0!==(nextProps&ForceSuspenseFallback))nextProps=nextProps&SubtreeSuspenseContextMask|ForceSuspenseFallback,workInProgress.flags|=128;else{if(null!==current&&0!==(current.flags&128))a:for(current=workInProgress.child;null!==current;){if(13===current.tag)null!==current.memoizedState&&scheduleSuspenseWorkOnFiber(current,renderLanes,workInProgress);else if(19===current.tag)scheduleSuspenseWorkOnFiber(current,
renderLanes,workInProgress);else if(null!==current.child){current.child.return=current;current=current.child;continue}if(current===workInProgress)break a;for(;null===current.sibling;){if(null===current.return||current.return===workInProgress)break a;current=current.return}current.sibling.return=current.return;current=current.sibling}nextProps&=SubtreeSuspenseContextMask}push(suspenseStackCursor,nextProps,workInProgress);if(0===(workInProgress.mode&1))workInProgress.memoizedState=null;else switch(revealOrder){case "forwards":renderLanes=
workInProgress.child;for(revealOrder=null;null!==renderLanes;)current=renderLanes.alternate,null!==current&&null===findFirstSuspended(current)&&(revealOrder=renderLanes),renderLanes=renderLanes.sibling;renderLanes=revealOrder;null===renderLanes?(revealOrder=workInProgress.child,workInProgress.child=null):(revealOrder=renderLanes.sibling,renderLanes.sibling=null);initSuspenseListRenderState(workInProgress,!1,revealOrder,renderLanes,tailMode);break;case "backwards":renderLanes=null;revealOrder=workInProgress.child;
for(workInProgress.child=null;null!==revealOrder;){current=revealOrder.alternate;if(null!==current&&null===findFirstSuspended(current)){workInProgress.child=revealOrder;break}current=revealOrder.sibling;revealOrder.sibling=renderLanes;renderLanes=revealOrder;revealOrder=current}initSuspenseListRenderState(workInProgress,!0,renderLanes,null,tailMode);break;case "together":initSuspenseListRenderState(workInProgress,!1,null,null,void 0);break;default:workInProgress.memoizedState=null}return workInProgress.child}
function bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes){null!==current&&(workInProgress.dependencies=current.dependencies);profilerStartTime=-1;workInProgressRootSkippedLanes|=workInProgress.lanes;if(0===(renderLanes&workInProgress.childLanes))return null;if(null!==current&&workInProgress.child!==current.child)throw Error("Resuming work not yet implemented.");if(null!==workInProgress.child){current=workInProgress.child;renderLanes=createWorkInProgress(current,current.pendingProps);
workInProgress.child=renderLanes;for(renderLanes.return=workInProgress;null!==current.sibling;)current=current.sibling,renderLanes=renderLanes.sibling=createWorkInProgress(current,current.pendingProps),renderLanes.return=workInProgress;renderLanes.sibling=null}return workInProgress.child}function attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes){switch(workInProgress.tag){case 3:pushHostRootContext(workInProgress);resetHydrationState();break;case 5:pushHostContext(workInProgress);
break;case 1:isContextProvider(workInProgress.type)&&pushContextProvider(workInProgress);break;case 4:pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo);break;case 10:pushProvider(workInProgress,workInProgress.type._context,workInProgress.memoizedProps.value);break;case 12:0!==(renderLanes&workInProgress.childLanes)&&(workInProgress.flags|=4);var stateNode=workInProgress.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;break;case 13:stateNode=workInProgress.memoizedState;
if(null!==stateNode){if(null!==stateNode.dehydrated)return push(suspenseStackCursor,suspenseStackCursor.current&SubtreeSuspenseContextMask,workInProgress),workInProgress.flags|=128,null;if(0!==(renderLanes&workInProgress.child.childLanes))return updateSuspenseComponent(current,workInProgress,renderLanes);push(suspenseStackCursor,suspenseStackCursor.current&SubtreeSuspenseContextMask,workInProgress);current=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);return null!==current?current.sibling:
null}push(suspenseStackCursor,suspenseStackCursor.current&SubtreeSuspenseContextMask,workInProgress);break;case 19:stateNode=0!==(renderLanes&workInProgress.childLanes);if(0!==(current.flags&128)){if(stateNode)return updateSuspenseListComponent(current,workInProgress,renderLanes);workInProgress.flags|=128}var renderState=workInProgress.memoizedState;null!==renderState&&(renderState.rendering=null,renderState.tail=null,renderState.lastEffect=null);push(suspenseStackCursor,suspenseStackCursor.current,
workInProgress);if(stateNode)break;else return null;case 22:case 23:return workInProgress.lanes=0,updateOffscreenComponent(current,workInProgress,renderLanes)}return bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes)}function beginWork(current,workInProgress,renderLanes){if(workInProgress._debugNeedsRemount&&null!==current){renderLanes=createFiberFromTypeAndProps(workInProgress.type,workInProgress.key,workInProgress.pendingProps,workInProgress._debugOwner||null,workInProgress.mode,workInProgress.lanes);
var returnFiber=workInProgress.return;if(null===returnFiber)throw Error("Cannot swap the root fiber.");current.alternate=null;workInProgress.alternate=null;renderLanes.index=workInProgress.index;renderLanes.sibling=workInProgress.sibling;renderLanes.return=workInProgress.return;renderLanes.ref=workInProgress.ref;if(workInProgress===returnFiber.child)returnFiber.child=renderLanes;else{var prevSibling=returnFiber.child;if(null===prevSibling)throw Error("Expected parent to have a child.");for(;prevSibling.sibling!==
workInProgress;)if(prevSibling=prevSibling.sibling,null===prevSibling)throw Error("Expected to find the previous sibling.");prevSibling.sibling=renderLanes}workInProgress=returnFiber.deletions;null===workInProgress?(returnFiber.deletions=[current],returnFiber.flags|=16):workInProgress.push(current);renderLanes.flags|=2;return renderLanes}if(null!==current)if(current.memoizedProps!==workInProgress.pendingProps||didPerformWorkStackCursor.current||workInProgress.type!==current.type)didReceiveUpdate=
!0;else{if(0===(current.lanes&renderLanes)&&0===(workInProgress.flags&128))return didReceiveUpdate=!1,attemptEarlyBailoutIfNoScheduledUpdate(current,workInProgress,renderLanes);didReceiveUpdate=0!==(current.flags&131072)?!0:!1}else{didReceiveUpdate=!1;if(returnFiber=isHydrating)warnIfNotHydrating(),returnFiber=0!==(workInProgress.flags&1048576);returnFiber&&(returnFiber=workInProgress.index,warnIfNotHydrating(),pushTreeId(workInProgress,treeForkCount,returnFiber))}workInProgress.lanes=0;switch(workInProgress.tag){case 2:returnFiber=
workInProgress.type;null!==current&&(current.alternate=null,workInProgress.alternate=null,workInProgress.flags|=2);current=workInProgress.pendingProps;var context=getMaskedContext(workInProgress,contextStackCursor.current);prepareToReadContext(workInProgress,renderLanes);markComponentRenderStarted(workInProgress);returnFiber.prototype&&"function"===typeof returnFiber.prototype.render&&(prevSibling=getComponentNameFromType(returnFiber)||"Unknown",didWarnAboutBadClass[prevSibling]||(error$jscomp$0("The \x3c%s /\x3e component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.",
prevSibling,prevSibling),didWarnAboutBadClass[prevSibling]=!0));workInProgress.mode&8&&ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress,null);isRendering=!0;ReactCurrentOwner$1.current=workInProgress;prevSibling=renderWithHooks(null,workInProgress,returnFiber,current,context,renderLanes);var hasId=checkDidRenderIdHook();isRendering=!1;markComponentRenderStopped();workInProgress.flags|=1;if("object"===typeof prevSibling&&null!==prevSibling&&"function"===typeof prevSibling.render&&
void 0===prevSibling.$$typeof){var _componentName=getComponentNameFromType(returnFiber)||"Unknown";didWarnAboutModulePatternComponent[_componentName]||(error$jscomp$0("The \x3c%s /\x3e component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype \x3d React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
_componentName,_componentName,_componentName),didWarnAboutModulePatternComponent[_componentName]=!0)}if("object"===typeof prevSibling&&null!==prevSibling&&"function"===typeof prevSibling.render&&void 0===prevSibling.$$typeof)context=getComponentNameFromType(returnFiber)||"Unknown",didWarnAboutModulePatternComponent[context]||(error$jscomp$0("The \x3c%s /\x3e component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype \x3d React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.",
context,context,context),didWarnAboutModulePatternComponent[context]=!0),workInProgress.tag=1,workInProgress.memoizedState=null,workInProgress.updateQueue=null,isContextProvider(returnFiber)?(context=!0,pushContextProvider(workInProgress)):context=!1,workInProgress.memoizedState=null!==prevSibling.state&&void 0!==prevSibling.state?prevSibling.state:null,initializeUpdateQueue(workInProgress),prevSibling.updater=classComponentUpdater,workInProgress.stateNode=prevSibling,prevSibling._reactInternals=
workInProgress,prevSibling._reactInternalInstance=fakeInternalInstance,mountClassInstance(workInProgress,returnFiber,current,renderLanes),workInProgress=finishClassComponent(null,workInProgress,returnFiber,!0,context,renderLanes);else{workInProgress.tag=0;if(workInProgress.mode&8){setIsStrictModeForDevtools(!0);try{prevSibling=renderWithHooks(null,workInProgress,returnFiber,current,context,renderLanes),hasId=checkDidRenderIdHook()}finally{setIsStrictModeForDevtools(!1)}}isHydrating&&hasId&&pushMaterializedTreeId(workInProgress);
reconcileChildren(null,workInProgress,prevSibling,renderLanes);validateFunctionComponentInDev(workInProgress,returnFiber);workInProgress=workInProgress.child}return workInProgress;case 16:a:{prevSibling=workInProgress.elementType;null!==current&&(current.alternate=null,workInProgress.alternate=null,workInProgress.flags|=2);returnFiber=workInProgress.pendingProps;current=prevSibling._init;current=current(prevSibling._payload);workInProgress.type=current;prevSibling=workInProgress.tag=resolveLazyComponentTag(current);
returnFiber=resolveDefaultProps(current,returnFiber);switch(prevSibling){case 0:validateFunctionComponentInDev(workInProgress,current);workInProgress.type=current=resolveFunctionForHotReloading(current);workInProgress=updateFunctionComponent(null,workInProgress,current,returnFiber,renderLanes);break a;case 1:workInProgress.type=current=resolveFunctionForHotReloading(current);workInProgress=updateClassComponent(null,workInProgress,current,returnFiber,renderLanes);break a;case 11:workInProgress.type=
current=resolveForwardRefForHotReloading(current);workInProgress=updateForwardRef(null,workInProgress,current,returnFiber,renderLanes);break a;case 14:workInProgress.type!==workInProgress.elementType&&(prevSibling=current.propTypes)&&checkPropTypes(prevSibling,returnFiber,"prop",getComponentNameFromType(current));workInProgress=updateMemoComponent(null,workInProgress,current,resolveDefaultProps(current.type,returnFiber),renderLanes);break a}workInProgress="";null!==current&&"object"===typeof current&&
current.$$typeof===REACT_LAZY_TYPE&&(workInProgress=" Did you wrap a component in React.lazy() more than once?");throw Error("Element type is invalid. Received a promise that resolves to: "+current+". Lazy element type must resolve to a class or function."+workInProgress);}return workInProgress;case 0:return returnFiber=workInProgress.type,prevSibling=workInProgress.pendingProps,prevSibling=workInProgress.elementType===returnFiber?prevSibling:resolveDefaultProps(returnFiber,prevSibling),updateFunctionComponent(current,
workInProgress,returnFiber,prevSibling,renderLanes);case 1:return returnFiber=workInProgress.type,prevSibling=workInProgress.pendingProps,prevSibling=workInProgress.elementType===returnFiber?prevSibling:resolveDefaultProps(returnFiber,prevSibling),updateClassComponent(current,workInProgress,returnFiber,prevSibling,renderLanes);case 3:a:{pushHostRootContext(workInProgress);if(null===current)throw Error("Should have a current fiber. This is a bug in React.");context=workInProgress.pendingProps;prevSibling=
workInProgress.memoizedState;returnFiber=prevSibling.element;cloneUpdateQueue(current,workInProgress);processUpdateQueue(workInProgress,context,null,renderLanes);hasId=workInProgress.memoizedState;context=hasId.element;if(supportsHydration&&prevSibling.isDehydrated)if(prevSibling={element:context,isDehydrated:!1,cache:hasId.cache,transitions:hasId.transitions},workInProgress.updateQueue.baseState=prevSibling,workInProgress.memoizedState=prevSibling,workInProgress.flags&256){workInProgress=mountHostRootWithoutHydrating(current,
workInProgress,context,renderLanes,Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."));break a}else if(context!==returnFiber){workInProgress=mountHostRootWithoutHydrating(current,workInProgress,context,renderLanes,Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."));break a}else for(supportsHydration&&(nextHydratableInstance=
getFirstHydratableChildWithinContainer(workInProgress.stateNode.containerInfo),hydrationParentFiber=workInProgress,isHydrating=!0,hydrationErrors=null,didSuspend$jscomp$0=!1),renderLanes=mountChildFibers(workInProgress,null,context,renderLanes),workInProgress.child=renderLanes;renderLanes;)renderLanes.flags=renderLanes.flags&-3|4096,renderLanes=renderLanes.sibling;else{resetHydrationState();if(context===returnFiber){workInProgress=bailoutOnAlreadyFinishedWork(current,workInProgress,renderLanes);break a}reconcileChildren(current,
workInProgress,context,renderLanes)}workInProgress=workInProgress.child}return workInProgress;case 5:return pushHostContext(workInProgress),null===current&&tryToClaimNextHydratableInstance(workInProgress),returnFiber=workInProgress.type,prevSibling=workInProgress.pendingProps,context=null!==current?current.memoizedProps:null,hasId=prevSibling.children,shouldSetTextContent(returnFiber,prevSibling)?hasId=null:null!==context&&shouldSetTextContent(returnFiber,context)&&(workInProgress.flags|=32),markRef$1(current,
workInProgress),reconcileChildren(current,workInProgress,hasId,renderLanes),workInProgress.child;case 6:return null===current&&tryToClaimNextHydratableInstance(workInProgress),null;case 13:return updateSuspenseComponent(current,workInProgress,renderLanes);case 4:return pushHostContainer(workInProgress,workInProgress.stateNode.containerInfo),returnFiber=workInProgress.pendingProps,null===current?workInProgress.child=reconcileChildFibers$jscomp$0(workInProgress,null,returnFiber,renderLanes):reconcileChildren(current,
workInProgress,returnFiber,renderLanes),workInProgress.child;case 11:return returnFiber=workInProgress.type,prevSibling=workInProgress.pendingProps,prevSibling=workInProgress.elementType===returnFiber?prevSibling:resolveDefaultProps(returnFiber,prevSibling),updateForwardRef(current,workInProgress,returnFiber,prevSibling,renderLanes);case 7:return reconcileChildren(current,workInProgress,workInProgress.pendingProps,renderLanes),workInProgress.child;case 8:return reconcileChildren(current,workInProgress,
workInProgress.pendingProps.children,renderLanes),workInProgress.child;case 12:return workInProgress.flags|=4,returnFiber=workInProgress.stateNode,returnFiber.effectDuration=0,returnFiber.passiveEffectDuration=0,reconcileChildren(current,workInProgress,workInProgress.pendingProps.children,renderLanes),workInProgress.child;case 10:a:{returnFiber=workInProgress.type._context;prevSibling=workInProgress.pendingProps;context=workInProgress.memoizedProps;hasId=prevSibling.value;"value"in prevSibling||hasWarnedAboutUsingNoValuePropOnContextProvider||
(hasWarnedAboutUsingNoValuePropOnContextProvider=!0,error$jscomp$0("The `value` prop is required for the `\x3cContext.Provider\x3e`. Did you misspell it or forget to pass it?"));(_componentName=workInProgress.type.propTypes)&&checkPropTypes(_componentName,prevSibling,"prop","Context.Provider");pushProvider(workInProgress,returnFiber,hasId);if(null!==context)if(objectIs(context.value,hasId)){if(context.children===prevSibling.children&&!didPerformWorkStackCursor.current){workInProgress=bailoutOnAlreadyFinishedWork(current,
workInProgress,renderLanes);break a}}else for(context=workInProgress.child,null!==context&&(context.return=workInProgress);null!==context;){_componentName=context.dependencies;if(null!==_componentName){hasId=context.child;for(var dependency=_componentName.firstContext;null!==dependency;){if(dependency.context===returnFiber){if(1===context.tag){dependency=createUpdate(-1,renderLanes&-renderLanes);dependency.tag=ForceUpdate;var updateQueue=context.updateQueue;if(null!==updateQueue){updateQueue=updateQueue.shared;
var pending=updateQueue.pending;null===pending?dependency.next=dependency:(dependency.next=pending.next,pending.next=dependency);updateQueue.pending=dependency}}context.lanes|=renderLanes;dependency=context.alternate;null!==dependency&&(dependency.lanes|=renderLanes);scheduleContextWorkOnParentPath(context.return,renderLanes,workInProgress);_componentName.lanes|=renderLanes;break}dependency=dependency.next}}else if(10===context.tag)hasId=context.type===workInProgress.type?null:context.child;else if(18===
context.tag){hasId=context.return;if(null===hasId)throw Error("We just came from a parent so we must have had a parent. This is a bug in React.");hasId.lanes|=renderLanes;_componentName=hasId.alternate;null!==_componentName&&(_componentName.lanes|=renderLanes);scheduleContextWorkOnParentPath(hasId,renderLanes,workInProgress);hasId=context.sibling}else hasId=context.child;if(null!==hasId)hasId.return=context;else for(hasId=context;null!==hasId;){if(hasId===workInProgress){hasId=null;break}context=
hasId.sibling;if(null!==context){context.return=hasId.return;hasId=context;break}hasId=hasId.return}context=hasId}reconcileChildren(current,workInProgress,prevSibling.children,renderLanes);workInProgress=workInProgress.child}return workInProgress;case 9:return prevSibling=workInProgress.type,void 0===prevSibling._context?prevSibling===prevSibling.Consumer||hasWarnedAboutUsingContextAsConsumer||(hasWarnedAboutUsingContextAsConsumer=!0,error$jscomp$0("Rendering \x3cContext\x3e directly is not supported and will be removed in a future major release. Did you mean to render \x3cContext.Consumer\x3e instead?")):
prevSibling=prevSibling._context,returnFiber=workInProgress.pendingProps.children,"function"!==typeof returnFiber&&error$jscomp$0("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."),prepareToReadContext(workInProgress,renderLanes),prevSibling=readContext(prevSibling),markComponentRenderStarted(workInProgress),
ReactCurrentOwner$1.current=workInProgress,isRendering=!0,returnFiber=returnFiber(prevSibling),isRendering=!1,markComponentRenderStopped(),workInProgress.flags|=1,reconcileChildren(current,workInProgress,returnFiber,renderLanes),workInProgress.child;case 14:return returnFiber=workInProgress.type,prevSibling=resolveDefaultProps(returnFiber,workInProgress.pendingProps),workInProgress.type!==workInProgress.elementType&&(context=returnFiber.propTypes)&&checkPropTypes(context,prevSibling,"prop",getComponentNameFromType(returnFiber)),
prevSibling=resolveDefaultProps(returnFiber.type,prevSibling),updateMemoComponent(current,workInProgress,returnFiber,prevSibling,renderLanes);case 15:return updateSimpleMemoComponent(current,workInProgress,workInProgress.type,workInProgress.pendingProps,renderLanes);case 17:return returnFiber=workInProgress.type,prevSibling=workInProgress.pendingProps,prevSibling=workInProgress.elementType===returnFiber?prevSibling:resolveDefaultProps(returnFiber,prevSibling),null!==current&&(current.alternate=null,
workInProgress.alternate=null,workInProgress.flags|=2),workInProgress.tag=1,isContextProvider(returnFiber)?(current=!0,pushContextProvider(workInProgress)):current=!1,prepareToReadContext(workInProgress,renderLanes),constructClassInstance(workInProgress,returnFiber,prevSibling),mountClassInstance(workInProgress,returnFiber,prevSibling,renderLanes),finishClassComponent(null,workInProgress,returnFiber,!0,current,renderLanes);case 19:return updateSuspenseListComponent(current,workInProgress,renderLanes);
case 22:return updateOffscreenComponent(current,workInProgress,renderLanes)}throw Error("Unknown unit of work tag ("+workInProgress.tag+"). This error is likely caused by a bug in React. Please file an issue.");}function unwindWork(current,workInProgress,renderLanes){popTreeContext(workInProgress);switch(workInProgress.tag){case 1:return isContextProvider(workInProgress.type)&&popContext(workInProgress),current=workInProgress.flags,current&65536?(workInProgress.flags=current&-65537|128,0!==(workInProgress.mode&
2)&&transferActualDuration(workInProgress),workInProgress):null;case 3:return popHostContainer(workInProgress),popTopLevelContextObject(workInProgress),resetWorkInProgressVersions(),current=workInProgress.flags,0!==(current&65536)&&0===(current&128)?(workInProgress.flags=current&-65537|128,workInProgress):null;case 5:return popHostContext(workInProgress),null;case 13:pop(suspenseStackCursor,workInProgress);current=workInProgress.memoizedState;if(null!==current&&null!==current.dehydrated){if(null===
workInProgress.alternate)throw Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");resetHydrationState()}current=workInProgress.flags;return current&65536?(workInProgress.flags=current&-65537|128,0!==(workInProgress.mode&2)&&transferActualDuration(workInProgress),workInProgress):null;case 19:return pop(suspenseStackCursor,workInProgress),null;case 4:return popHostContainer(workInProgress),null;case 10:return popProvider(workInProgress.type._context,
workInProgress),null;case 22:case 23:return popRenderLanes(workInProgress),null;case 24:return null;default:return null}}function unwindInterruptedWork(current,interruptedWork,renderLanes){popTreeContext(interruptedWork);switch(interruptedWork.tag){case 1:current=interruptedWork.type.childContextTypes;null!==current&&void 0!==current&&popContext(interruptedWork);break;case 3:popHostContainer(interruptedWork);popTopLevelContextObject(interruptedWork);resetWorkInProgressVersions();break;case 5:popHostContext(interruptedWork);
break;case 4:popHostContainer(interruptedWork);break;case 13:pop(suspenseStackCursor,interruptedWork);break;case 19:pop(suspenseStackCursor,interruptedWork);break;case 10:popProvider(interruptedWork.type._context,interruptedWork);break;case 22:case 23:popRenderLanes(interruptedWork)}}function invokeGuardedCallbackProd(name,func,context,a,b,c,d,e,f){var funcArgs=Array.prototype.slice.call(arguments,3);try{func.apply(context,funcArgs)}catch(error){this.onError(error)}}function invokeGuardedCallback(name,
func,context,a,b,c,d,e,f){hasError=!1;caughtError=null;invokeGuardedCallbackImpl$1.apply(reporter,arguments)}function clearCaughtError(){if(hasError){var error=caughtError;hasError=!1;caughtError=null;return error}throw Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");}function reportUncaughtErrorInDEV(error){invokeGuardedCallback(null,function(){throw error;});clearCaughtError()}function safelyCallCommitHookLayoutEffectListMount(current,
nearestMountedAncestor){try{commitHookEffectListMount(Layout,current)}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(current,nearestMountedAncestor,error)}}function safelyCallComponentWillUnmount(current,nearestMountedAncestor,instance){try{if(instance.props=current.memoizedProps,instance.state=current.memoizedState,current.mode&2)try{startLayoutEffectTimer(),instance.componentWillUnmount()}finally{recordLayoutEffectDuration(current)}else instance.componentWillUnmount()}catch(error){reportUncaughtErrorInDEV(error),
captureCommitPhaseError(current,nearestMountedAncestor,error)}}function safelyAttachRef(current,nearestMountedAncestor){try{commitAttachRef(current)}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(current,nearestMountedAncestor,error)}}function safelyDetachRef(current,nearestMountedAncestor){var ref=current.ref;if(null!==ref)if("function"===typeof ref){try{if(current.mode&2)try{startLayoutEffectTimer();var retVal=ref(null)}finally{recordLayoutEffectDuration(current)}else retVal=
ref(null)}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(current,nearestMountedAncestor,error)}"function"===typeof retVal&&error$jscomp$0("Unexpected return value from a callback ref in %s. A callback ref should not return a function.",getComponentNameFromFiber(current))}else ref.current=null}function safelyCallDestroy(current,nearestMountedAncestor,destroy){try{destroy()}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(current,nearestMountedAncestor,error)}}
function commitBeforeMutationEffects(root,firstChild){prepareForCommit(root.containerInfo);for(nextEffect=firstChild;null!==nextEffect;)if(root=nextEffect,firstChild=root.child,0!==(root.subtreeFlags&1028)&&null!==firstChild)ensureCorrectReturnPointer(firstChild,root),nextEffect=firstChild;else for(;null!==nextEffect;){root=nextEffect;setCurrentFiber(root);try{firstChild=root;var current=firstChild.alternate;if(0!==(firstChild.flags&1024)){setCurrentFiber(firstChild);switch(firstChild.tag){case 0:case 11:case 15:break;
case 1:if(null!==current){var prevProps=current.memoizedProps,prevState=current.memoizedState,instance=firstChild.stateNode;firstChild.type!==firstChild.elementType||didWarnAboutReassigningProps||(instance.props!==firstChild.memoizedProps&&error$jscomp$0("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(firstChild)||"instance"),
instance.state!==firstChild.memoizedState&&error$jscomp$0("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(firstChild)||"instance"));var snapshot=instance.getSnapshotBeforeUpdate(firstChild.elementType===firstChild.type?prevProps:resolveDefaultProps(firstChild.type,prevProps),prevState),didWarnSet=didWarnAboutUndefinedSnapshotBeforeUpdate;
void 0!==snapshot||didWarnSet.has(firstChild.type)||(didWarnSet.add(firstChild.type),error$jscomp$0("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.",getComponentNameFromFiber(firstChild)));instance.__reactInternalSnapshotBeforeUpdate=snapshot}break;case 3:supportsMutation&&clearContainer(firstChild.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
}resetCurrentFiber()}}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(root,root.return,error)}resetCurrentFiber();firstChild=root.sibling;if(null!==firstChild){ensureCorrectReturnPointer(firstChild,root.return);nextEffect=firstChild;break}nextEffect=root.return}current=shouldFireAfterActiveInstanceBlur;shouldFireAfterActiveInstanceBlur=!1;return current}function commitHookEffectListUnmount(flags,finishedWork,nearestMountedAncestor){var updateQueue=finishedWork.updateQueue;updateQueue=
null!==updateQueue?updateQueue.lastEffect:null;if(null!==updateQueue){var effect=updateQueue=updateQueue.next;do{if((effect.tag&flags)===flags){var destroy=effect.destroy;effect.destroy=void 0;void 0!==destroy&&((flags&Passive$1)!==NoFlags$1?null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted&&injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(finishedWork):(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectUnmountStarted(finishedWork),
safelyCallDestroy(finishedWork,nearestMountedAncestor,destroy),(flags&Passive$1)!==NoFlags$1?null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped&&injectedProfilingHooks.markComponentPassiveEffectUnmountStopped():(flags&Layout)!==NoFlags$1&&markComponentLayoutEffectUnmountStopped())}effect=effect.next}while(effect!==updateQueue)}}function commitHookEffectListMount(flags,finishedWork){var updateQueue=finishedWork.updateQueue;updateQueue=
null!==updateQueue?updateQueue.lastEffect:null;if(null!==updateQueue){var effect=updateQueue=updateQueue.next;do{if((effect.tag&flags)===flags){(flags&Passive$1)!==NoFlags$1?null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted&&injectedProfilingHooks.markComponentPassiveEffectMountStarted(finishedWork):(flags&Layout)!==NoFlags$1&&null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted&&
injectedProfilingHooks.markComponentLayoutEffectMountStarted(finishedWork);var create=effect.create;effect.destroy=create();(flags&Passive$1)!==NoFlags$1?null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped&&injectedProfilingHooks.markComponentPassiveEffectMountStopped():(flags&Layout)!==NoFlags$1&&null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped&&injectedProfilingHooks.markComponentLayoutEffectMountStopped();
create=effect.destroy;if(void 0!==create&&"function"!==typeof create){var hookName=0!==(effect.tag&Layout)?"useLayoutEffect":0!==(effect.tag&Insertion)?"useInsertionEffect":"useEffect";error$jscomp$0("%s must not return anything besides a function, which is used for clean-up.%s",hookName,null===create?" You returned null. If your effect does not require clean up, return undefined (or nothing).":"function"===typeof create.then?"\n\nIt looks like you wrote "+hookName+"(async () \x3d\x3e ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:\n\n"+
hookName+"(() \x3d\x3e {\n  async function fetchData() {\n    // You can await here\n    const response \x3d await MyAPI.getData(someId);\n    // ...\n  }\n  fetchData();\n}, [someId]); // Or [] if effect doesn't need props or state\n\nLearn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching":" You returned: "+create)}}effect=effect.next}while(effect!==updateQueue)}}function commitAttachRef(finishedWork){var ref=finishedWork.ref;if(null!==ref){var instance=finishedWork.stateNode;
switch(finishedWork.tag){case 5:instance=getPublicInstance(instance)}if("function"===typeof ref){if(finishedWork.mode&2)try{startLayoutEffectTimer();var retVal=ref(instance)}finally{recordLayoutEffectDuration(finishedWork)}else retVal=ref(instance);"function"===typeof retVal&&error$jscomp$0("Unexpected return value from a callback ref in %s. A callback ref should not return a function.",getComponentNameFromFiber(finishedWork))}else ref.hasOwnProperty("current")||error$jscomp$0("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().",
getComponentNameFromFiber(finishedWork)),ref.current=instance}}function commitUnmount(finishedRoot,current,nearestMountedAncestor){if(injectedHook&&"function"===typeof injectedHook.onCommitFiberUnmount)try{injectedHook.onCommitFiberUnmount(rendererID,current)}catch(err){hasLoggedError||(hasLoggedError=!0,error$jscomp$0("React instrumentation encountered an error: %s",err))}switch(current.tag){case 0:case 11:case 14:case 15:finishedRoot=current.updateQueue;if(null!==finishedRoot&&(finishedRoot=finishedRoot.lastEffect,
null!==finishedRoot)){var effect=finishedRoot=finishedRoot.next;do{var _effect=effect,destroy=_effect.destroy;_effect=_effect.tag;void 0!==destroy&&((_effect&Insertion)!==NoFlags$1?safelyCallDestroy(current,nearestMountedAncestor,destroy):(_effect&Layout)!==NoFlags$1&&(markComponentLayoutEffectUnmountStarted(current),current.mode&2?(startLayoutEffectTimer(),safelyCallDestroy(current,nearestMountedAncestor,destroy),recordLayoutEffectDuration(current)):safelyCallDestroy(current,nearestMountedAncestor,
destroy),markComponentLayoutEffectUnmountStopped()));effect=effect.next}while(effect!==finishedRoot)}break;case 1:safelyDetachRef(current,nearestMountedAncestor);finishedRoot=current.stateNode;"function"===typeof finishedRoot.componentWillUnmount&&safelyCallComponentWillUnmount(current,nearestMountedAncestor,finishedRoot);break;case 5:safelyDetachRef(current,nearestMountedAncestor);break;case 4:supportsMutation?unmountHostComponents(finishedRoot,current,nearestMountedAncestor):supportsPersistence&&
supportsPersistence&&(current=current.stateNode.containerInfo,nearestMountedAncestor=createContainerChildSet(current),replaceContainerChildren(current,nearestMountedAncestor))}}function commitNestedUnmounts(finishedRoot,root,nearestMountedAncestor){for(var node=root;;)if(commitUnmount(finishedRoot,node,nearestMountedAncestor),null===node.child||supportsMutation&&4===node.tag){if(node===root)break;for(;null===node.sibling;){if(null===node.return||node.return===root)return;node=node.return}node.sibling.return=
node.return;node=node.sibling}else node.child.return=node,node=node.child}function detachFiberAfterEffects(fiber){var alternate=fiber.alternate;null!==alternate&&(fiber.alternate=null,detachFiberAfterEffects(alternate));fiber.child=null;fiber.deletions=null;fiber.sibling=null;5===fiber.tag&&(alternate=fiber.stateNode,null!==alternate&&detachDeletedInstance(alternate));fiber.stateNode=null;fiber._debugOwner=null;fiber.return=null;fiber.dependencies=null;fiber.memoizedProps=null;fiber.memoizedState=
null;fiber.pendingProps=null;fiber.stateNode=null;fiber.updateQueue=null}function isHostParent(fiber){return 5===fiber.tag||3===fiber.tag||4===fiber.tag}function getHostSibling(fiber){a:for(;;){for(;null===fiber.sibling;){if(null===fiber.return||isHostParent(fiber.return))return null;fiber=fiber.return}fiber.sibling.return=fiber.return;for(fiber=fiber.sibling;5!==fiber.tag&&6!==fiber.tag&&18!==fiber.tag;){if(fiber.flags&2)continue a;if(null===fiber.child||4===fiber.tag)continue a;else fiber.child.return=
fiber,fiber=fiber.child}if(!(fiber.flags&2))return fiber.stateNode}}function commitPlacement(finishedWork){if(supportsMutation){a:{for(var parent=finishedWork.return;null!==parent;){if(isHostParent(parent)){var parentFiber=parent;break a}parent=parent.return}throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");}switch(parentFiber.tag){case 5:parent=parentFiber.stateNode;parentFiber.flags&32&&(resetTextContent(parent),parentFiber.flags&=
-33);parentFiber=getHostSibling(finishedWork);insertOrAppendPlacementNode(finishedWork,parentFiber,parent);break;case 3:case 4:parent=parentFiber.stateNode.containerInfo;parentFiber=getHostSibling(finishedWork);insertOrAppendPlacementNodeIntoContainer(finishedWork,parentFiber,parent);break;default:throw Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");}}}function insertOrAppendPlacementNodeIntoContainer(node,before,parent){var tag=node.tag;if(5===
tag||6===tag)node=node.stateNode,before?insertInContainerBefore(parent,node,before):appendChildToContainer(parent,node);else if(4!==tag&&(node=node.child,null!==node))for(insertOrAppendPlacementNodeIntoContainer(node,before,parent),node=node.sibling;null!==node;)insertOrAppendPlacementNodeIntoContainer(node,before,parent),node=node.sibling}function insertOrAppendPlacementNode(node,before,parent){var tag=node.tag;if(5===tag||6===tag)node=node.stateNode,before?insertBefore(parent,node,before):appendChild(parent,
node);else if(4!==tag&&(node=node.child,null!==node))for(insertOrAppendPlacementNode(node,before,parent),node=node.sibling;null!==node;)insertOrAppendPlacementNode(node,before,parent),node=node.sibling}function unmountHostComponents(finishedRoot,current,nearestMountedAncestor){for(var node=current,currentParentIsValid=!1,currentParent,currentParentIsContainer;;){if(!currentParentIsValid){currentParentIsValid=node.return;a:for(;;){if(null===currentParentIsValid)throw Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
currentParent=currentParentIsValid.stateNode;switch(currentParentIsValid.tag){case 5:currentParentIsContainer=!1;break a;case 3:currentParent=currentParent.containerInfo;currentParentIsContainer=!0;break a;case 4:currentParent=currentParent.containerInfo;currentParentIsContainer=!0;break a}currentParentIsValid=currentParentIsValid.return}currentParentIsValid=!0}if(5===node.tag||6===node.tag)commitNestedUnmounts(finishedRoot,node,nearestMountedAncestor),currentParentIsContainer?removeChildFromContainer(currentParent,
node.stateNode):removeChild(currentParent,node.stateNode);else if(18===node.tag)currentParentIsContainer?clearSuspenseBoundaryFromContainer(currentParent,node.stateNode):clearSuspenseBoundary(currentParent,node.stateNode);else if(4===node.tag){if(null!==node.child){currentParent=node.stateNode.containerInfo;currentParentIsContainer=!0;node.child.return=node;node=node.child;continue}}else if(commitUnmount(finishedRoot,node,nearestMountedAncestor),null!==node.child){node.child.return=node;node=node.child;
continue}if(node===current)break;for(;null===node.sibling;){if(null===node.return||node.return===current)return;node=node.return;4===node.tag&&(currentParentIsValid=!1)}node.sibling.return=node.return;node=node.sibling}}function commitWork(current,finishedWork){if(supportsMutation){switch(finishedWork.tag){case 0:case 11:case 14:case 15:commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);if(finishedWork.mode&
2)try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return)}finally{recordLayoutEffectDuration(finishedWork)}else commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);return;case 1:return;case 5:var instance=finishedWork.stateNode;if(null!=instance){var newProps=finishedWork.memoizedProps;current=null!==current?current.memoizedProps:newProps;var type=finishedWork.type,updatePayload=finishedWork.updateQueue;finishedWork.updateQueue=
null;null!==updatePayload&&commitUpdate(instance,updatePayload,type,current,newProps,finishedWork)}return;case 6:if(null===finishedWork.stateNode)throw Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");instance=finishedWork.memoizedProps;commitTextUpdate(finishedWork.stateNode,null!==current?current.memoizedProps:instance,instance);return;case 3:supportsHydration&&null!==current&&current.memoizedState.isDehydrated&&commitHydratedContainer(finishedWork.stateNode.containerInfo);
return;case 12:return;case 13:attachSuspenseRetryListeners(finishedWork);return;case 19:attachSuspenseRetryListeners(finishedWork);return;case 17:return}throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}switch(finishedWork.tag){case 0:case 11:case 14:case 15:commitHookEffectListUnmount(Insertion|HasEffect,finishedWork,finishedWork.return);commitHookEffectListMount(Insertion|HasEffect,finishedWork);if(finishedWork.mode&
2)try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return)}finally{recordLayoutEffectDuration(finishedWork)}else commitHookEffectListUnmount(Layout|HasEffect,finishedWork,finishedWork.return);return;case 12:return;case 13:attachSuspenseRetryListeners(finishedWork);return;case 19:attachSuspenseRetryListeners(finishedWork);return;case 3:supportsHydration&&null!==current&&current.memoizedState.isDehydrated&&commitHydratedContainer(finishedWork.stateNode.containerInfo);
break;case 22:case 23:return}a:if(supportsPersistence){switch(finishedWork.tag){case 1:case 5:case 6:break a;case 3:case 4:finishedWork=finishedWork.stateNode;replaceContainerChildren(finishedWork.containerInfo,finishedWork.pendingChildren);break a}throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}}function attachSuspenseRetryListeners(finishedWork){var wakeables=finishedWork.updateQueue;if(null!==wakeables){finishedWork.updateQueue=
null;var retryCache=finishedWork.stateNode;null===retryCache&&(retryCache=finishedWork.stateNode=new PossiblyWeakSet);wakeables.forEach(function(wakeable){var retry=resolveRetryWakeable.bind(null,finishedWork,wakeable);if(!retryCache.has(wakeable)){retryCache.add(wakeable);if(isDevToolsPresent)if(null!==inProgressLanes&&null!==inProgressRoot)restorePendingUpdaters(inProgressRoot,inProgressLanes);else throw Error("Expected finished root and lanes to be set. This is a bug in React.");wakeable.then(retry,
retry)}})}}function commitMutationEffects(root,firstChild$jscomp$0,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;for(nextEffect=firstChild$jscomp$0;null!==nextEffect;){firstChild$jscomp$0=nextEffect;committedLanes=firstChild$jscomp$0.deletions;if(null!==committedLanes)for(var i=0;i<committedLanes.length;i++){var childToDelete=committedLanes[i];try{var finishedRoot=root,current=childToDelete,nearestMountedAncestor=firstChild$jscomp$0;supportsMutation?unmountHostComponents(finishedRoot,
current,nearestMountedAncestor):commitNestedUnmounts(finishedRoot,current,nearestMountedAncestor);finishedRoot=current;var alternate=finishedRoot.alternate;null!==alternate&&(alternate.return=null);finishedRoot.return=null}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(childToDelete,firstChild$jscomp$0,error)}}committedLanes=firstChild$jscomp$0.child;if(0!==(firstChild$jscomp$0.subtreeFlags&12854)&&null!==committedLanes)ensureCorrectReturnPointer(committedLanes,firstChild$jscomp$0),
nextEffect=committedLanes;else for(;null!==nextEffect;){firstChild$jscomp$0=nextEffect;setCurrentFiber(firstChild$jscomp$0);try{committedLanes=firstChild$jscomp$0;var flags=committedLanes.flags;flags&32&&supportsMutation&&resetTextContent(committedLanes.stateNode);if(flags&512){var current$jscomp$0=committedLanes.alternate;if(null!==current$jscomp$0){i=current$jscomp$0;var currentRef=i.ref;if(null!==currentRef)if("function"===typeof currentRef)if(i.mode&2)try{startLayoutEffectTimer(),currentRef(null)}finally{recordLayoutEffectDuration(i)}else currentRef(null);
else currentRef.current=null}}if(flags&8192)switch(committedLanes.tag){case 13:if(null!==committedLanes.memoizedState){var _current=committedLanes.alternate;if(null===_current||null===_current.memoizedState)globalMostRecentFallbackTime=now$1()}break;case 22:var _isHidden=null!==committedLanes.memoizedState,_current2=committedLanes.alternate,_wasHidden=null!==_current2&&null!==_current2.memoizedState;i=committedLanes;if(supportsMutation)a:if(childToDelete=i,finishedRoot=_isHidden,current=null,supportsMutation)for(nearestMountedAncestor=
childToDelete;;){if(5===nearestMountedAncestor.tag){if(null===current){current=nearestMountedAncestor;var instance=nearestMountedAncestor.stateNode;finishedRoot?hideInstance(instance):unhideInstance(nearestMountedAncestor.stateNode,nearestMountedAncestor.memoizedProps)}}else if(6===nearestMountedAncestor.tag){if(null===current){var _instance3=nearestMountedAncestor.stateNode;finishedRoot?hideTextInstance(_instance3):unhideTextInstance(_instance3,nearestMountedAncestor.memoizedProps)}}else if((22!==
nearestMountedAncestor.tag&&23!==nearestMountedAncestor.tag||null===nearestMountedAncestor.memoizedState||nearestMountedAncestor===childToDelete)&&null!==nearestMountedAncestor.child){nearestMountedAncestor.child.return=nearestMountedAncestor;nearestMountedAncestor=nearestMountedAncestor.child;continue}if(nearestMountedAncestor===childToDelete)break;for(;null===nearestMountedAncestor.sibling;){if(null===nearestMountedAncestor.return||nearestMountedAncestor.return===childToDelete)break a;current===
nearestMountedAncestor&&(current=null);nearestMountedAncestor=nearestMountedAncestor.return}current===nearestMountedAncestor&&(current=null);nearestMountedAncestor.sibling.return=nearestMountedAncestor.return;nearestMountedAncestor=nearestMountedAncestor.sibling}if(_isHidden&&!_wasHidden&&0!==(i.mode&1)){nextEffect=i;for(var offscreenChild=i.child;null!==offscreenChild;){for(i=nextEffect=offscreenChild;null!==nextEffect;){childToDelete=nextEffect;var firstChild=childToDelete.child;switch(childToDelete.tag){case 0:case 11:case 14:case 15:if(childToDelete.mode&
2)try{startLayoutEffectTimer(),commitHookEffectListUnmount(Layout,childToDelete,childToDelete.return)}finally{recordLayoutEffectDuration(childToDelete)}else commitHookEffectListUnmount(Layout,childToDelete,childToDelete.return);break;case 1:safelyDetachRef(childToDelete,childToDelete.return);var instance$jscomp$0=childToDelete.stateNode;"function"===typeof instance$jscomp$0.componentWillUnmount&&safelyCallComponentWillUnmount(childToDelete,childToDelete.return,instance$jscomp$0);break;case 5:safelyDetachRef(childToDelete,
childToDelete.return);break;case 22:if(null!==childToDelete.memoizedState){disappearLayoutEffects_complete(i);continue}}null!==firstChild?(firstChild.return=childToDelete,nextEffect=firstChild):disappearLayoutEffects_complete(i)}offscreenChild=offscreenChild.sibling}}}switch(flags&4102){case 2:commitPlacement(committedLanes);committedLanes.flags&=-3;break;case 6:commitPlacement(committedLanes);committedLanes.flags&=-3;commitWork(committedLanes.alternate,committedLanes);break;case 4096:committedLanes.flags&=
-4097;break;case 4100:committedLanes.flags&=-4097;commitWork(committedLanes.alternate,committedLanes);break;case 4:commitWork(committedLanes.alternate,committedLanes)}}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(firstChild$jscomp$0,firstChild$jscomp$0.return,error)}resetCurrentFiber();committedLanes=firstChild$jscomp$0.sibling;if(null!==committedLanes){ensureCorrectReturnPointer(committedLanes,firstChild$jscomp$0.return);nextEffect=committedLanes;break}nextEffect=firstChild$jscomp$0.return}}inProgressRoot=
inProgressLanes=null}function commitLayoutEffects(finishedWork,root,committedLanes){inProgressLanes=committedLanes;inProgressRoot=root;nextEffect=finishedWork;commitLayoutEffects_begin(finishedWork,root,committedLanes);inProgressRoot=inProgressLanes=null}function commitLayoutEffects_begin(subtreeRoot,root,committedLanes){for(var isModernRoot=0!==(subtreeRoot.mode&1);null!==nextEffect;){var fiber=nextEffect,firstChild=fiber.child;if(22===fiber.tag&&isModernRoot){var newOffscreenSubtreeIsHidden=null!==
fiber.memoizedState||offscreenSubtreeIsHidden;if(!newOffscreenSubtreeIsHidden){var current=fiber.alternate,newOffscreenSubtreeWasHidden=null!==current&&null!==current.memoizedState||offscreenSubtreeWasHidden;current=offscreenSubtreeIsHidden;var prevOffscreenSubtreeWasHidden=offscreenSubtreeWasHidden;offscreenSubtreeIsHidden=newOffscreenSubtreeIsHidden;if((offscreenSubtreeWasHidden=newOffscreenSubtreeWasHidden)&&!prevOffscreenSubtreeWasHidden)for(newOffscreenSubtreeIsHidden=nextEffect=fiber;null!==
nextEffect;){newOffscreenSubtreeWasHidden=nextEffect;var firstChild$jscomp$0=newOffscreenSubtreeWasHidden.child;22===newOffscreenSubtreeWasHidden.tag&&null!==newOffscreenSubtreeWasHidden.memoizedState?reappearLayoutEffects_complete(newOffscreenSubtreeIsHidden):null!==firstChild$jscomp$0?(firstChild$jscomp$0.return=newOffscreenSubtreeWasHidden,nextEffect=firstChild$jscomp$0):reappearLayoutEffects_complete(newOffscreenSubtreeIsHidden)}for(;null!==firstChild;)nextEffect=firstChild,commitLayoutEffects_begin(firstChild,
root,committedLanes),firstChild=firstChild.sibling;nextEffect=fiber;offscreenSubtreeIsHidden=current;offscreenSubtreeWasHidden=prevOffscreenSubtreeWasHidden}commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes)}else 0!==(fiber.subtreeFlags&8772)&&null!==firstChild?(ensureCorrectReturnPointer(firstChild,fiber),nextEffect=firstChild):commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes)}}function commitLayoutMountEffects_complete(subtreeRoot,root,committedLanes){for(;null!==
nextEffect;){root=nextEffect;if(0!==(root.flags&8772)){committedLanes=root.alternate;setCurrentFiber(root);try{var current=committedLanes;committedLanes=root;if(0!==(committedLanes.flags&8772))switch(committedLanes.tag){case 0:case 11:case 15:if(!offscreenSubtreeWasHidden)if(committedLanes.mode&2)try{startLayoutEffectTimer(),commitHookEffectListMount(Layout|HasEffect,committedLanes)}finally{recordLayoutEffectDuration(committedLanes)}else commitHookEffectListMount(Layout|HasEffect,committedLanes);
break;case 1:var instance=committedLanes.stateNode;if(committedLanes.flags&4&&!offscreenSubtreeWasHidden)if(null===current)if(committedLanes.type!==committedLanes.elementType||didWarnAboutReassigningProps||(instance.props!==committedLanes.memoizedProps&&error$jscomp$0("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(committedLanes)||
"instance"),instance.state!==committedLanes.memoizedState&&error$jscomp$0("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(committedLanes)||"instance")),committedLanes.mode&2)try{startLayoutEffectTimer(),instance.componentDidMount()}finally{recordLayoutEffectDuration(committedLanes)}else instance.componentDidMount();else{var prevProps=
committedLanes.elementType===committedLanes.type?current.memoizedProps:resolveDefaultProps(committedLanes.type,current.memoizedProps),prevState=current.memoizedState;committedLanes.type!==committedLanes.elementType||didWarnAboutReassigningProps||(instance.props!==committedLanes.memoizedProps&&error$jscomp$0("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",
getComponentNameFromFiber(committedLanes)||"instance"),instance.state!==committedLanes.memoizedState&&error$jscomp$0("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(committedLanes)||"instance"));if(committedLanes.mode&2)try{startLayoutEffectTimer(),instance.componentDidUpdate(prevProps,prevState,instance.__reactInternalSnapshotBeforeUpdate)}finally{recordLayoutEffectDuration(committedLanes)}else instance.componentDidUpdate(prevProps,
prevState,instance.__reactInternalSnapshotBeforeUpdate)}var updateQueue=committedLanes.updateQueue;null!==updateQueue&&(committedLanes.type!==committedLanes.elementType||didWarnAboutReassigningProps||(instance.props!==committedLanes.memoizedProps&&error$jscomp$0("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.",getComponentNameFromFiber(committedLanes)||
"instance"),instance.state!==committedLanes.memoizedState&&error$jscomp$0("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.",getComponentNameFromFiber(committedLanes)||"instance")),commitUpdateQueue(committedLanes,updateQueue,instance));break;case 3:var _updateQueue=committedLanes.updateQueue;if(null!==_updateQueue){var _instance=null;if(null!==
committedLanes.child)switch(committedLanes.child.tag){case 5:_instance=getPublicInstance(committedLanes.child.stateNode);break;case 1:_instance=committedLanes.child.stateNode}commitUpdateQueue(committedLanes,_updateQueue,_instance)}break;case 5:var _instance2=committedLanes.stateNode;null===current&&committedLanes.flags&4&&commitMount(_instance2,committedLanes.type,committedLanes.memoizedProps,committedLanes);break;case 6:break;case 4:break;case 12:var _finishedWork$memoize2=committedLanes.memoizedProps,
onCommit=_finishedWork$memoize2.onCommit,onRender=_finishedWork$memoize2.onRender,effectDuration=committedLanes.stateNode.effectDuration;_instance=commitTime;current=null===current?"mount":"update";currentUpdateIsNested&&(current="nested-update");"function"===typeof onRender&&onRender(committedLanes.memoizedProps.id,current,committedLanes.actualDuration,committedLanes.treeBaseDuration,committedLanes.actualStartTime,_instance);"function"===typeof onCommit&&onCommit(committedLanes.memoizedProps.id,
current,effectDuration,_instance);enqueuePendingPassiveProfilerEffect(committedLanes);var parentFiber=committedLanes.return;a:for(;null!==parentFiber;){switch(parentFiber.tag){case 3:parentFiber.stateNode.effectDuration+=effectDuration;break a;case 12:parentFiber.stateNode.effectDuration+=effectDuration;break a}parentFiber=parentFiber.return}break;case 13:if(supportsHydration&&null===committedLanes.memoizedState){var current$jscomp$0=committedLanes.alternate;if(null!==current$jscomp$0){var prevState$jscomp$0=
current$jscomp$0.memoizedState;if(null!==prevState$jscomp$0){var suspenseInstance=prevState$jscomp$0.dehydrated;null!==suspenseInstance&&commitHydratedSuspenseInstance(suspenseInstance)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");}offscreenSubtreeWasHidden||committedLanes.flags&512&&commitAttachRef(committedLanes)}catch(error){reportUncaughtErrorInDEV(error),
captureCommitPhaseError(root,root.return,error)}resetCurrentFiber()}if(root===subtreeRoot){nextEffect=null;break}committedLanes=root.sibling;if(null!==committedLanes){ensureCorrectReturnPointer(committedLanes,root.return);nextEffect=committedLanes;break}nextEffect=root.return}}function disappearLayoutEffects_complete(subtreeRoot){for(;null!==nextEffect;){var fiber=nextEffect;if(fiber===subtreeRoot){nextEffect=null;break}var sibling=fiber.sibling;if(null!==sibling){sibling.return=fiber.return;nextEffect=
sibling;break}nextEffect=fiber.return}}function reappearLayoutEffects_complete(subtreeRoot){for(;null!==nextEffect;){var fiber=nextEffect;setCurrentFiber(fiber);try{var node=fiber;switch(node.tag){case 0:case 11:case 15:if(node.mode&2)try{startLayoutEffectTimer(),safelyCallCommitHookLayoutEffectListMount(node,node.return)}finally{recordLayoutEffectDuration(node)}else safelyCallCommitHookLayoutEffectListMount(node,node.return);break;case 1:var instance=node.stateNode;if("function"===typeof instance.componentDidMount){var current=
node,nearestMountedAncestor=node.return;try{instance.componentDidMount()}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(current,nearestMountedAncestor,error)}}safelyAttachRef(node,node.return);break;case 5:safelyAttachRef(node,node.return)}}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(fiber,fiber.return,error)}resetCurrentFiber();if(fiber===subtreeRoot){nextEffect=null;break}node=fiber.sibling;if(null!==node){node.return=fiber.return;nextEffect=node;break}nextEffect=
fiber.return}}function ensureCorrectReturnPointer(fiber,expectedReturnFiber){didWarnWrongReturnPointer||fiber.return===expectedReturnFiber||(didWarnWrongReturnPointer=!0,error$jscomp$0("Internal React error: Return pointer is inconsistent with parent."));fiber.return=expectedReturnFiber}function invokeLayoutEffectMountInDEV(fiber){switch(fiber.tag){case 0:case 11:case 15:try{commitHookEffectListMount(Layout|HasEffect,fiber)}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(fiber,
fiber.return,error)}break;case 1:var instance=fiber.stateNode;try{instance.componentDidMount()}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(fiber,fiber.return,error)}}}function invokePassiveEffectMountInDEV(fiber){switch(fiber.tag){case 0:case 11:case 15:try{commitHookEffectListMount(Passive$1|HasEffect,fiber)}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(fiber,fiber.return,error)}}}function invokeLayoutEffectUnmountInDEV(fiber){switch(fiber.tag){case 0:case 11:case 15:try{commitHookEffectListUnmount(Layout|
HasEffect,fiber,fiber.return)}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(fiber,fiber.return,error)}break;case 1:var instance=fiber.stateNode;"function"===typeof instance.componentWillUnmount&&safelyCallComponentWillUnmount(fiber,fiber.return,instance)}}function invokePassiveEffectUnmountInDEV(fiber){switch(fiber.tag){case 0:case 11:case 15:try{commitHookEffectListUnmount(Passive$1|HasEffect,fiber,fiber.return)}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(fiber,
fiber.return,error)}}}function findFiberRootForHostRoot(hostRoot){var maybeFiber=getInstanceFromNode(hostRoot);if(null!=maybeFiber){if("string"!==typeof maybeFiber.memoizedProps["data-testname"])throw Error("Invalid host root specified. Should be either a React container or a node with a testname attribute.");return maybeFiber}hostRoot=findFiberRoot(hostRoot);if(null===hostRoot)throw Error("Could not find React container within specified host subtree.");return hostRoot.stateNode.current}function matchSelector(fiber$jscomp$0,
selector$jscomp$0){switch(selector$jscomp$0.$$typeof){case COMPONENT_TYPE:if(fiber$jscomp$0.type===selector$jscomp$0.value)return!0;break;case HAS_PSEUDO_CLASS_TYPE:a:{selector$jscomp$0=selector$jscomp$0.value;fiber$jscomp$0=[fiber$jscomp$0,0];for(var index=0;index<fiber$jscomp$0.length;){var fiber=fiber$jscomp$0[index++],selectorIndex=fiber$jscomp$0[index++],selector=selector$jscomp$0[selectorIndex];if(5!==fiber.tag||!isHiddenSubtree(fiber)){for(;null!=selector&&matchSelector(fiber,selector);)selectorIndex++,
selector=selector$jscomp$0[selectorIndex];if(selectorIndex===selector$jscomp$0.length){selector$jscomp$0=!0;break a}else for(fiber=fiber.child;null!==fiber;)fiber$jscomp$0.push(fiber,selectorIndex),fiber=fiber.sibling}}selector$jscomp$0=!1}return selector$jscomp$0;case ROLE_TYPE:if(5===fiber$jscomp$0.tag&&matchAccessibilityRole(fiber$jscomp$0.stateNode,selector$jscomp$0.value))return!0;break;case TEXT_TYPE:if(5===fiber$jscomp$0.tag||6===fiber$jscomp$0.tag)if(fiber$jscomp$0=getTextContent(fiber$jscomp$0),
null!==fiber$jscomp$0&&0<=fiber$jscomp$0.indexOf(selector$jscomp$0.value))return!0;break;case TEST_NAME_TYPE:if(5===fiber$jscomp$0.tag&&(fiber$jscomp$0=fiber$jscomp$0.memoizedProps["data-testname"],"string"===typeof fiber$jscomp$0&&fiber$jscomp$0.toLowerCase()===selector$jscomp$0.value.toLowerCase()))return!0;break;default:throw Error("Invalid selector type specified.");}return!1}function selectorToString(selector){switch(selector.$$typeof){case COMPONENT_TYPE:return"\x3c"+(getComponentNameFromType(selector.value)||
"Unknown")+"\x3e";case HAS_PSEUDO_CLASS_TYPE:return":has("+(selectorToString(selector)||"")+")";case ROLE_TYPE:return'[role\x3d"'+selector.value+'"]';case TEXT_TYPE:return'"'+selector.value+'"';case TEST_NAME_TYPE:return'[data-testname\x3d"'+selector.value+'"]';default:throw Error("Invalid selector type specified.");}}function findPaths(root,selectors){var matchingFibers=[];root=[root,0];for(var index=0;index<root.length;){var fiber=root[index++],selectorIndex=root[index++],selector=selectors[selectorIndex];
if(5!==fiber.tag||!isHiddenSubtree(fiber)){for(;null!=selector&&matchSelector(fiber,selector);)selectorIndex++,selector=selectors[selectorIndex];if(selectorIndex===selectors.length)matchingFibers.push(fiber);else for(fiber=fiber.child;null!==fiber;)root.push(fiber,selectorIndex),fiber=fiber.sibling}}return matchingFibers}function findAllNodes(hostRoot,selectors){if(!supportsTestSelectors)throw Error("Test selector API is not supported by this renderer.");hostRoot=findFiberRootForHostRoot(hostRoot);
hostRoot=findPaths(hostRoot,selectors);selectors=[];hostRoot=Array.from(hostRoot);for(var index=0;index<hostRoot.length;){var node=hostRoot[index++];if(5===node.tag)isHiddenSubtree(node)||selectors.push(node.stateNode);else for(node=node.child;null!==node;)hostRoot.push(node),node=node.sibling}return selectors}function onCommitRoot$1(){supportsTestSelectors&&commitHooks.forEach(function(commitHook){return commitHook()})}function isConcurrentActEnvironment(){var isReactActEnvironmentGlobal="undefined"!==
typeof IS_REACT_ACT_ENVIRONMENT?IS_REACT_ACT_ENVIRONMENT:void 0;isReactActEnvironmentGlobal||null===ReactCurrentActQueue.current||error$jscomp$0("The current testing environment is not configured to support act(...)");return isReactActEnvironmentGlobal}function resetRenderTimer(){workInProgressRootRenderTargetTime=now$1()+RENDER_TIMEOUT_MS}function requestEventTime(){return(executionContext&(RenderContext|CommitContext))!==NoContext?now$1():-1!==currentEventTime?currentEventTime:currentEventTime=
now$1()}function requestUpdateLane(fiber){if(0===(fiber.mode&1))return 1;if((executionContext&RenderContext)!==NoContext&&0!==workInProgressRootRenderLanes)return workInProgressRootRenderLanes&-workInProgressRootRenderLanes;if(null!==ReactCurrentBatchConfig.transition){if(null!==ReactCurrentBatchConfig$2.transition){var transition=ReactCurrentBatchConfig$2.transition;transition._updatedFibers||(transition._updatedFibers=new Set);transition._updatedFibers.add(fiber)}0===currentEventTransitionLane&&
(fiber=nextTransitionLane,nextTransitionLane<<=1,0===(nextTransitionLane&4194240)&&(nextTransitionLane=64),currentEventTransitionLane=fiber);return currentEventTransitionLane}fiber=currentUpdatePriority;return 0!==fiber?fiber:getCurrentEventPriority()}function scheduleUpdateOnFiber(fiber,lane,eventTime){if(nestedUpdateCount>NESTED_UPDATE_LIMIT)throw nestedUpdateCount=0,rootWithNestedUpdates=null,Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
nestedPassiveUpdateCount>NESTED_PASSIVE_UPDATE_LIMIT&&(nestedPassiveUpdateCount=0,error$jscomp$0("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));var root=markUpdateLaneFromFiberToRoot(fiber,lane);if(null===root)return null;markRootUpdated(root,lane,eventTime);if(0!==(executionContext&RenderContext)&&root===workInProgressRoot){if(isRendering&&
!isUpdatingOpaqueValueInRenderPhase)switch(fiber.tag){case 0:case 11:case 15:lane=workInProgress$jscomp$0&&getComponentNameFromFiber(workInProgress$jscomp$0)||"Unknown";didWarnAboutUpdateInRenderForAnotherComponent.has(lane)||(didWarnAboutUpdateInRenderForAnotherComponent.add(lane),fiber=getComponentNameFromFiber(fiber)||"Unknown",error$jscomp$0("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render",
fiber,lane,lane));break;case 1:didWarnAboutUpdateInRender||(error$jscomp$0("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."),didWarnAboutUpdateInRender=!0)}}else{isDevToolsPresent&&addFiberToLanesMap(root,fiber,lane);a:{if(fiber.mode&1){if(!isConcurrentActEnvironment())break a}else{var JSCompiler_inline_result="undefined"!==typeof IS_REACT_ACT_ENVIRONMENT?IS_REACT_ACT_ENVIRONMENT:void 0;var jestIsDefined="undefined"!==
typeof jest;JSCompiler_inline_result=warnsIfNotActing&&jestIsDefined&&!1!==JSCompiler_inline_result;if(!JSCompiler_inline_result||executionContext!==NoContext||0!==fiber.tag&&11!==fiber.tag&&15!==fiber.tag)break a}if(null===ReactCurrentActQueue$1.current){JSCompiler_inline_result=current$jscomp$1;try{setCurrentFiber(fiber),error$jscomp$0("An update to %s inside a test was not wrapped in act(...).\n\nWhen testing, code that causes React state updates should be wrapped into act(...):\n\nact(() \x3d\x3e {\n  /* fire events that update state */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act",
getComponentNameFromFiber(fiber))}finally{JSCompiler_inline_result?setCurrentFiber(fiber):resetCurrentFiber()}}}root===workInProgressRoot&&((executionContext&RenderContext)===NoContext&&(workInProgressRootInterleavedUpdatedLanes|=lane),workInProgressRootExitStatus===RootSuspendedWithDelay&&markRootSuspended$1(root,workInProgressRootRenderLanes));ensureRootIsScheduled(root,eventTime);1!==lane||executionContext!==NoContext||0!==(fiber.mode&1)||ReactCurrentActQueue$1.isBatchingLegacy||(resetRenderTimer(),
includesLegacySyncCallbacks&&flushSyncCallbacks())}return root}function markUpdateLaneFromFiberToRoot(sourceFiber,lane){sourceFiber.lanes|=lane;var alternate=sourceFiber.alternate;null!==alternate&&(alternate.lanes|=lane);null===alternate&&0!==(sourceFiber.flags&4098)&&warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);alternate=sourceFiber;for(var parent=sourceFiber.return;null!==parent;)parent.childLanes|=lane,alternate=parent.alternate,null!==alternate?alternate.childLanes|=lane:0!==(parent.flags&
4098)&&warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber),alternate=parent,parent=parent.return;return 3===alternate.tag?alternate.stateNode:null}function ensureRootIsScheduled(root,currentTime){var existingCallbackNode=root.callbackNode;markStarvedLanesAsExpired(root,currentTime);var nextLanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:0);if(0===nextLanes)null!==existingCallbackNode&&cancelCallback$1(existingCallbackNode),root.callbackNode=null,root.callbackPriority=
0;else{currentTime=nextLanes&-nextLanes;var existingCallbackPriority=root.callbackPriority;if(existingCallbackPriority!==currentTime||null!==ReactCurrentActQueue$1.current&&existingCallbackNode!==fakeActCallbackNode){null!=existingCallbackNode&&cancelCallback$1(existingCallbackNode);if(1===currentTime)0===root.tag?(null!==ReactCurrentActQueue$1.isBatchingLegacy&&(ReactCurrentActQueue$1.didScheduleLegacyUpdate=!0),scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null,root))):scheduleSyncCallback(performSyncWorkOnRoot.bind(null,
root)),supportsMicrotasks?null!==ReactCurrentActQueue$1.current?ReactCurrentActQueue$1.current.push(flushSyncCallbacks):scheduleMicrotask(function(){executionContext===NoContext&&flushSyncCallbacks()}):scheduleCallback$1(ImmediatePriority,flushSyncCallbacks),existingCallbackNode=null;else{switch(lanesToEventPriority(nextLanes)){case 1:existingCallbackNode=ImmediatePriority;break;case 4:existingCallbackNode=UserBlockingPriority;break;case 16:existingCallbackNode=NormalPriority;break;case 536870912:existingCallbackNode=
IdlePriority;break;default:existingCallbackNode=NormalPriority}existingCallbackNode=scheduleCallback$1(existingCallbackNode,performConcurrentWorkOnRoot.bind(null,root))}root.callbackPriority=currentTime;root.callbackNode=existingCallbackNode}else null==existingCallbackNode&&1!==existingCallbackPriority&&error$jscomp$0("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.")}}function performConcurrentWorkOnRoot(root,didTimeout){nestedUpdateScheduled=
currentUpdateIsNested=!1;currentEventTime=-1;currentEventTransitionLane=0;if((executionContext&(RenderContext|CommitContext))!==NoContext)throw Error("Should not already be working.");var originalCallbackNode=root.callbackNode;if(flushPassiveEffects()&&root.callbackNode!==originalCallbackNode)return null;var lanes=getNextLanes(root,root===workInProgressRoot?workInProgressRootRenderLanes:0);if(0===lanes)return null;if(0!==(lanes&30)||0!==(lanes&root.expiredLanes)||didTimeout)didTimeout=renderRootSync(root,
lanes);else{didTimeout=lanes;var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();if(workInProgressRoot!==root||workInProgressRootRenderLanes!==didTimeout){if(isDevToolsPresent){var memoizedUpdaters=root.memoizedUpdaters;0<memoizedUpdaters.size&&(restorePendingUpdaters(root,workInProgressRootRenderLanes),memoizedUpdaters.clear());movePendingFibersToMemoized(root,didTimeout)}resetRenderTimer();prepareFreshStack(root,didTimeout)}markRenderStarted(didTimeout);
do try{workLoopConcurrent();break}catch(thrownValue){handleError(root,thrownValue)}while(1);resetContextDependencies();ReactCurrentDispatcher$2.current=prevDispatcher;executionContext=prevExecutionContext;null!==workInProgress$jscomp$0?(null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markRenderYielded&&injectedProfilingHooks.markRenderYielded(),didTimeout=RootInProgress):(markRenderStopped(),workInProgressRoot=null,workInProgressRootRenderLanes=0,didTimeout=workInProgressRootExitStatus)}if(didTimeout!==
RootInProgress){didTimeout===RootErrored&&(prevExecutionContext=getLanesToRetrySynchronouslyOnError(root),0!==prevExecutionContext&&(lanes=prevExecutionContext,didTimeout=recoverFromConcurrentError(root,prevExecutionContext)));if(didTimeout===RootFatalErrored)throw originalCallbackNode=workInProgressRootFatalError,prepareFreshStack(root,0),markRootSuspended$1(root,lanes),ensureRootIsScheduled(root,now$1()),originalCallbackNode;if(didTimeout===RootDidNotComplete)markRootSuspended$1(root,lanes);else{prevExecutionContext=
root.current.alternate;if(0===(lanes&30)&&!isRenderConsistentWithExternalStores(prevExecutionContext)&&(didTimeout=renderRootSync(root,lanes),didTimeout===RootErrored&&(prevDispatcher=getLanesToRetrySynchronouslyOnError(root),0!==prevDispatcher&&(lanes=prevDispatcher,didTimeout=recoverFromConcurrentError(root,prevDispatcher))),didTimeout===RootFatalErrored))throw originalCallbackNode=workInProgressRootFatalError,prepareFreshStack(root,0),markRootSuspended$1(root,lanes),ensureRootIsScheduled(root,
now$1()),originalCallbackNode;root.finishedWork=prevExecutionContext;root.finishedLanes=lanes;switch(didTimeout){case RootInProgress:case RootFatalErrored:throw Error("Root did not complete. This is a bug in React.");case RootErrored:commitRoot(root,workInProgressRootRecoverableErrors);break;case RootSuspended:markRootSuspended$1(root,lanes);if((lanes&130023424)===lanes&&null===ReactCurrentActQueue$1.current&&(didTimeout=globalMostRecentFallbackTime+FALLBACK_THROTTLE_MS-now$1(),10<didTimeout)){if(0!==
getNextLanes(root,0))break;prevExecutionContext=root.suspendedLanes;if((prevExecutionContext&lanes)!==lanes){requestEventTime();root.pingedLanes|=root.suspendedLanes&prevExecutionContext;break}root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,root,workInProgressRootRecoverableErrors),didTimeout);break}commitRoot(root,workInProgressRootRecoverableErrors);break;case RootSuspendedWithDelay:markRootSuspended$1(root,lanes);if((lanes&4194240)===lanes)break;if(null===ReactCurrentActQueue$1.current){didTimeout=
root.eventTimes;for(prevExecutionContext=-1;0<lanes;)memoizedUpdaters=31-clz32(lanes),prevDispatcher=1<<memoizedUpdaters,memoizedUpdaters=didTimeout[memoizedUpdaters],memoizedUpdaters>prevExecutionContext&&(prevExecutionContext=memoizedUpdaters),lanes&=~prevDispatcher;lanes=prevExecutionContext;lanes=now$1()-lanes;lanes=(120>lanes?120:480>lanes?480:1080>lanes?1080:1920>lanes?1920:3E3>lanes?3E3:4320>lanes?4320:1960*ceil(lanes/1960))-lanes;if(10<lanes){root.timeoutHandle=scheduleTimeout(commitRoot.bind(null,
root,workInProgressRootRecoverableErrors),lanes);break}}commitRoot(root,workInProgressRootRecoverableErrors);break;case RootCompleted:commitRoot(root,workInProgressRootRecoverableErrors);break;default:throw Error("Unknown root exit status.");}}}ensureRootIsScheduled(root,now$1());return root.callbackNode===originalCallbackNode?performConcurrentWorkOnRoot.bind(null,root):null}function recoverFromConcurrentError(root,errorRetryLanes){var errorsFromFirstAttempt=workInProgressRootConcurrentErrors;root.current.memoizedState.isDehydrated&&
(prepareFreshStack(root,errorRetryLanes).flags|=256,errorHydratingContainer(root.containerInfo));root=renderRootSync(root,errorRetryLanes);root!==RootErrored&&(errorRetryLanes=workInProgressRootRecoverableErrors,workInProgressRootRecoverableErrors=errorsFromFirstAttempt,null!==errorRetryLanes&&queueRecoverableErrors(errorRetryLanes));return root}function queueRecoverableErrors(errors){null===workInProgressRootRecoverableErrors?workInProgressRootRecoverableErrors=errors:workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors,
errors)}function isRenderConsistentWithExternalStores(finishedWork){for(var node=finishedWork;;){if(node.flags&16384){var updateQueue=node.updateQueue;if(null!==updateQueue&&(updateQueue=updateQueue.stores,null!==updateQueue))for(var i=0;i<updateQueue.length;i++){var check=updateQueue[i],getSnapshot=check.getSnapshot;check=check.value;try{if(!objectIs(getSnapshot(),check))return!1}catch(error){return!1}}}updateQueue=node.child;if(node.subtreeFlags&16384&&null!==updateQueue)updateQueue.return=node,
node=updateQueue;else{if(node===finishedWork)break;for(;null===node.sibling;){if(null===node.return||node.return===finishedWork)return!0;node=node.return}node.sibling.return=node.return;node=node.sibling}}return!0}function markRootSuspended$1(root,suspendedLanes){suspendedLanes&=~workInProgressRootPingedLanes;suspendedLanes&=~workInProgressRootInterleavedUpdatedLanes;root.suspendedLanes|=suspendedLanes;root.pingedLanes&=~suspendedLanes;for(root=root.expirationTimes;0<suspendedLanes;){var index=31-
clz32(suspendedLanes),lane=1<<index;root[index]=-1;suspendedLanes&=~lane}}function performSyncWorkOnRoot(root){currentUpdateIsNested=nestedUpdateScheduled;nestedUpdateScheduled=!1;if((executionContext&(RenderContext|CommitContext))!==NoContext)throw Error("Should not already be working.");flushPassiveEffects();var lanes=getNextLanes(root,0);if(0===(lanes&1))return ensureRootIsScheduled(root,now$1()),null;var exitStatus=renderRootSync(root,lanes);if(0!==root.tag&&exitStatus===RootErrored){var errorRetryLanes=
getLanesToRetrySynchronouslyOnError(root);0!==errorRetryLanes&&(lanes=errorRetryLanes,exitStatus=recoverFromConcurrentError(root,errorRetryLanes))}if(exitStatus===RootFatalErrored)throw exitStatus=workInProgressRootFatalError,prepareFreshStack(root,0),markRootSuspended$1(root,lanes),ensureRootIsScheduled(root,now$1()),exitStatus;if(exitStatus===RootDidNotComplete)throw Error("Root did not complete. This is a bug in React.");root.finishedWork=root.current.alternate;root.finishedLanes=lanes;commitRoot(root,
workInProgressRootRecoverableErrors);ensureRootIsScheduled(root,now$1());return null}function flushRoot(root,lanes){0!==lanes&&(markRootEntangled(root,lanes|1),ensureRootIsScheduled(root,now$1()),(executionContext&(RenderContext|CommitContext))===NoContext&&(resetRenderTimer(),flushSyncCallbacks()))}function flushSync(fn){null!==rootWithPendingPassiveEffects&&0===rootWithPendingPassiveEffects.tag&&(executionContext&(RenderContext|CommitContext))===NoContext&&flushPassiveEffects();var prevExecutionContext=
executionContext;executionContext|=1;var prevTransition=ReactCurrentBatchConfig$2.transition,previousPriority=currentUpdatePriority;try{if(ReactCurrentBatchConfig$2.transition=null,currentUpdatePriority=1,fn)return fn()}finally{currentUpdatePriority=previousPriority,ReactCurrentBatchConfig$2.transition=prevTransition,executionContext=prevExecutionContext,(executionContext&(RenderContext|CommitContext))===NoContext&&flushSyncCallbacks()}}function pushRenderLanes(fiber,lanes){push(subtreeRenderLanesCursor,
subtreeRenderLanes,fiber);subtreeRenderLanes|=lanes}function popRenderLanes(fiber){subtreeRenderLanes=subtreeRenderLanesCursor.current;pop(subtreeRenderLanesCursor,fiber)}function prepareFreshStack(root,lanes){root.finishedWork=null;root.finishedLanes=0;var timeoutHandle=root.timeoutHandle;timeoutHandle!==noTimeout&&(root.timeoutHandle=noTimeout,cancelTimeout(timeoutHandle));if(null!==workInProgress$jscomp$0)for(timeoutHandle=workInProgress$jscomp$0.return;null!==timeoutHandle;)unwindInterruptedWork(timeoutHandle.alternate,
timeoutHandle),timeoutHandle=timeoutHandle.return;workInProgressRoot=root;workInProgress$jscomp$0=root=createWorkInProgress(root.current,null);workInProgressRootRenderLanes=subtreeRenderLanes=lanes;workInProgressRootExitStatus=RootInProgress;workInProgressRootFatalError=null;workInProgressRootPingedLanes=workInProgressRootInterleavedUpdatedLanes=workInProgressRootSkippedLanes=0;workInProgressRootRecoverableErrors=workInProgressRootConcurrentErrors=null;if(null!==interleavedQueues){for(lanes=0;lanes<
interleavedQueues.length;lanes++){timeoutHandle=interleavedQueues[lanes];var lastInterleavedUpdate=timeoutHandle.interleaved;if(null!==lastInterleavedUpdate){timeoutHandle.interleaved=null;var firstInterleavedUpdate=lastInterleavedUpdate.next,lastPendingUpdate=timeoutHandle.pending;if(null!==lastPendingUpdate){var firstPendingUpdate=lastPendingUpdate.next;lastPendingUpdate.next=firstInterleavedUpdate;lastInterleavedUpdate.next=firstPendingUpdate}timeoutHandle.pending=lastInterleavedUpdate}}interleavedQueues=
null}ReactStrictModeWarnings.discardPendingWarnings();return root}function handleError(root$jscomp$0,thrownValue){do{var erroredWork=workInProgress$jscomp$0;try{resetContextDependencies();resetHooksAfterThrow();resetCurrentFiber();ReactCurrentOwner$2.current=null;if(null===erroredWork||null===erroredWork.return){workInProgressRootExitStatus=RootFatalErrored;workInProgressRootFatalError=thrownValue;workInProgress$jscomp$0=null;break}erroredWork.mode&2&&stopProfilerTimerIfRunningAndRecordDelta(erroredWork,
!0);markComponentRenderStopped();if(null!==thrownValue&&"object"===typeof thrownValue&&"function"===typeof thrownValue.then){var wakeable=thrownValue;null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentSuspended&&injectedProfilingHooks.markComponentSuspended(erroredWork,wakeable,workInProgressRootRenderLanes)}else null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markComponentErrored&&injectedProfilingHooks.markComponentErrored(erroredWork,
thrownValue,workInProgressRootRenderLanes);a:{var root=root$jscomp$0,returnFiber=erroredWork.return,sourceFiber=erroredWork;wakeable=thrownValue;thrownValue=workInProgressRootRenderLanes;sourceFiber.flags|=32768;isDevToolsPresent&&restorePendingUpdaters(root,thrownValue);if(null!==wakeable&&"object"===typeof wakeable&&"function"===typeof wakeable.then){var wakeable$jscomp$0=wakeable,sourceFiber$jscomp$0=sourceFiber,tag=sourceFiber$jscomp$0.tag;if(0===(sourceFiber$jscomp$0.mode&1)&&(0===tag||11===
tag||15===tag)){var currentSource=sourceFiber$jscomp$0.alternate;currentSource?(sourceFiber$jscomp$0.updateQueue=currentSource.updateQueue,sourceFiber$jscomp$0.memoizedState=currentSource.memoizedState,sourceFiber$jscomp$0.lanes=currentSource.lanes):(sourceFiber$jscomp$0.updateQueue=null,sourceFiber$jscomp$0.memoizedState=null)}var suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(null!==suspenseBoundary){suspenseBoundary.flags&=-257;markSuspenseBoundaryShouldCapture(suspenseBoundary,
returnFiber,sourceFiber,root,thrownValue);suspenseBoundary.mode&1&&attachPingListener(root,wakeable$jscomp$0,thrownValue);thrownValue=suspenseBoundary;wakeable=wakeable$jscomp$0;var wakeables=thrownValue.updateQueue;if(null===wakeables){var updateQueue=new Set;updateQueue.add(wakeable);thrownValue.updateQueue=updateQueue}else wakeables.add(wakeable);break a}else{if(0===(thrownValue&1)){attachPingListener(root,wakeable$jscomp$0,thrownValue);renderDidSuspendDelayIfPossible();break a}wakeable=Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.")}}else if(isHydrating&&
sourceFiber.mode&1){didSuspend$jscomp$0=!0;var _suspenseBoundary=getNearestSuspenseBoundaryToCapture(returnFiber);if(null!==_suspenseBoundary){0===(_suspenseBoundary.flags&65536)&&(_suspenseBoundary.flags|=256);markSuspenseBoundaryShouldCapture(_suspenseBoundary,returnFiber,sourceFiber,root,thrownValue);queueHydrationError(wakeable);break a}}root=wakeable;workInProgressRootExitStatus!==RootSuspendedWithDelay&&(workInProgressRootExitStatus=RootErrored);null===workInProgressRootConcurrentErrors?workInProgressRootConcurrentErrors=
[root]:workInProgressRootConcurrentErrors.push(root);wakeable=createCapturedValue(wakeable,sourceFiber);sourceFiber=returnFiber;do{switch(sourceFiber.tag){case 3:sourceFiber.flags|=65536;thrownValue&=-thrownValue;sourceFiber.lanes|=thrownValue;var update=createRootErrorUpdate(sourceFiber,wakeable,thrownValue);enqueueCapturedUpdate(sourceFiber,update);break a;case 1:root=wakeable;var ctor=sourceFiber.type,instance=sourceFiber.stateNode;if(0===(sourceFiber.flags&128)&&("function"===typeof ctor.getDerivedStateFromError||
null!==instance&&"function"===typeof instance.componentDidCatch&&(null===legacyErrorBoundariesThatAlreadyFailed||!legacyErrorBoundariesThatAlreadyFailed.has(instance)))){sourceFiber.flags|=65536;thrownValue&=-thrownValue;sourceFiber.lanes|=thrownValue;var _update=createClassErrorUpdate(sourceFiber,root,thrownValue);enqueueCapturedUpdate(sourceFiber,_update);break a}}sourceFiber=sourceFiber.return}while(null!==sourceFiber)}completeUnitOfWork(erroredWork)}catch(yetAnotherThrownValue){thrownValue=yetAnotherThrownValue;
workInProgress$jscomp$0===erroredWork&&null!==erroredWork&&(workInProgress$jscomp$0=erroredWork=erroredWork.return);continue}break}while(1)}function pushDispatcher(){var prevDispatcher=ReactCurrentDispatcher$2.current;ReactCurrentDispatcher$2.current=ContextOnlyDispatcher;return null===prevDispatcher?ContextOnlyDispatcher:prevDispatcher}function renderDidSuspendDelayIfPossible(){if(workInProgressRootExitStatus===RootInProgress||workInProgressRootExitStatus===RootSuspended||workInProgressRootExitStatus===
RootErrored)workInProgressRootExitStatus=RootSuspendedWithDelay;null===workInProgressRoot||0===(workInProgressRootSkippedLanes&268435455)&&0===(workInProgressRootInterleavedUpdatedLanes&268435455)||markRootSuspended$1(workInProgressRoot,workInProgressRootRenderLanes)}function renderRootSync(root,lanes){var prevExecutionContext=executionContext;executionContext|=RenderContext;var prevDispatcher=pushDispatcher();if(workInProgressRoot!==root||workInProgressRootRenderLanes!==lanes){if(isDevToolsPresent){var memoizedUpdaters=
root.memoizedUpdaters;0<memoizedUpdaters.size&&(restorePendingUpdaters(root,workInProgressRootRenderLanes),memoizedUpdaters.clear());movePendingFibersToMemoized(root,lanes)}prepareFreshStack(root,lanes)}markRenderStarted(lanes);do try{workLoopSync();break}catch(thrownValue){handleError(root,thrownValue)}while(1);resetContextDependencies();executionContext=prevExecutionContext;ReactCurrentDispatcher$2.current=prevDispatcher;if(null!==workInProgress$jscomp$0)throw Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
markRenderStopped();workInProgressRoot=null;workInProgressRootRenderLanes=0;return workInProgressRootExitStatus}function workLoopSync(){for(;null!==workInProgress$jscomp$0;)performUnitOfWork(workInProgress$jscomp$0)}function workLoopConcurrent(){for(;null!==workInProgress$jscomp$0&&!shouldYield();)performUnitOfWork(workInProgress$jscomp$0)}function performUnitOfWork(unitOfWork){var current=unitOfWork.alternate;setCurrentFiber(unitOfWork);0!==(unitOfWork.mode&2)?(startProfilerTimer(unitOfWork),current=
beginWork$1(current,unitOfWork,subtreeRenderLanes),stopProfilerTimerIfRunningAndRecordDelta(unitOfWork,!0)):current=beginWork$1(current,unitOfWork,subtreeRenderLanes);resetCurrentFiber();unitOfWork.memoizedProps=unitOfWork.pendingProps;null===current?completeUnitOfWork(unitOfWork):workInProgress$jscomp$0=current;ReactCurrentOwner$2.current=null}function completeUnitOfWork(unitOfWork){var completedWork=unitOfWork;do{var current=completedWork.alternate;unitOfWork=completedWork.return;if(0===(completedWork.flags&
32768)){if(setCurrentFiber(completedWork),0===(completedWork.mode&2)?current=completeWork(current,completedWork,subtreeRenderLanes):(startProfilerTimer(completedWork),current=completeWork(current,completedWork,subtreeRenderLanes),stopProfilerTimerIfRunningAndRecordDelta(completedWork,!1)),resetCurrentFiber(),null!==current){workInProgress$jscomp$0=current;return}}else{current=unwindWork(current,completedWork);if(null!==current){current.flags&=32767;workInProgress$jscomp$0=current;return}if(0!==(completedWork.mode&
2)){stopProfilerTimerIfRunningAndRecordDelta(completedWork,!1);current=completedWork.actualDuration;for(var child=completedWork.child;null!==child;)current+=child.actualDuration,child=child.sibling;completedWork.actualDuration=current}if(null!==unitOfWork)unitOfWork.flags|=32768,unitOfWork.subtreeFlags=0,unitOfWork.deletions=null;else{workInProgressRootExitStatus=RootDidNotComplete;workInProgress$jscomp$0=null;return}}completedWork=completedWork.sibling;if(null!==completedWork){workInProgress$jscomp$0=
completedWork;return}workInProgress$jscomp$0=completedWork=unitOfWork}while(null!==completedWork);workInProgressRootExitStatus===RootInProgress&&(workInProgressRootExitStatus=RootCompleted)}function commitRoot(root,recoverableErrors){var previousUpdateLanePriority=currentUpdatePriority,prevTransition=ReactCurrentBatchConfig$2.transition;try{ReactCurrentBatchConfig$2.transition=null,currentUpdatePriority=1,commitRootImpl(root,recoverableErrors,previousUpdateLanePriority)}finally{ReactCurrentBatchConfig$2.transition=
prevTransition,currentUpdatePriority=previousUpdateLanePriority}return null}function commitRootImpl(root,recoverableErrors,renderPriorityLevel){do flushPassiveEffects();while(null!==rootWithPendingPassiveEffects);ReactStrictModeWarnings.flushLegacyContextWarning();ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();if((executionContext&(RenderContext|CommitContext))!==NoContext)throw Error("Should not already be working.");var finishedWork=root.finishedWork,lanes=root.finishedLanes;null!==
injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markCommitStarted&&injectedProfilingHooks.markCommitStarted(lanes);if(null===finishedWork)return markCommitStopped(),null;0===lanes&&error$jscomp$0("root.finishedLanes should not be empty during a commit. This is a bug in React.");root.finishedWork=null;root.finishedLanes=0;if(finishedWork===root.current)throw Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");root.callbackNode=
null;root.callbackPriority=0;var remainingLanes=finishedWork.lanes|finishedWork.childLanes;markRootFinished(root,remainingLanes);root===workInProgressRoot&&(workInProgress$jscomp$0=workInProgressRoot=null,workInProgressRootRenderLanes=0);0===(finishedWork.subtreeFlags&2064)&&0===(finishedWork.flags&2064)||rootDoesHavePassiveEffects||(rootDoesHavePassiveEffects=!0,scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null}));remainingLanes=0!==(finishedWork.flags&15990);if(0!==
(finishedWork.subtreeFlags&15990)||remainingLanes){remainingLanes=ReactCurrentBatchConfig$2.transition;ReactCurrentBatchConfig$2.transition=null;var previousPriority=currentUpdatePriority;currentUpdatePriority=1;var prevExecutionContext=executionContext;executionContext|=CommitContext;ReactCurrentOwner$2.current=null;commitBeforeMutationEffects(root,finishedWork);commitTime=now$2();commitMutationEffects(root,finishedWork,lanes);resetAfterCommit(root.containerInfo);root.current=finishedWork;null!==
injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markLayoutEffectsStarted&&injectedProfilingHooks.markLayoutEffectsStarted(lanes);commitLayoutEffects(finishedWork,root,lanes);null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markLayoutEffectsStopped&&injectedProfilingHooks.markLayoutEffectsStopped();requestPaint();executionContext=prevExecutionContext;currentUpdatePriority=previousPriority;ReactCurrentBatchConfig$2.transition=remainingLanes}else root.current=
finishedWork,commitTime=now$2();if(previousPriority=rootDoesHavePassiveEffects)rootDoesHavePassiveEffects=!1,rootWithPendingPassiveEffects=root,pendingPassiveEffectsLanes=lanes;remainingLanes=root.pendingLanes;0===remainingLanes&&(legacyErrorBoundariesThatAlreadyFailed=null);previousPriority||commitDoubleInvokeEffectsInDEV(root.current,!1);onCommitRoot(finishedWork.stateNode,renderPriorityLevel);isDevToolsPresent&&root.memoizedUpdaters.clear();onCommitRoot$1();ensureRootIsScheduled(root,now$1());
if(null!==recoverableErrors)for(renderPriorityLevel=root.onRecoverableError,finishedWork=0;finishedWork<recoverableErrors.length;finishedWork++)renderPriorityLevel(recoverableErrors[finishedWork]);if(hasUncaughtError)throw hasUncaughtError=!1,root=firstUncaughtError,firstUncaughtError=null,root;0!==(pendingPassiveEffectsLanes&1)&&0!==root.tag&&flushPassiveEffects();remainingLanes=root.pendingLanes;0!==(remainingLanes&1)?(nestedUpdateScheduled=!0,root===rootWithNestedUpdates?nestedUpdateCount++:(nestedUpdateCount=
0,rootWithNestedUpdates=root)):nestedUpdateCount=0;flushSyncCallbacks();markCommitStopped();return null}function flushPassiveEffects(){if(null!==rootWithPendingPassiveEffects){var renderPriority=lanesToEventPriority(pendingPassiveEffectsLanes),prevTransition=ReactCurrentBatchConfig$2.transition,previousPriority=currentUpdatePriority;try{ReactCurrentBatchConfig$2.transition=null;currentUpdatePriority=16>renderPriority?16:renderPriority;if(null===rootWithPendingPassiveEffects)var JSCompiler_inline_result=
!1;else{renderPriority=rootWithPendingPassiveEffects;var lanes=pendingPassiveEffectsLanes;rootWithPendingPassiveEffects=null;pendingPassiveEffectsLanes=0;if((executionContext&(RenderContext|CommitContext))!==NoContext)throw Error("Cannot flush passive effects while already rendering.");null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markPassiveEffectsStarted&&injectedProfilingHooks.markPassiveEffectsStarted(lanes);lanes=executionContext;executionContext|=CommitContext;for(nextEffect=
renderPriority.current;null!==nextEffect;){var fiber=nextEffect,child=fiber.child;if(0!==(nextEffect.flags&16)){var deletions=fiber.deletions;if(null!==deletions){for(var i=0;i<deletions.length;i++)for(var fiberToDelete=deletions[i],deletedSubtreeRoot=nextEffect=fiberToDelete,nearestMountedAncestor=fiber;null!==nextEffect;){var fiber$jscomp$0=nextEffect;setCurrentFiber(fiber$jscomp$0);var current=fiber$jscomp$0,nearestMountedAncestor$jscomp$0=nearestMountedAncestor;switch(current.tag){case 0:case 11:case 15:current.mode&
2?(passiveEffectStartTime=now$2(),commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor$jscomp$0),recordPassiveEffectDuration(current)):commitHookEffectListUnmount(Passive$1,current,nearestMountedAncestor$jscomp$0)}resetCurrentFiber();var child$jscomp$0=fiber$jscomp$0.child;if(null!==child$jscomp$0)ensureCorrectReturnPointer(child$jscomp$0,fiber$jscomp$0),nextEffect=child$jscomp$0;else for(fiber$jscomp$0=deletedSubtreeRoot;null!==nextEffect;){current=nextEffect;var sibling=current.sibling,
returnFiber=current.return;detachFiberAfterEffects(current);if(current===fiber$jscomp$0){nextEffect=null;break}if(null!==sibling){ensureCorrectReturnPointer(sibling,returnFiber);nextEffect=sibling;break}nextEffect=returnFiber}}var previousFiber=fiber.alternate;if(null!==previousFiber){var detachedChild=previousFiber.child;if(null!==detachedChild){previousFiber.child=null;do{var detachedSibling=detachedChild.sibling;detachedChild.sibling=null;detachedChild=detachedSibling}while(null!==detachedChild)}}nextEffect=
fiber}}if(0!==(fiber.subtreeFlags&2064)&&null!==child)ensureCorrectReturnPointer(child,fiber),nextEffect=child;else b:for(;null!==nextEffect;){fiber=nextEffect;if(0!==(fiber.flags&2048)){setCurrentFiber(fiber);i=fiber;switch(i.tag){case 0:case 11:case 15:i.mode&2?(passiveEffectStartTime=now$2(),commitHookEffectListUnmount(Passive$1|HasEffect,i,i.return),recordPassiveEffectDuration(i)):commitHookEffectListUnmount(Passive$1|HasEffect,i,i.return)}resetCurrentFiber()}var sibling$jscomp$0=fiber.sibling;
if(null!==sibling$jscomp$0){ensureCorrectReturnPointer(sibling$jscomp$0,fiber.return);nextEffect=sibling$jscomp$0;break b}nextEffect=fiber.return}}var finishedWork=renderPriority.current;for(nextEffect=finishedWork;null!==nextEffect;){child=nextEffect;var firstChild=child.child;if(0!==(child.subtreeFlags&2064)&&null!==firstChild)ensureCorrectReturnPointer(firstChild,child),nextEffect=firstChild;else b:for(child=finishedWork;null!==nextEffect;){deletions=nextEffect;if(0!==(deletions.flags&2048)){setCurrentFiber(deletions);
try{switch(fiberToDelete=deletions,fiberToDelete.tag){case 0:case 11:case 15:if(fiberToDelete.mode&2){passiveEffectStartTime=now$2();try{commitHookEffectListMount(Passive$1|HasEffect,fiberToDelete)}finally{recordPassiveEffectDuration(fiberToDelete)}}else commitHookEffectListMount(Passive$1|HasEffect,fiberToDelete)}}catch(error){reportUncaughtErrorInDEV(error),captureCommitPhaseError(deletions,deletions.return,error)}resetCurrentFiber()}if(deletions===child){nextEffect=null;break b}var sibling$jscomp$1=
deletions.sibling;if(null!==sibling$jscomp$1){ensureCorrectReturnPointer(sibling$jscomp$1,deletions.return);nextEffect=sibling$jscomp$1;break b}nextEffect=deletions.return}}finishedWork=pendingPassiveProfilerEffects;pendingPassiveProfilerEffects=[];for(firstChild=0;firstChild<finishedWork.length;firstChild++){var finishedWork$jscomp$0=finishedWork[firstChild];if(0!==(finishedWork$jscomp$0.flags&4))switch(finishedWork$jscomp$0.tag){case 12:var passiveEffectDuration=finishedWork$jscomp$0.stateNode.passiveEffectDuration,
_finishedWork$memoize=finishedWork$jscomp$0.memoizedProps,id=_finishedWork$memoize.id,onPostCommit=_finishedWork$memoize.onPostCommit;sibling$jscomp$1=commitTime;var phase=null===finishedWork$jscomp$0.alternate?"mount":"update";currentUpdateIsNested&&(phase="nested-update");"function"===typeof onPostCommit&&onPostCommit(id,phase,passiveEffectDuration,sibling$jscomp$1);var parentFiber=finishedWork$jscomp$0.return;b:for(;null!==parentFiber;){switch(parentFiber.tag){case 3:parentFiber.stateNode.passiveEffectDuration+=
passiveEffectDuration;break b;case 12:parentFiber.stateNode.passiveEffectDuration+=passiveEffectDuration;break b}parentFiber=parentFiber.return}}}null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markPassiveEffectsStopped&&injectedProfilingHooks.markPassiveEffectsStopped();commitDoubleInvokeEffectsInDEV(renderPriority.current,!0);executionContext=lanes;flushSyncCallbacks();nestedPassiveUpdateCount=null===rootWithPendingPassiveEffects?0:nestedPassiveUpdateCount+1;if(injectedHook&&
"function"===typeof injectedHook.onPostCommitFiberRoot)try{injectedHook.onPostCommitFiberRoot(rendererID,renderPriority)}catch(err){hasLoggedError||(hasLoggedError=!0,error$jscomp$0("React instrumentation encountered an error: %s",err))}var stateNode=renderPriority.current.stateNode;stateNode.effectDuration=0;stateNode.passiveEffectDuration=0;JSCompiler_inline_result=!0}return JSCompiler_inline_result}finally{currentUpdatePriority=previousPriority,ReactCurrentBatchConfig$2.transition=prevTransition}}return!1}
function enqueuePendingPassiveProfilerEffect(fiber){pendingPassiveProfilerEffects.push(fiber);rootDoesHavePassiveEffects||(rootDoesHavePassiveEffects=!0,scheduleCallback$1(NormalPriority,function(){flushPassiveEffects();return null}))}function captureCommitPhaseErrorOnRoot(rootFiber,sourceFiber,error){sourceFiber=createCapturedValue(error,sourceFiber);sourceFiber=createRootErrorUpdate(rootFiber,sourceFiber,1);enqueueUpdate(rootFiber,sourceFiber);sourceFiber=requestEventTime();rootFiber=markUpdateLaneFromFiberToRoot(rootFiber,
1);null!==rootFiber&&(markRootUpdated(rootFiber,1,sourceFiber),ensureRootIsScheduled(rootFiber,sourceFiber))}function captureCommitPhaseError(sourceFiber,nearestMountedAncestor,error$1){if(3===sourceFiber.tag)captureCommitPhaseErrorOnRoot(sourceFiber,sourceFiber,error$1);else{for(;null!==nearestMountedAncestor;){if(3===nearestMountedAncestor.tag){captureCommitPhaseErrorOnRoot(nearestMountedAncestor,sourceFiber,error$1);return}if(1===nearestMountedAncestor.tag){var instance=nearestMountedAncestor.stateNode;
if("function"===typeof nearestMountedAncestor.type.getDerivedStateFromError||"function"===typeof instance.componentDidCatch&&(null===legacyErrorBoundariesThatAlreadyFailed||!legacyErrorBoundariesThatAlreadyFailed.has(instance))){sourceFiber=createCapturedValue(error$1,sourceFiber);sourceFiber=createClassErrorUpdate(nearestMountedAncestor,sourceFiber,1);enqueueUpdate(nearestMountedAncestor,sourceFiber);sourceFiber=requestEventTime();nearestMountedAncestor=markUpdateLaneFromFiberToRoot(nearestMountedAncestor,
1);null!==nearestMountedAncestor&&(markRootUpdated(nearestMountedAncestor,1,sourceFiber),ensureRootIsScheduled(nearestMountedAncestor,sourceFiber));return}}nearestMountedAncestor=nearestMountedAncestor.return}error$jscomp$0("Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.\n\nError message:\n\n%s",
error$1)}}function pingSuspendedRoot(root,wakeable,pingedLanes){var pingCache=root.pingCache;null!==pingCache&&pingCache.delete(wakeable);wakeable=requestEventTime();root.pingedLanes|=root.suspendedLanes&pingedLanes;0!==root.tag&&isConcurrentActEnvironment()&&null===ReactCurrentActQueue$1.current&&error$jscomp$0("A suspended resource finished loading inside a test, but the event was not wrapped in act(...).\n\nWhen testing, code that resolves suspended data should be wrapped into act(...):\n\nact(() \x3d\x3e {\n  /* finish loading suspended data */\n});\n/* assert on the output */\n\nThis ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act");
workInProgressRoot===root&&(workInProgressRootRenderLanes&pingedLanes)===pingedLanes&&(workInProgressRootExitStatus===RootSuspendedWithDelay||workInProgressRootExitStatus===RootSuspended&&(workInProgressRootRenderLanes&130023424)===workInProgressRootRenderLanes&&now$1()-globalMostRecentFallbackTime<FALLBACK_THROTTLE_MS?prepareFreshStack(root,0):workInProgressRootPingedLanes|=pingedLanes);ensureRootIsScheduled(root,wakeable)}function retryTimedOutBoundary(boundaryFiber,retryLane){0===retryLane&&(0===
(boundaryFiber.mode&1)?retryLane=1:(retryLane=nextRetryLane,nextRetryLane<<=1,0===(nextRetryLane&130023424)&&(nextRetryLane=4194304)));var eventTime=requestEventTime();boundaryFiber=markUpdateLaneFromFiberToRoot(boundaryFiber,retryLane);null!==boundaryFiber&&(markRootUpdated(boundaryFiber,retryLane,eventTime),ensureRootIsScheduled(boundaryFiber,eventTime))}function retryDehydratedSuspenseBoundary(boundaryFiber){var suspenseState=boundaryFiber.memoizedState,retryLane=0;null!==suspenseState&&(retryLane=
suspenseState.retryLane);retryTimedOutBoundary(boundaryFiber,retryLane)}function resolveRetryWakeable(boundaryFiber,wakeable){var retryLane=0;switch(boundaryFiber.tag){case 13:var retryCache=boundaryFiber.stateNode;var suspenseState=boundaryFiber.memoizedState;null!==suspenseState&&(retryLane=suspenseState.retryLane);break;case 19:retryCache=boundaryFiber.stateNode;break;default:throw Error("Pinged unknown suspense boundary type. This is probably a bug in React.");}null!==retryCache&&retryCache.delete(wakeable);
retryTimedOutBoundary(boundaryFiber,retryLane)}function commitDoubleInvokeEffectsInDEV(fiber,hasPassiveEffects){setCurrentFiber(fiber);invokeEffectsInDev(fiber,16777216,invokeLayoutEffectUnmountInDEV);hasPassiveEffects&&invokeEffectsInDev(fiber,33554432,invokePassiveEffectUnmountInDEV);invokeEffectsInDev(fiber,16777216,invokeLayoutEffectMountInDEV);hasPassiveEffects&&invokeEffectsInDev(fiber,33554432,invokePassiveEffectMountInDEV);resetCurrentFiber()}function invokeEffectsInDev(firstChild,fiberFlags,
invokeEffectFn){for(var subtreeRoot=null;null!==firstChild;){var primarySubtreeFlag=firstChild.subtreeFlags&fiberFlags;firstChild!==subtreeRoot&&null!==firstChild.child&&0!==primarySubtreeFlag?firstChild=firstChild.child:(0!==(firstChild.flags&fiberFlags)&&invokeEffectFn(firstChild),firstChild=null!==firstChild.sibling?firstChild.sibling:subtreeRoot=firstChild.return)}}function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber){if((executionContext&RenderContext)===NoContext&&fiber.mode&1){var tag=fiber.tag;
if(2===tag||3===tag||1===tag||0===tag||11===tag||14===tag||15===tag){tag=getComponentNameFromFiber(fiber)||"ReactComponent";if(null!==didWarnStateUpdateForNotYetMountedComponent){if(didWarnStateUpdateForNotYetMountedComponent.has(tag))return;didWarnStateUpdateForNotYetMountedComponent.add(tag)}else didWarnStateUpdateForNotYetMountedComponent=new Set([tag]);tag=current$jscomp$1;try{setCurrentFiber(fiber),error$jscomp$0("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.")}finally{tag?
setCurrentFiber(fiber):resetCurrentFiber()}}}}function restorePendingUpdaters(root,lanes){isDevToolsPresent&&root.memoizedUpdaters.forEach(function(schedulingFiber){addFiberToLanesMap(root,schedulingFiber,lanes)})}function scheduleCallback$1(priorityLevel,callback){var actQueue=ReactCurrentActQueue$1.current;return null!==actQueue?(actQueue.push(callback),fakeActCallbackNode):scheduleCallback(priorityLevel,callback)}function cancelCallback$1(callbackNode){if(callbackNode!==fakeActCallbackNode)return cancelCallback(callbackNode)}
function resolveFunctionForHotReloading(type){if(null===resolveFamily)return type;var family=resolveFamily(type);return void 0===family?type:family.current}function resolveForwardRefForHotReloading(type){if(null===resolveFamily)return type;var family=resolveFamily(type);return void 0===family?null!==type&&void 0!==type&&"function"===typeof type.render&&(family=resolveFunctionForHotReloading(type.render),type.render!==family)?(family={$$typeof:REACT_FORWARD_REF_TYPE,render:family},void 0!==type.displayName&&
(family.displayName=type.displayName),family):type:family.current}function isCompatibleFamilyForHotReloading(fiber,element){if(null===resolveFamily)return!1;var prevType=fiber.elementType;element=element.type;var needsCompareFamilies=!1,$$typeofNextType="object"===typeof element&&null!==element?element.$$typeof:null;switch(fiber.tag){case 1:"function"===typeof element&&(needsCompareFamilies=!0);break;case 0:"function"===typeof element?needsCompareFamilies=!0:$$typeofNextType===REACT_LAZY_TYPE&&(needsCompareFamilies=
!0);break;case 11:$$typeofNextType===REACT_FORWARD_REF_TYPE?needsCompareFamilies=!0:$$typeofNextType===REACT_LAZY_TYPE&&(needsCompareFamilies=!0);break;case 14:case 15:$$typeofNextType===REACT_MEMO_TYPE?needsCompareFamilies=!0:$$typeofNextType===REACT_LAZY_TYPE&&(needsCompareFamilies=!0);break;default:return!1}return needsCompareFamilies&&(fiber=resolveFamily(prevType),void 0!==fiber&&fiber===resolveFamily(element))?!0:!1}function markFailedErrorBoundaryForHotReloading(fiber){null!==resolveFamily&&
"function"===typeof WeakSet&&(null===failedBoundaries&&(failedBoundaries=new WeakSet),failedBoundaries.add(fiber))}function scheduleFibersWithFamiliesRecursively(fiber,updatedFamilies,staleFamilies){var alternate=fiber.alternate,child=fiber.child,sibling=fiber.sibling,tag=fiber.tag,type=fiber.type,candidateType=null;switch(tag){case 0:case 15:case 1:candidateType=type;break;case 11:candidateType=type.render}if(null===resolveFamily)throw Error("Expected resolveFamily to be set during hot reload.");
var needsRemount=type=!1;null!==candidateType&&(candidateType=resolveFamily(candidateType),void 0!==candidateType&&(staleFamilies.has(candidateType)?needsRemount=!0:updatedFamilies.has(candidateType)&&(1===tag?needsRemount=!0:type=!0)));null!==failedBoundaries&&(failedBoundaries.has(fiber)||null!==alternate&&failedBoundaries.has(alternate))&&(needsRemount=!0);needsRemount&&(fiber._debugNeedsRemount=!0);(needsRemount||type)&&scheduleUpdateOnFiber(fiber,1,-1);null===child||needsRemount||scheduleFibersWithFamiliesRecursively(child,
updatedFamilies,staleFamilies);null!==sibling&&scheduleFibersWithFamiliesRecursively(sibling,updatedFamilies,staleFamilies)}function findHostInstancesForMatchingFibersRecursively(fiber,types,hostInstances){var child=fiber.child,sibling=fiber.sibling,type=fiber.type,candidateType=null;switch(fiber.tag){case 0:case 15:case 1:candidateType=type;break;case 11:candidateType=type.render}type=!1;null!==candidateType&&types.has(candidateType)&&(type=!0);if(type)a:{b:for(child=fiber,candidateType=!1;;){if(5===
child.tag)candidateType=!0,hostInstances.add(child.stateNode);else if(null!==child.child){child.child.return=child;child=child.child;continue}if(child===fiber){child=candidateType;break b}for(;null===child.sibling;){if(null===child.return||child.return===fiber){child=candidateType;break b}child=child.return}child.sibling.return=child.return;child=child.sibling}if(!child)for(;;){switch(fiber.tag){case 5:hostInstances.add(fiber.stateNode);break a;case 4:hostInstances.add(fiber.stateNode.containerInfo);
break a;case 3:hostInstances.add(fiber.stateNode.containerInfo);break a}if(null===fiber.return)throw Error("Expected to reach root first.");fiber=fiber.return}}else null!==child&&findHostInstancesForMatchingFibersRecursively(child,types,hostInstances);null!==sibling&&findHostInstancesForMatchingFibersRecursively(sibling,types,hostInstances)}function FiberNode(tag,pendingProps,key,mode){this.tag=tag;this.key=key;this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null;this.index=
0;this.ref=null;this.pendingProps=pendingProps;this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null;this.mode=mode;this.subtreeFlags=this.flags=0;this.deletions=null;this.childLanes=this.lanes=0;this.alternate=null;this.actualDuration=0;this.actualStartTime=-1;this.treeBaseDuration=this.selfBaseDuration=0;this._debugOwner=this._debugSource=null;this._debugNeedsRemount=!1;this._debugHookTypes=null;hasBadMapPolyfill||"function"!==typeof Object.preventExtensions||Object.preventExtensions(this)}
function shouldConstruct$1(Component){Component=Component.prototype;return!(!Component||!Component.isReactComponent)}function resolveLazyComponentTag(Component){if("function"===typeof Component)return shouldConstruct$1(Component)?1:0;if(void 0!==Component&&null!==Component){Component=Component.$$typeof;if(Component===REACT_FORWARD_REF_TYPE)return 11;if(Component===REACT_MEMO_TYPE)return 14}return 2}function createWorkInProgress(current,pendingProps){var workInProgress=current.alternate;null===workInProgress?
(workInProgress=createFiber(current.tag,pendingProps,current.key,current.mode),workInProgress.elementType=current.elementType,workInProgress.type=current.type,workInProgress.stateNode=current.stateNode,workInProgress._debugSource=current._debugSource,workInProgress._debugOwner=current._debugOwner,workInProgress._debugHookTypes=current._debugHookTypes,workInProgress.alternate=current,current.alternate=workInProgress):(workInProgress.pendingProps=pendingProps,workInProgress.type=current.type,workInProgress.flags=
0,workInProgress.subtreeFlags=0,workInProgress.deletions=null,workInProgress.actualDuration=0,workInProgress.actualStartTime=-1);workInProgress.flags=current.flags&14680064;workInProgress.childLanes=current.childLanes;workInProgress.lanes=current.lanes;workInProgress.child=current.child;workInProgress.memoizedProps=current.memoizedProps;workInProgress.memoizedState=current.memoizedState;workInProgress.updateQueue=current.updateQueue;pendingProps=current.dependencies;workInProgress.dependencies=null===
pendingProps?null:{lanes:pendingProps.lanes,firstContext:pendingProps.firstContext};workInProgress.sibling=current.sibling;workInProgress.index=current.index;workInProgress.ref=current.ref;workInProgress.selfBaseDuration=current.selfBaseDuration;workInProgress.treeBaseDuration=current.treeBaseDuration;workInProgress._debugNeedsRemount=current._debugNeedsRemount;switch(workInProgress.tag){case 2:case 0:case 15:workInProgress.type=resolveFunctionForHotReloading(current.type);break;case 1:workInProgress.type=
resolveFunctionForHotReloading(current.type);break;case 11:workInProgress.type=resolveForwardRefForHotReloading(current.type)}return workInProgress}function createFiberFromTypeAndProps(type,key,pendingProps,owner,mode,lanes){var fiberTag=2,resolvedType=type;if("function"===typeof type)shouldConstruct$1(type)&&(fiberTag=1),resolvedType=resolveFunctionForHotReloading(resolvedType);else if("string"===typeof type)fiberTag=5;else a:switch(type){case REACT_FRAGMENT_TYPE:return createFiberFromFragment(pendingProps.children,
mode,lanes,key);case REACT_STRICT_MODE_TYPE:fiberTag=8;mode|=8;0!==(mode&1)&&(mode|=16);break;case REACT_PROFILER_TYPE:return type=mode,"string"!==typeof pendingProps.id&&error$jscomp$0('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.',typeof pendingProps.id),type=createFiber(12,pendingProps,key,type|2),type.elementType=REACT_PROFILER_TYPE,type.lanes=lanes,type.stateNode={effectDuration:0,passiveEffectDuration:0},type;case REACT_SUSPENSE_TYPE:return type=
createFiber(13,pendingProps,key,mode),type.elementType=REACT_SUSPENSE_TYPE,type.lanes=lanes,type;case REACT_SUSPENSE_LIST_TYPE:return type=createFiber(19,pendingProps,key,mode),type.elementType=REACT_SUSPENSE_LIST_TYPE,type.lanes=lanes,type;case REACT_OFFSCREEN_TYPE:return createFiberFromOffscreen(pendingProps,mode,lanes,key);default:if("object"===typeof type&&null!==type)switch(type.$$typeof){case REACT_PROVIDER_TYPE:fiberTag=10;break a;case REACT_CONTEXT_TYPE:fiberTag=9;break a;case REACT_FORWARD_REF_TYPE:fiberTag=
11;resolvedType=resolveForwardRefForHotReloading(resolvedType);break a;case REACT_MEMO_TYPE:fiberTag=14;break a;case REACT_LAZY_TYPE:fiberTag=16;resolvedType=null;break a}lanes="";if(void 0===type||"object"===typeof type&&null!==type&&0===Object.keys(type).length)lanes+=" You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.";(owner=owner?getComponentNameFromFiber(owner):null)&&(lanes+="\n\nCheck the render method of `"+owner+
"`.");throw Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) but got: "+((null==type?type:typeof type)+"."+lanes));}key=createFiber(fiberTag,pendingProps,key,mode);key.elementType=type;key.type=resolvedType;key.lanes=lanes;key._debugOwner=owner;return key}function createFiberFromElement(element,mode,lanes){mode=createFiberFromTypeAndProps(element.type,element.key,element.props,element._owner,mode,lanes);mode._debugSource=element._source;
mode._debugOwner=element._owner;return mode}function createFiberFromFragment(elements,mode,lanes,key){elements=createFiber(7,elements,key,mode);elements.lanes=lanes;return elements}function createFiberFromOffscreen(pendingProps,mode,lanes,key){pendingProps=createFiber(22,pendingProps,key,mode);pendingProps.elementType=REACT_OFFSCREEN_TYPE;pendingProps.lanes=lanes;pendingProps.stateNode={};return pendingProps}function createFiberFromText(content,mode,lanes){content=createFiber(6,content,null,mode);
content.lanes=lanes;return content}function createFiberFromPortal(portal,mode,lanes){mode=createFiber(4,null!==portal.children?portal.children:[],portal.key,mode);mode.lanes=lanes;mode.stateNode={containerInfo:portal.containerInfo,pendingChildren:null,implementation:portal.implementation};return mode}function assignFiberPropertiesInDEV(target,source){null===target&&(target=createFiber(2,null,null,0));target.tag=source.tag;target.key=source.key;target.elementType=source.elementType;target.type=source.type;
target.stateNode=source.stateNode;target.return=source.return;target.child=source.child;target.sibling=source.sibling;target.index=source.index;target.ref=source.ref;target.pendingProps=source.pendingProps;target.memoizedProps=source.memoizedProps;target.updateQueue=source.updateQueue;target.memoizedState=source.memoizedState;target.dependencies=source.dependencies;target.mode=source.mode;target.flags=source.flags;target.subtreeFlags=source.subtreeFlags;target.deletions=source.deletions;target.lanes=
source.lanes;target.childLanes=source.childLanes;target.alternate=source.alternate;target.actualDuration=source.actualDuration;target.actualStartTime=source.actualStartTime;target.selfBaseDuration=source.selfBaseDuration;target.treeBaseDuration=source.treeBaseDuration;target._debugSource=source._debugSource;target._debugOwner=source._debugOwner;target._debugNeedsRemount=source._debugNeedsRemount;target._debugHookTypes=source._debugHookTypes;return target}function FiberRootNode(containerInfo,tag,hydrate,
identifierPrefix,onRecoverableError){this.tag=tag;this.containerInfo=containerInfo;this.finishedWork=this.pingCache=this.current=this.pendingChildren=null;this.timeoutHandle=noTimeout;this.callbackNode=this.pendingContext=this.context=null;this.callbackPriority=0;this.eventTimes=createLaneMap(0);this.expirationTimes=createLaneMap(-1);this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0;this.entanglements=createLaneMap(0);
this.identifierPrefix=identifierPrefix;this.onRecoverableError=onRecoverableError;supportsHydration&&(this.mutableSourceEagerHydrationData=null);this.passiveEffectDuration=this.effectDuration=0;this.memoizedUpdaters=new Set;containerInfo=this.pendingUpdatersLaneMap=[];for(identifierPrefix=0;31>identifierPrefix;identifierPrefix++)containerInfo.push(new Set);switch(tag){case 1:this._debugRootType=hydrate?"hydrateRoot()":"createRoot()";break;case 0:this._debugRootType=hydrate?"hydrate()":"render()"}}
function createFiberRoot(containerInfo,tag,hydrate,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){containerInfo=new FiberRootNode(containerInfo,tag,hydrate,identifierPrefix,onRecoverableError);1===tag?(tag=1,!0===isStrictMode&&(tag|=24)):tag=0;isDevToolsPresent&&(tag|=2);isStrictMode=createFiber(3,null,null,tag);containerInfo.current=isStrictMode;isStrictMode.stateNode=containerInfo;isStrictMode.memoizedState=
{element:initialChildren,isDehydrated:hydrate,cache:null,transitions:null};initializeUpdateQueue(isStrictMode);return containerInfo}function getContextForSubtree(parentComponent){if(!parentComponent)return emptyContextObject;parentComponent=parentComponent._reactInternals;a:{if(getNearestMountedFiber(parentComponent)!==parentComponent||1!==parentComponent.tag)throw Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
var parentContext=parentComponent;do{switch(parentContext.tag){case 3:parentContext=parentContext.stateNode.context;break a;case 1:if(isContextProvider(parentContext.type)){parentContext=parentContext.stateNode.__reactInternalMemoizedMergedChildContext;break a}}parentContext=parentContext.return}while(null!==parentContext);throw Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");}if(1===parentComponent.tag){var Component=parentComponent.type;
if(isContextProvider(Component))return processChildContext(parentComponent,Component,parentContext)}return parentContext}function updateContainer(element,container,parentComponent,callback){if(injectedHook&&"function"===typeof injectedHook.onScheduleFiberRoot)try{injectedHook.onScheduleFiberRoot(rendererID,container,element)}catch(err){hasLoggedError||(hasLoggedError=!0,error$jscomp$0("React instrumentation encountered an error: %s",err))}var current$1=container.current,eventTime=requestEventTime(),
lane=requestUpdateLane(current$1);null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markRenderScheduled&&injectedProfilingHooks.markRenderScheduled(lane);parentComponent=getContextForSubtree(parentComponent);null===container.context?container.context=parentComponent:container.pendingContext=parentComponent;isRendering&&null!==current$jscomp$1&&!didWarnAboutNestedUpdates&&(didWarnAboutNestedUpdates=!0,error$jscomp$0("Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.\n\nCheck the render method of %s.",
getComponentNameFromFiber(current$jscomp$1)||"Unknown"));container=createUpdate(eventTime,lane);container.payload={element};callback=void 0===callback?null:callback;null!==callback&&("function"!==typeof callback&&error$jscomp$0("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callback),container.callback=callback);enqueueUpdate(current$1,container);element=scheduleUpdateOnFiber(current$1,lane,eventTime);null!==element&&entangleTransitions(element,
current$1,lane);return lane}function markRetryLaneImpl(fiber,retryLane){fiber=fiber.memoizedState;if(null!==fiber&&null!==fiber.dehydrated){var a=fiber.retryLane;fiber.retryLane=0!==a&&a<retryLane?a:retryLane}}function markRetryLaneIfNotHydrated(fiber,retryLane){markRetryLaneImpl(fiber,retryLane);(fiber=fiber.alternate)&&markRetryLaneImpl(fiber,retryLane)}function findHostInstanceByFiber(fiber){fiber=findCurrentHostFiber(fiber);return null===fiber?null:fiber.stateNode}function emptyFindFiberByHostInstance(instance){return null}
function getCurrentFiberForDevTools(){return current$jscomp$1}var exports={};"use strict";var React=require("module$node_modules$react$index"),Scheduler=require("module$node_modules$react_reconciler$node_modules$scheduler$index"),ReactSharedInternals=React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,suppressWarning=!1,assign=Object.assign,REACT_ELEMENT_TYPE=Symbol.for("react.element"),REACT_PORTAL_TYPE=Symbol.for("react.portal"),REACT_FRAGMENT_TYPE=Symbol.for("react.fragment"),REACT_STRICT_MODE_TYPE=
Symbol.for("react.strict_mode"),REACT_PROFILER_TYPE=Symbol.for("react.profiler"),REACT_PROVIDER_TYPE=Symbol.for("react.provider"),REACT_CONTEXT_TYPE=Symbol.for("react.context"),REACT_FORWARD_REF_TYPE=Symbol.for("react.forward_ref"),REACT_SUSPENSE_TYPE=Symbol.for("react.suspense"),REACT_SUSPENSE_LIST_TYPE=Symbol.for("react.suspense_list"),REACT_MEMO_TYPE=Symbol.for("react.memo"),REACT_LAZY_TYPE=Symbol.for("react.lazy");Symbol.for("react.scope");Symbol.for("react.debug_trace_mode");var REACT_OFFSCREEN_TYPE=
Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden");Symbol.for("react.cache");Symbol.for("react.tracing_marker");var MAYBE_ITERATOR_SYMBOL=Symbol.iterator,ReactCurrentOwner=ReactSharedInternals.ReactCurrentOwner,isArrayImpl=Array.isArray,getPublicInstance=$$$hostConfig.getPublicInstance,getRootHostContext=$$$hostConfig.getRootHostContext,getChildHostContext=$$$hostConfig.getChildHostContext,prepareForCommit=$$$hostConfig.prepareForCommit,resetAfterCommit=$$$hostConfig.resetAfterCommit,
createInstance=$$$hostConfig.createInstance,appendInitialChild=$$$hostConfig.appendInitialChild,finalizeInitialChildren=$$$hostConfig.finalizeInitialChildren,prepareUpdate=$$$hostConfig.prepareUpdate,shouldSetTextContent=$$$hostConfig.shouldSetTextContent,createTextInstance=$$$hostConfig.createTextInstance,scheduleTimeout=$$$hostConfig.scheduleTimeout,cancelTimeout=$$$hostConfig.cancelTimeout,noTimeout=$$$hostConfig.noTimeout,isPrimaryRenderer=$$$hostConfig.isPrimaryRenderer,warnsIfNotActing=$$$hostConfig.warnsIfNotActing,
supportsMutation=$$$hostConfig.supportsMutation,supportsPersistence=$$$hostConfig.supportsPersistence,supportsHydration=$$$hostConfig.supportsHydration,getInstanceFromNode=$$$hostConfig.getInstanceFromNode,preparePortalMount=$$$hostConfig.preparePortalMount,getCurrentEventPriority=$$$hostConfig.getCurrentEventPriority,detachDeletedInstance=$$$hostConfig.detachDeletedInstance,supportsMicrotasks=$$$hostConfig.supportsMicrotasks,scheduleMicrotask=$$$hostConfig.scheduleMicrotask,supportsTestSelectors=
$$$hostConfig.supportsTestSelectors,findFiberRoot=$$$hostConfig.findFiberRoot,getBoundingRect=$$$hostConfig.getBoundingRect,getTextContent=$$$hostConfig.getTextContent,isHiddenSubtree=$$$hostConfig.isHiddenSubtree,matchAccessibilityRole=$$$hostConfig.matchAccessibilityRole,setFocusIfFocusable=$$$hostConfig.setFocusIfFocusable,setupIntersectionObserver=$$$hostConfig.setupIntersectionObserver,appendChild=$$$hostConfig.appendChild,appendChildToContainer=$$$hostConfig.appendChildToContainer,commitTextUpdate=
$$$hostConfig.commitTextUpdate,commitMount=$$$hostConfig.commitMount,commitUpdate=$$$hostConfig.commitUpdate,insertBefore=$$$hostConfig.insertBefore,insertInContainerBefore=$$$hostConfig.insertInContainerBefore,removeChild=$$$hostConfig.removeChild,removeChildFromContainer=$$$hostConfig.removeChildFromContainer,resetTextContent=$$$hostConfig.resetTextContent,hideInstance=$$$hostConfig.hideInstance,hideTextInstance=$$$hostConfig.hideTextInstance,unhideInstance=$$$hostConfig.unhideInstance,unhideTextInstance=
$$$hostConfig.unhideTextInstance,clearContainer=$$$hostConfig.clearContainer,cloneInstance=$$$hostConfig.cloneInstance,createContainerChildSet=$$$hostConfig.createContainerChildSet,appendChildToContainerChildSet=$$$hostConfig.appendChildToContainerChildSet,finalizeContainerChildren=$$$hostConfig.finalizeContainerChildren,replaceContainerChildren=$$$hostConfig.replaceContainerChildren,cloneHiddenInstance=$$$hostConfig.cloneHiddenInstance,cloneHiddenTextInstance=$$$hostConfig.cloneHiddenTextInstance,
canHydrateInstance=$$$hostConfig.canHydrateInstance,canHydrateTextInstance=$$$hostConfig.canHydrateTextInstance,canHydrateSuspenseInstance=$$$hostConfig.canHydrateSuspenseInstance,isSuspenseInstancePending=$$$hostConfig.isSuspenseInstancePending,isSuspenseInstanceFallback=$$$hostConfig.isSuspenseInstanceFallback,registerSuspenseInstanceRetry=$$$hostConfig.registerSuspenseInstanceRetry,getNextHydratableSibling=$$$hostConfig.getNextHydratableSibling,getFirstHydratableChild=$$$hostConfig.getFirstHydratableChild,
getFirstHydratableChildWithinContainer=$$$hostConfig.getFirstHydratableChildWithinContainer,getFirstHydratableChildWithinSuspenseInstance=$$$hostConfig.getFirstHydratableChildWithinSuspenseInstance,hydrateInstance=$$$hostConfig.hydrateInstance,hydrateTextInstance=$$$hostConfig.hydrateTextInstance,hydrateSuspenseInstance=$$$hostConfig.hydrateSuspenseInstance,getNextHydratableInstanceAfterSuspenseInstance=$$$hostConfig.getNextHydratableInstanceAfterSuspenseInstance,commitHydratedContainer=$$$hostConfig.commitHydratedContainer,
commitHydratedSuspenseInstance=$$$hostConfig.commitHydratedSuspenseInstance,clearSuspenseBoundary=$$$hostConfig.clearSuspenseBoundary,clearSuspenseBoundaryFromContainer=$$$hostConfig.clearSuspenseBoundaryFromContainer,shouldDeleteUnhydratedTailInstances=$$$hostConfig.shouldDeleteUnhydratedTailInstances,didNotMatchHydratedContainerTextInstance=$$$hostConfig.didNotMatchHydratedContainerTextInstance,didNotMatchHydratedTextInstance=$$$hostConfig.didNotMatchHydratedTextInstance,didNotHydrateInstanceWithinContainer=
$$$hostConfig.didNotHydrateInstanceWithinContainer,didNotHydrateInstanceWithinSuspenseInstance=$$$hostConfig.didNotHydrateInstanceWithinSuspenseInstance,didNotHydrateInstance=$$$hostConfig.didNotHydrateInstance,didNotFindHydratableInstanceWithinContainer=$$$hostConfig.didNotFindHydratableInstanceWithinContainer,didNotFindHydratableTextInstanceWithinContainer=$$$hostConfig.didNotFindHydratableTextInstanceWithinContainer,didNotFindHydratableSuspenseInstanceWithinContainer=$$$hostConfig.didNotFindHydratableSuspenseInstanceWithinContainer,
didNotFindHydratableInstanceWithinSuspenseInstance=$$$hostConfig.didNotFindHydratableInstanceWithinSuspenseInstance,didNotFindHydratableTextInstanceWithinSuspenseInstance=$$$hostConfig.didNotFindHydratableTextInstanceWithinSuspenseInstance,didNotFindHydratableSuspenseInstanceWithinSuspenseInstance=$$$hostConfig.didNotFindHydratableSuspenseInstanceWithinSuspenseInstance,didNotFindHydratableInstance=$$$hostConfig.didNotFindHydratableInstance,didNotFindHydratableTextInstance=$$$hostConfig.didNotFindHydratableTextInstance,
didNotFindHydratableSuspenseInstance=$$$hostConfig.didNotFindHydratableSuspenseInstance,errorHydratingContainer=$$$hostConfig.errorHydratingContainer,disabledDepth=0,prevLog,prevInfo,prevWarn,prevError,prevGroup,prevGroupCollapsed,prevGroupEnd;disabledLog.__reactDisabledLog=!0;var ReactCurrentDispatcher=ReactSharedInternals.ReactCurrentDispatcher,prefix,reentry=!1;var componentFrameCache=new ("function"===typeof WeakMap?WeakMap:Map);var hasOwnProperty=Object.prototype.hasOwnProperty,loggedTypeFailures=
{},ReactDebugCurrentFrame=ReactSharedInternals.ReactDebugCurrentFrame,valueStack=[];var fiberStack=[];var index$jscomp$0=-1;var warnedAboutMissingGetChildContext={};var emptyContextObject={};Object.freeze(emptyContextObject);var contextStackCursor=createCursor(emptyContextObject),didPerformWorkStackCursor=createCursor(!1),previousContext=emptyContextObject,clz32=Math.clz32?Math.clz32:clz32Fallback,log=Math.log,LN2=Math.LN2,nextTransitionLane=64,nextRetryLane=4194304,currentUpdatePriority=0,scheduleCallback=
Scheduler.unstable_scheduleCallback,cancelCallback=Scheduler.unstable_cancelCallback,shouldYield=Scheduler.unstable_shouldYield,requestPaint=Scheduler.unstable_requestPaint,now$1=Scheduler.unstable_now,ImmediatePriority=Scheduler.unstable_ImmediatePriority,UserBlockingPriority=Scheduler.unstable_UserBlockingPriority,NormalPriority=Scheduler.unstable_NormalPriority,IdlePriority=Scheduler.unstable_IdlePriority,unstable_yieldValue=Scheduler.unstable_yieldValue,unstable_setDisableYieldValue=Scheduler.unstable_setDisableYieldValue,
rendererID=null,injectedHook=null,injectedProfilingHooks=null,hasLoggedError=!1,isDevToolsPresent="undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__,objectIs="function"===typeof Object.is?Object.is:is,syncQueue=null,includesLegacySyncCallbacks=!1,isFlushingSyncQueue=!1,ReactCurrentBatchConfig=ReactSharedInternals.ReactCurrentBatchConfig,ReactDebugCurrentFrame$1=ReactSharedInternals.ReactDebugCurrentFrame,current$jscomp$1=null,isRendering=!1,ReactStrictModeWarnings={recordUnsafeLifecycleWarnings:function(fiber,
instance){},flushPendingUnsafeLifecycleWarnings:function(){},recordLegacyContextWarning:function(fiber,instance){},flushLegacyContextWarning:function(){},discardPendingWarnings:function(){}},setToSortedString=function(set){var array=[];set.forEach(function(value){array.push(value)});return array.sort().join(", ")},pendingComponentWillMountWarnings=[],pendingUNSAFE_ComponentWillMountWarnings=[],pendingComponentWillReceivePropsWarnings=[],pendingUNSAFE_ComponentWillReceivePropsWarnings=[],pendingComponentWillUpdateWarnings=
[],pendingUNSAFE_ComponentWillUpdateWarnings=[],didWarnAboutUnsafeLifecycles=new Set;ReactStrictModeWarnings.recordUnsafeLifecycleWarnings=function(fiber,instance){didWarnAboutUnsafeLifecycles.has(fiber.type)||("function"===typeof instance.componentWillMount&&!0!==instance.componentWillMount.__suppressDeprecationWarning&&pendingComponentWillMountWarnings.push(fiber),fiber.mode&8&&"function"===typeof instance.UNSAFE_componentWillMount&&pendingUNSAFE_ComponentWillMountWarnings.push(fiber),"function"===
typeof instance.componentWillReceiveProps&&!0!==instance.componentWillReceiveProps.__suppressDeprecationWarning&&pendingComponentWillReceivePropsWarnings.push(fiber),fiber.mode&8&&"function"===typeof instance.UNSAFE_componentWillReceiveProps&&pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber),"function"===typeof instance.componentWillUpdate&&!0!==instance.componentWillUpdate.__suppressDeprecationWarning&&pendingComponentWillUpdateWarnings.push(fiber),fiber.mode&8&&"function"===typeof instance.UNSAFE_componentWillUpdate&&
pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber))};ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings=function(){var componentWillMountUniqueNames=new Set;0<pendingComponentWillMountWarnings.length&&(pendingComponentWillMountWarnings.forEach(function(fiber){componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||"Component");didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillMountWarnings=[]);var UNSAFE_componentWillMountUniqueNames=new Set;0<pendingUNSAFE_ComponentWillMountWarnings.length&&
(pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber){UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber)||"Component");didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillMountWarnings=[]);var componentWillReceivePropsUniqueNames=new Set;0<pendingComponentWillReceivePropsWarnings.length&&(pendingComponentWillReceivePropsWarnings.forEach(function(fiber){componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||"Component");didWarnAboutUnsafeLifecycles.add(fiber.type)}),
pendingComponentWillReceivePropsWarnings=[]);var UNSAFE_componentWillReceivePropsUniqueNames=new Set;0<pendingUNSAFE_ComponentWillReceivePropsWarnings.length&&(pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber){UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber)||"Component");didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingUNSAFE_ComponentWillReceivePropsWarnings=[]);var componentWillUpdateUniqueNames=new Set;0<pendingComponentWillUpdateWarnings.length&&
(pendingComponentWillUpdateWarnings.forEach(function(fiber){componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||"Component");didWarnAboutUnsafeLifecycles.add(fiber.type)}),pendingComponentWillUpdateWarnings=[]);var UNSAFE_componentWillUpdateUniqueNames=new Set;0<pendingUNSAFE_ComponentWillUpdateWarnings.length&&(pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber){UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber)||"Component");didWarnAboutUnsafeLifecycles.add(fiber.type)}),
pendingUNSAFE_ComponentWillUpdateWarnings=[]);if(0<UNSAFE_componentWillMountUniqueNames.size){var sortedNames=setToSortedString(UNSAFE_componentWillMountUniqueNames);error$jscomp$0("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n\nPlease update the following components: %s",sortedNames)}0<
UNSAFE_componentWillReceivePropsUniqueNames.size&&(sortedNames=setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames),error$jscomp$0("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n\nPlease update the following components: %s",
sortedNames));0<UNSAFE_componentWillUpdateUniqueNames.size&&(sortedNames=setToSortedString(UNSAFE_componentWillUpdateUniqueNames),error$jscomp$0("Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n\nPlease update the following components: %s",sortedNames));0<componentWillMountUniqueNames.size&&(sortedNames=setToSortedString(componentWillMountUniqueNames),
warn("componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move code with side effects to componentDidMount, and set initial state in the constructor.\n* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
sortedNames));0<componentWillReceivePropsUniqueNames.size&&(sortedNames=setToSortedString(componentWillReceivePropsUniqueNames),warn("componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state\n* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
sortedNames));0<componentWillUpdateUniqueNames.size&&(sortedNames=setToSortedString(componentWillUpdateUniqueNames),warn("componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.\n\n* Move data fetching code or side effects to componentDidUpdate.\n* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run `npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n\nPlease update the following components: %s",
sortedNames))};var pendingLegacyContextWarning=new Map,didWarnAboutLegacyContext=new Set;ReactStrictModeWarnings.recordLegacyContextWarning=function(fiber,instance){var strictRoot=null;for(var node=fiber;null!==node;)node.mode&8&&(strictRoot=node),node=node.return;null===strictRoot?error$jscomp$0("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue."):!didWarnAboutLegacyContext.has(fiber.type)&&(node=pendingLegacyContextWarning.get(strictRoot),
null!=fiber.type.contextTypes||null!=fiber.type.childContextTypes||null!==instance&&"function"===typeof instance.getChildContext)&&(void 0===node&&(node=[],pendingLegacyContextWarning.set(strictRoot,node)),node.push(fiber))};ReactStrictModeWarnings.flushLegacyContextWarning=function(){pendingLegacyContextWarning.forEach(function(fiberArray,strictRoot){if(0!==fiberArray.length){strictRoot=fiberArray[0];var uniqueNames=new Set;fiberArray.forEach(function(fiber){uniqueNames.add(getComponentNameFromFiber(fiber)||
"Component");didWarnAboutLegacyContext.add(fiber.type)});fiberArray=setToSortedString(uniqueNames);try{setCurrentFiber(strictRoot),error$jscomp$0("Legacy context API has been detected within a strict-mode tree.\n\nThe old API will be supported in all 16.x releases, but applications using it should migrate to the new version.\n\nPlease update the following components: %s\n\nLearn more about this warning here: https://reactjs.org/link/legacy-context",fiberArray)}finally{resetCurrentFiber()}}})};ReactStrictModeWarnings.discardPendingWarnings=
function(){pendingComponentWillMountWarnings=[];pendingUNSAFE_ComponentWillMountWarnings=[];pendingComponentWillReceivePropsWarnings=[];pendingUNSAFE_ComponentWillReceivePropsWarnings=[];pendingComponentWillUpdateWarnings=[];pendingUNSAFE_ComponentWillUpdateWarnings=[];pendingLegacyContextWarning=new Map};var valueCursor=createCursor(null);var rendererSigil={};var currentlyRenderingFiber=null,lastContextDependency=null,lastFullyObservedContext=null,isDisallowedContextReadInDEV=!1,interleavedQueues=
null,UpdateState=0,ForceUpdate=2,hasForceUpdate=!1;var didWarnUpdateInsideUpdate=!1;var currentlyProcessingQueue=null;var fakeInternalInstance={},emptyRefsObject=(new React.Component).refs;var didWarnAboutStateAssignmentForComponent=new Set;var didWarnAboutUninitializedState=new Set;var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate=new Set;var didWarnAboutLegacyLifecyclesAndDerivedState=new Set;var didWarnAboutDirectlyAssigningPropsToState=new Set;var didWarnAboutUndefinedDerivedState=new Set;
var didWarnAboutContextTypeAndContextTypes=new Set;var didWarnAboutInvalidateContextType=new Set;var didWarnOnInvalidCallback=new Set;var warnOnInvalidCallback=function(callback,callerName){if(null!==callback&&"function"!==typeof callback){var key=callerName+"_"+callback;didWarnOnInvalidCallback.has(key)||(didWarnOnInvalidCallback.add(key),error$jscomp$0("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.",callerName,callback))}};var warnOnUndefinedDerivedState=
function(type,partialState){void 0===partialState&&(type=getComponentNameFromType(type)||"Component",didWarnAboutUndefinedDerivedState.has(type)||(didWarnAboutUndefinedDerivedState.add(type),error$jscomp$0("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.",type)))};Object.defineProperty(fakeInternalInstance,"_processChildContext",{enumerable:!1,value:function(){throw Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
}});Object.freeze(fakeInternalInstance);var classComponentUpdater={isMounted:function(component){var owner=ReactCurrentOwner.current;if(null!==owner&&1===owner.tag){var instance=owner.stateNode;instance._warnedAboutRefsInRender||error$jscomp$0("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",
getComponentNameFromFiber(owner)||"A component");instance._warnedAboutRefsInRender=!0}return(component=component._reactInternals)?getNearestMountedFiber(component)===component:!1},enqueueSetState:function(inst,payload,callback){inst=inst._reactInternals;var eventTime=requestEventTime(),lane=requestUpdateLane(inst),update=createUpdate(eventTime,lane);update.payload=payload;void 0!==callback&&null!==callback&&(warnOnInvalidCallback(callback,"setState"),update.callback=callback);enqueueUpdate(inst,update);
payload=scheduleUpdateOnFiber(inst,lane,eventTime);null!==payload&&entangleTransitions(payload,inst,lane);markStateUpdateScheduled(inst,lane)},enqueueReplaceState:function(inst,payload,callback){inst=inst._reactInternals;var eventTime=requestEventTime(),lane=requestUpdateLane(inst),update=createUpdate(eventTime,lane);update.tag=1;update.payload=payload;void 0!==callback&&null!==callback&&(warnOnInvalidCallback(callback,"replaceState"),update.callback=callback);enqueueUpdate(inst,update);payload=scheduleUpdateOnFiber(inst,
lane,eventTime);null!==payload&&entangleTransitions(payload,inst,lane);markStateUpdateScheduled(inst,lane)},enqueueForceUpdate:function(inst,callback){inst=inst._reactInternals;var eventTime=requestEventTime(),lane=requestUpdateLane(inst),update=createUpdate(eventTime,lane);update.tag=ForceUpdate;void 0!==callback&&null!==callback&&(warnOnInvalidCallback(callback,"forceUpdate"),update.callback=callback);enqueueUpdate(inst,update);callback=scheduleUpdateOnFiber(inst,lane,eventTime);null!==callback&&
entangleTransitions(callback,inst,lane);null!==injectedProfilingHooks&&"function"===typeof injectedProfilingHooks.markForceUpdateScheduled&&injectedProfilingHooks.markForceUpdateScheduled(inst,lane)}},forkStack=[],forkStackIndex=0,treeForkProvider=null,treeForkCount=0,idStack=[],idStackIndex=0,treeContextProvider=null,treeContextId=1,treeContextOverflow="",hydrationParentFiber=null,nextHydratableInstance=null,isHydrating=!1,didSuspend$jscomp$0=!1,hydrationErrors=null,didWarnAboutMaps,warnForMissingKey=
function(child,returnFiber){};var didWarnAboutGenerators=didWarnAboutMaps=!1;var didWarnAboutStringRefs={};var ownerHasKeyUseWarning={};var ownerHasFunctionTypeWarning={};warnForMissingKey=function(child,returnFiber){if(null!==child&&"object"===typeof child&&child._store&&!child._store.validated&&null==child.key){if("object"!==typeof child._store)throw Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");child._store.validated=
!0;child=getComponentNameFromFiber(returnFiber)||"Component";ownerHasKeyUseWarning[child]||(ownerHasKeyUseWarning[child]=!0,error$jscomp$0('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'))}};var reconcileChildFibers$jscomp$0=ChildReconciler(!0),mountChildFibers=ChildReconciler(!1),NO_CONTEXT={},contextStackCursor$1=createCursor(NO_CONTEXT),contextFiberStackCursor=createCursor(NO_CONTEXT),rootInstanceStackCursor=createCursor(NO_CONTEXT),
SubtreeSuspenseContextMask=1,InvisibleParentSuspenseContext=1,ForceSuspenseFallback=2,suspenseStackCursor=createCursor(0),NoFlags$1=0,HasEffect=1,Insertion=2,Layout=4,Passive$1=8,workInProgressSources=[],ReactCurrentDispatcher$1=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentBatchConfig$1=ReactSharedInternals.ReactCurrentBatchConfig,didWarnUncachedGetSnapshot;var didWarnAboutMismatchedHooksForComponent=new Set;var renderLanes$jscomp$0=0,currentlyRenderingFiber$1=null,currentHook=null,workInProgressHook=
null,didScheduleRenderPhaseUpdate=!1,didScheduleRenderPhaseUpdateDuringThisPass=!1,localIdCounter=0,globalClientIdCounter=0,currentHookNameInDev=null,hookTypesDev=null,hookTypesUpdateIndexDev=-1,ignorePreviousDependencies=!1,isUpdatingOpaqueValueInRenderPhase=!1,ContextOnlyDispatcher={readContext,useCallback:throwInvalidHookError,useContext:throwInvalidHookError,useEffect:throwInvalidHookError,useImperativeHandle:throwInvalidHookError,useInsertionEffect:throwInvalidHookError,useLayoutEffect:throwInvalidHookError,
useMemo:throwInvalidHookError,useReducer:throwInvalidHookError,useRef:throwInvalidHookError,useState:throwInvalidHookError,useDebugValue:throwInvalidHookError,useDeferredValue:throwInvalidHookError,useTransition:throwInvalidHookError,useMutableSource:throwInvalidHookError,useSyncExternalStore:throwInvalidHookError,useId:throwInvalidHookError,unstable_isNewReconciler:!1},HooksDispatcherOnMountInDEV=null,HooksDispatcherOnMountWithHookTypesInDEV=null,HooksDispatcherOnUpdateInDEV=null,HooksDispatcherOnRerenderInDEV=
null,InvalidNestedHooksDispatcherOnMountInDEV=null,InvalidNestedHooksDispatcherOnUpdateInDEV=null,InvalidNestedHooksDispatcherOnRerenderInDEV=null,warnInvalidContextAccess=function(){error$jscomp$0("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().")},warnInvalidHookAccess=function(){error$jscomp$0("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks")};
HooksDispatcherOnMountInDEV={readContext:function(context){return readContext(context)},useCallback:function(callback,deps){currentHookNameInDev="useCallback";mountHookTypesDev();checkDepsAreArrayDev(deps);return mountCallback(callback,deps)},useContext:function(context){currentHookNameInDev="useContext";mountHookTypesDev();return readContext(context)},useEffect:function(create,deps){currentHookNameInDev="useEffect";mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffect(create,deps)},useImperativeHandle:function(ref,
create,deps){currentHookNameInDev="useImperativeHandle";mountHookTypesDev();checkDepsAreArrayDev(deps);return mountImperativeHandle(ref,create,deps)},useInsertionEffect:function(create,deps){currentHookNameInDev="useInsertionEffect";mountHookTypesDev();checkDepsAreArrayDev(deps);return mountEffectImpl(4,Insertion,create,deps)},useLayoutEffect:function(create,deps){currentHookNameInDev="useLayoutEffect";mountHookTypesDev();checkDepsAreArrayDev(deps);return mountLayoutEffect(create,deps)},useMemo:function(create,
deps){currentHookNameInDev="useMemo";mountHookTypesDev();checkDepsAreArrayDev(deps);var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer";mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;
try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){currentHookNameInDev="useRef";mountHookTypesDev();return mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState";mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=
prevDispatcher}},useDebugValue:function(value,formatterFn){currentHookNameInDev="useDebugValue";mountHookTypesDev()},useDeferredValue:function(value){currentHookNameInDev="useDeferredValue";mountHookTypesDev();return mountDeferredValue(value)},useTransition:function(){currentHookNameInDev="useTransition";mountHookTypesDev();return mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev="useMutableSource";mountHookTypesDev()},useSyncExternalStore:function(subscribe,
getSnapshot,getServerSnapshot){currentHookNameInDev="useSyncExternalStore";mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){currentHookNameInDev="useId";mountHookTypesDev();return mountId()},unstable_isNewReconciler:!1};HooksDispatcherOnMountWithHookTypesInDEV={readContext:function(context){return readContext(context)},useCallback:function(callback,deps){currentHookNameInDev="useCallback";updateHookTypesDev();return mountCallback(callback,
deps)},useContext:function(context){currentHookNameInDev="useContext";updateHookTypesDev();return readContext(context)},useEffect:function(create,deps){currentHookNameInDev="useEffect";updateHookTypesDev();return mountEffect(create,deps)},useImperativeHandle:function(ref,create,deps){currentHookNameInDev="useImperativeHandle";updateHookTypesDev();return mountImperativeHandle(ref,create,deps)},useInsertionEffect:function(create,deps){currentHookNameInDev="useInsertionEffect";updateHookTypesDev();return mountEffectImpl(4,
Insertion,create,deps)},useLayoutEffect:function(create,deps){currentHookNameInDev="useLayoutEffect";updateHookTypesDev();return mountLayoutEffect(create,deps)},useMemo:function(create,deps){currentHookNameInDev="useMemo";updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev=
"useReducer";updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){currentHookNameInDev="useRef";updateHookTypesDev();return mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState";updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;
ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,formatterFn){currentHookNameInDev="useDebugValue";updateHookTypesDev()},useDeferredValue:function(value){currentHookNameInDev="useDeferredValue";updateHookTypesDev();return mountDeferredValue(value)},useTransition:function(){currentHookNameInDev="useTransition";updateHookTypesDev();return mountTransition()},
useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev="useMutableSource";updateHookTypesDev()},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev="useSyncExternalStore";updateHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){currentHookNameInDev="useId";updateHookTypesDev();return mountId()},unstable_isNewReconciler:!1};HooksDispatcherOnUpdateInDEV={readContext:function(context){return readContext(context)},
useCallback:function(callback,deps){currentHookNameInDev="useCallback";updateHookTypesDev();return updateCallback(callback,deps)},useContext:function(context){currentHookNameInDev="useContext";updateHookTypesDev();return readContext(context)},useEffect:function(create,deps){currentHookNameInDev="useEffect";updateHookTypesDev();return updateEffect(create,deps)},useImperativeHandle:function(ref,create,deps){currentHookNameInDev="useImperativeHandle";updateHookTypesDev();return updateImperativeHandle(ref,
create,deps)},useInsertionEffect:function(create,deps){currentHookNameInDev="useInsertionEffect";updateHookTypesDev();return updateEffectImpl(4,Insertion,create,deps)},useLayoutEffect:function(create,deps){currentHookNameInDev="useLayoutEffect";updateHookTypesDev();return updateEffectImpl(4,Layout,create,deps)},useMemo:function(create,deps){currentHookNameInDev="useMemo";updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
try{return updateMemo(create,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer";updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){currentHookNameInDev="useRef";updateHookTypesDev();
return updateWorkInProgressHook().memoizedState},useState:function(initialState){currentHookNameInDev="useState";updateHookTypesDev();initialState=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(basicStateReducer)}finally{ReactCurrentDispatcher$1.current=initialState}},useDebugValue:function(value,formatterFn){currentHookNameInDev="useDebugValue";updateHookTypesDev()},useDeferredValue:function(value){currentHookNameInDev=
"useDeferredValue";updateHookTypesDev();return updateDeferredValue(value)},useTransition:function(){currentHookNameInDev="useTransition";updateHookTypesDev();return updateTransition()},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev="useMutableSource";updateHookTypesDev()},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev="useSyncExternalStore";updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){currentHookNameInDev=
"useId";updateHookTypesDev();return updateWorkInProgressHook().memoizedState},unstable_isNewReconciler:!1};HooksDispatcherOnRerenderInDEV={readContext:function(context){return readContext(context)},useCallback:function(callback,deps){currentHookNameInDev="useCallback";updateHookTypesDev();return updateCallback(callback,deps)},useContext:function(context){currentHookNameInDev="useContext";updateHookTypesDev();return readContext(context)},useEffect:function(create,deps){currentHookNameInDev="useEffect";
updateHookTypesDev();return updateEffect(create,deps)},useImperativeHandle:function(ref,create,deps){currentHookNameInDev="useImperativeHandle";updateHookTypesDev();return updateImperativeHandle(ref,create,deps)},useInsertionEffect:function(create,deps){currentHookNameInDev="useInsertionEffect";updateHookTypesDev();return updateEffectImpl(4,Insertion,create,deps)},useLayoutEffect:function(create,deps){currentHookNameInDev="useLayoutEffect";updateHookTypesDev();return updateEffectImpl(4,Layout,create,
deps)},useMemo:function(create,deps){currentHookNameInDev="useMemo";updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return updateMemo(create,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer";updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;
try{return rerenderReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){currentHookNameInDev="useRef";updateHookTypesDev();return updateWorkInProgressHook().memoizedState},useState:function(initialState){currentHookNameInDev="useState";updateHookTypesDev();initialState=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnRerenderInDEV;try{return rerenderReducer(basicStateReducer)}finally{ReactCurrentDispatcher$1.current=
initialState}},useDebugValue:function(value,formatterFn){currentHookNameInDev="useDebugValue";updateHookTypesDev()},useDeferredValue:function(value){currentHookNameInDev="useDeferredValue";updateHookTypesDev();return rerenderDeferredValue(value)},useTransition:function(){currentHookNameInDev="useTransition";updateHookTypesDev();return rerenderTransition()},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev="useMutableSource";updateHookTypesDev()},useSyncExternalStore:function(subscribe,
getSnapshot,getServerSnapshot){currentHookNameInDev="useSyncExternalStore";updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){currentHookNameInDev="useId";updateHookTypesDev();return updateWorkInProgressHook().memoizedState},unstable_isNewReconciler:!1};InvalidNestedHooksDispatcherOnMountInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context)},useCallback:function(callback,deps){currentHookNameInDev="useCallback";warnInvalidHookAccess();
mountHookTypesDev();return mountCallback(callback,deps)},useContext:function(context){currentHookNameInDev="useContext";warnInvalidHookAccess();mountHookTypesDev();return readContext(context)},useEffect:function(create,deps){currentHookNameInDev="useEffect";warnInvalidHookAccess();mountHookTypesDev();return mountEffect(create,deps)},useImperativeHandle:function(ref,create,deps){currentHookNameInDev="useImperativeHandle";warnInvalidHookAccess();mountHookTypesDev();return mountImperativeHandle(ref,
create,deps)},useInsertionEffect:function(create,deps){currentHookNameInDev="useInsertionEffect";warnInvalidHookAccess();mountHookTypesDev();return mountEffectImpl(4,Insertion,create,deps)},useLayoutEffect:function(create,deps){currentHookNameInDev="useLayoutEffect";warnInvalidHookAccess();mountHookTypesDev();return mountLayoutEffect(create,deps)},useMemo:function(create,deps){currentHookNameInDev="useMemo";warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;
ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountMemo(create,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer";warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=
prevDispatcher}},useRef:function(initialValue){currentHookNameInDev="useRef";warnInvalidHookAccess();mountHookTypesDev();return mountRef(initialValue)},useState:function(initialState){currentHookNameInDev="useState";warnInvalidHookAccess();mountHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnMountInDEV;try{return mountState(initialState)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useDebugValue:function(value,
formatterFn){currentHookNameInDev="useDebugValue";warnInvalidHookAccess();mountHookTypesDev()},useDeferredValue:function(value){currentHookNameInDev="useDeferredValue";warnInvalidHookAccess();mountHookTypesDev();return mountDeferredValue(value)},useTransition:function(){currentHookNameInDev="useTransition";warnInvalidHookAccess();mountHookTypesDev();return mountTransition()},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev="useMutableSource";warnInvalidHookAccess();mountHookTypesDev()},
useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev="useSyncExternalStore";warnInvalidHookAccess();mountHookTypesDev();return mountSyncExternalStore(subscribe,getSnapshot,getServerSnapshot)},useId:function(){currentHookNameInDev="useId";warnInvalidHookAccess();mountHookTypesDev();return mountId()},unstable_isNewReconciler:!1};InvalidNestedHooksDispatcherOnUpdateInDEV={readContext:function(context){warnInvalidContextAccess();return readContext(context)},useCallback:function(callback,
deps){currentHookNameInDev="useCallback";warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps)},useContext:function(context){currentHookNameInDev="useContext";warnInvalidHookAccess();updateHookTypesDev();return readContext(context)},useEffect:function(create,deps){currentHookNameInDev="useEffect";warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps)},useImperativeHandle:function(ref,create,deps){currentHookNameInDev="useImperativeHandle";warnInvalidHookAccess();
updateHookTypesDev();return updateImperativeHandle(ref,create,deps)},useInsertionEffect:function(create,deps){currentHookNameInDev="useInsertionEffect";warnInvalidHookAccess();updateHookTypesDev();return updateEffectImpl(4,Insertion,create,deps)},useLayoutEffect:function(create,deps){currentHookNameInDev="useLayoutEffect";warnInvalidHookAccess();updateHookTypesDev();return updateEffectImpl(4,Layout,create,deps)},useMemo:function(create,deps){currentHookNameInDev="useMemo";warnInvalidHookAccess();
updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer";warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(reducer,
initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){currentHookNameInDev="useRef";warnInvalidHookAccess();updateHookTypesDev();return updateWorkInProgressHook().memoizedState},useState:function(initialState){currentHookNameInDev="useState";warnInvalidHookAccess();updateHookTypesDev();initialState=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateReducer(basicStateReducer)}finally{ReactCurrentDispatcher$1.current=
initialState}},useDebugValue:function(value,formatterFn){currentHookNameInDev="useDebugValue";warnInvalidHookAccess();updateHookTypesDev()},useDeferredValue:function(value){currentHookNameInDev="useDeferredValue";warnInvalidHookAccess();updateHookTypesDev();return updateDeferredValue(value)},useTransition:function(){currentHookNameInDev="useTransition";warnInvalidHookAccess();updateHookTypesDev();return updateTransition()},useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev=
"useMutableSource";warnInvalidHookAccess();updateHookTypesDev()},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev="useSyncExternalStore";warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){currentHookNameInDev="useId";warnInvalidHookAccess();updateHookTypesDev();return updateWorkInProgressHook().memoizedState},unstable_isNewReconciler:!1};InvalidNestedHooksDispatcherOnRerenderInDEV={readContext:function(context){warnInvalidContextAccess();
return readContext(context)},useCallback:function(callback,deps){currentHookNameInDev="useCallback";warnInvalidHookAccess();updateHookTypesDev();return updateCallback(callback,deps)},useContext:function(context){currentHookNameInDev="useContext";warnInvalidHookAccess();updateHookTypesDev();return readContext(context)},useEffect:function(create,deps){currentHookNameInDev="useEffect";warnInvalidHookAccess();updateHookTypesDev();return updateEffect(create,deps)},useImperativeHandle:function(ref,create,
deps){currentHookNameInDev="useImperativeHandle";warnInvalidHookAccess();updateHookTypesDev();return updateImperativeHandle(ref,create,deps)},useInsertionEffect:function(create,deps){currentHookNameInDev="useInsertionEffect";warnInvalidHookAccess();updateHookTypesDev();return updateEffectImpl(4,Insertion,create,deps)},useLayoutEffect:function(create,deps){currentHookNameInDev="useLayoutEffect";warnInvalidHookAccess();updateHookTypesDev();return updateEffectImpl(4,Layout,create,deps)},useMemo:function(create,
deps){currentHookNameInDev="useMemo";warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;try{return updateMemo(create,deps)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useReducer:function(reducer,initialArg,init){currentHookNameInDev="useReducer";warnInvalidHookAccess();updateHookTypesDev();var prevDispatcher=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=
InvalidNestedHooksDispatcherOnUpdateInDEV;try{return rerenderReducer(reducer,initialArg,init)}finally{ReactCurrentDispatcher$1.current=prevDispatcher}},useRef:function(initialValue){currentHookNameInDev="useRef";warnInvalidHookAccess();updateHookTypesDev();return updateWorkInProgressHook().memoizedState},useState:function(initialState){currentHookNameInDev="useState";warnInvalidHookAccess();updateHookTypesDev();initialState=ReactCurrentDispatcher$1.current;ReactCurrentDispatcher$1.current=InvalidNestedHooksDispatcherOnUpdateInDEV;
try{return rerenderReducer(basicStateReducer)}finally{ReactCurrentDispatcher$1.current=initialState}},useDebugValue:function(value,formatterFn){currentHookNameInDev="useDebugValue";warnInvalidHookAccess();updateHookTypesDev()},useDeferredValue:function(value){currentHookNameInDev="useDeferredValue";warnInvalidHookAccess();updateHookTypesDev();return rerenderDeferredValue(value)},useTransition:function(){currentHookNameInDev="useTransition";warnInvalidHookAccess();updateHookTypesDev();return rerenderTransition()},
useMutableSource:function(source,getSnapshot,subscribe){currentHookNameInDev="useMutableSource";warnInvalidHookAccess();updateHookTypesDev()},useSyncExternalStore:function(subscribe,getSnapshot,getServerSnapshot){currentHookNameInDev="useSyncExternalStore";warnInvalidHookAccess();updateHookTypesDev();return updateSyncExternalStore(subscribe,getSnapshot)},useId:function(){currentHookNameInDev="useId";warnInvalidHookAccess();updateHookTypesDev();return updateWorkInProgressHook().memoizedState},unstable_isNewReconciler:!1};
var now$2=Scheduler.unstable_now,commitTime=0,layoutEffectStartTime=-1,profilerStartTime=-1,passiveEffectStartTime=-1,currentUpdateIsNested=!1,nestedUpdateScheduled=!1,PossiblyWeakMap$1="function"===typeof WeakMap?WeakMap:Map;if(supportsMutation){var appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){for(needsVisibilityToggle=workInProgress.child;null!==needsVisibilityToggle;){if(5===needsVisibilityToggle.tag||6===needsVisibilityToggle.tag)appendInitialChild(parent,needsVisibilityToggle.stateNode);
else if(4!==needsVisibilityToggle.tag&&null!==needsVisibilityToggle.child){needsVisibilityToggle.child.return=needsVisibilityToggle;needsVisibilityToggle=needsVisibilityToggle.child;continue}if(needsVisibilityToggle===workInProgress)break;for(;null===needsVisibilityToggle.sibling;){if(null===needsVisibilityToggle.return||needsVisibilityToggle.return===workInProgress)return;needsVisibilityToggle=needsVisibilityToggle.return}needsVisibilityToggle.sibling.return=needsVisibilityToggle.return;needsVisibilityToggle=
needsVisibilityToggle.sibling}};var updateHostContainer=function(current,workInProgress){};var updateHostComponent=function(current,workInProgress,type,newProps,rootContainerInstance){current=current.memoizedProps;if(current!==newProps){var instance=workInProgress.stateNode,currentHostContext=requiredContext(contextStackCursor$1.current);type=prepareUpdate(instance,type,current,newProps,rootContainerInstance,currentHostContext);(workInProgress.updateQueue=type)&&markUpdate(workInProgress)}};var updateHostText=
function(current,workInProgress,oldText,newText){oldText!==newText&&markUpdate(workInProgress)}}else if(supportsPersistence){appendAllChildren=function(parent,workInProgress,needsVisibilityToggle,isHidden){for(var node=workInProgress.child;null!==node;){if(5===node.tag){var instance=node.stateNode;needsVisibilityToggle&&isHidden&&(instance=cloneHiddenInstance(instance,node.type,node.memoizedProps,node));appendInitialChild(parent,instance)}else if(6===node.tag)instance=node.stateNode,needsVisibilityToggle&&
isHidden&&(instance=cloneHiddenTextInstance(instance,node.memoizedProps,node)),appendInitialChild(parent,instance);else if(4!==node.tag)if(22===node.tag&&null!==node.memoizedState)instance=node.child,null!==instance&&(instance.return=node),appendAllChildren(parent,node,!0,!0);else if(null!==node.child){node.child.return=node;node=node.child;continue}if(node===workInProgress)break;for(;null===node.sibling;){if(null===node.return||node.return===workInProgress)return;node=node.return}node.sibling.return=
node.return;node=node.sibling}};var appendAllChildrenToContainer=function(containerChildSet,workInProgress,needsVisibilityToggle,isHidden){for(var node=workInProgress.child;null!==node;){if(5===node.tag){var instance=node.stateNode;needsVisibilityToggle&&isHidden&&(instance=cloneHiddenInstance(instance,node.type,node.memoizedProps,node));appendChildToContainerChildSet(containerChildSet,instance)}else if(6===node.tag)instance=node.stateNode,needsVisibilityToggle&&isHidden&&(instance=cloneHiddenTextInstance(instance,
node.memoizedProps,node)),appendChildToContainerChildSet(containerChildSet,instance);else if(4!==node.tag)if(22===node.tag&&null!==node.memoizedState)instance=node.child,null!==instance&&(instance.return=node),appendAllChildrenToContainer(containerChildSet,node,!0,!0);else if(null!==node.child){node.child.return=node;node=node.child;continue}if(node===workInProgress)break;for(;null===node.sibling;){if(null===node.return||node.return===workInProgress)return;node=node.return}node.sibling.return=node.return;
node=node.sibling}};updateHostContainer=function(current,workInProgress){var portalOrRoot=workInProgress.stateNode;if(!hadNoMutationsEffects(current,workInProgress)){current=portalOrRoot.containerInfo;var newChildSet=createContainerChildSet(current);appendAllChildrenToContainer(newChildSet,workInProgress,!1,!1);portalOrRoot.pendingChildren=newChildSet;markUpdate(workInProgress);finalizeContainerChildren(current,newChildSet)}};updateHostComponent=function(current,workInProgress,type,newProps,rootContainerInstance){var currentInstance=
current.stateNode,oldProps=current.memoizedProps;if((current=hadNoMutationsEffects(current,workInProgress))&&oldProps===newProps)workInProgress.stateNode=currentInstance;else{var recyclableInstance=workInProgress.stateNode,currentHostContext=requiredContext(contextStackCursor$1.current),updatePayload=null;oldProps!==newProps&&(updatePayload=prepareUpdate(recyclableInstance,type,oldProps,newProps,rootContainerInstance,currentHostContext));current&&null===updatePayload?workInProgress.stateNode=currentInstance:
(currentInstance=cloneInstance(currentInstance,updatePayload,type,oldProps,newProps,workInProgress,current,recyclableInstance),finalizeInitialChildren(currentInstance,type,newProps,rootContainerInstance,currentHostContext)&&markUpdate(workInProgress),workInProgress.stateNode=currentInstance,current?markUpdate(workInProgress):appendAllChildren(currentInstance,workInProgress,!1,!1))}};updateHostText=function(current,workInProgress,oldText,newText){oldText!==newText?(current=requiredContext(rootInstanceStackCursor.current),
oldText=requiredContext(contextStackCursor$1.current),workInProgress.stateNode=createTextInstance(newText,current,oldText,workInProgress),markUpdate(workInProgress)):workInProgress.stateNode=current.stateNode}}else updateHostContainer=function(current,workInProgress){},updateHostComponent=function(current,workInProgress,type,newProps,rootContainerInstance){},updateHostText=function(current,workInProgress,oldText,newText){};var ReactCurrentOwner$1=ReactSharedInternals.ReactCurrentOwner,didReceiveUpdate=
!1;var didWarnAboutBadClass={};var didWarnAboutModulePatternComponent={};var didWarnAboutContextTypeOnFunctionComponent={};var didWarnAboutGetDerivedStateOnFunctionComponent={};var didWarnAboutFunctionRefs={};var didWarnAboutReassigningProps=!1;var didWarnAboutRevealOrder={};var didWarnAboutTailOptions={};var SUSPENDED_MARKER={dehydrated:null,treeContext:null,retryLane:0},hasWarnedAboutUsingNoValuePropOnContextProvider=!1,hasWarnedAboutUsingContextAsConsumer=!1,invokeGuardedCallbackImpl=invokeGuardedCallbackProd;
if("undefined"!==typeof window&&"function"===typeof window.dispatchEvent&&"undefined"!==typeof document&&"function"===typeof document.createEvent){var fakeNode=document.createElement("react");invokeGuardedCallbackImpl=function(name,func,context,a,b,c,d,e,f){function restoreAfterDispatch(){fakeNode.removeEventListener(evtType,callCallback,!1);"undefined"!==typeof window.event&&window.hasOwnProperty("event")&&(window.event=windowEvent)}function callCallback(){didCall=!0;restoreAfterDispatch();func.apply(context,
funcArgs);didError=!1}function handleWindowError(event){error=event.error;didSetError=!0;null===error&&0===event.colno&&0===event.lineno&&(isCrossOriginError=!0);if(event.defaultPrevented&&null!=error&&"object"===typeof error)try{error._suppressLogging=!0}catch(inner){}}if("undefined"===typeof document||null===document)throw Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
var evt=document.createEvent("Event"),didCall=!1,didError=!0,windowEvent=window.event,windowEventDescriptor=Object.getOwnPropertyDescriptor(window,"event"),funcArgs=Array.prototype.slice.call(arguments,3),error,didSetError=!1,isCrossOriginError=!1,evtType="react-"+(name?name:"invokeguardedcallback");window.addEventListener("error",handleWindowError);fakeNode.addEventListener(evtType,callCallback,!1);evt.initEvent(evtType,!1,!1);fakeNode.dispatchEvent(evt);windowEventDescriptor&&Object.defineProperty(window,
"event",windowEventDescriptor);didCall&&didError&&(didSetError?isCrossOriginError&&(error=Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")):error=Error("An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the \"Pause on exceptions\" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue."),
this.onError(error));window.removeEventListener("error",handleWindowError);if(!didCall)return restoreAfterDispatch(),invokeGuardedCallbackProd.apply(this,arguments)}}var invokeGuardedCallbackImpl$1=invokeGuardedCallbackImpl,hasError=!1,caughtError=null,reporter={onError:function(error){hasError=!0;caughtError=error}},didWarnAboutUndefinedSnapshotBeforeUpdate=null;didWarnAboutUndefinedSnapshotBeforeUpdate=new Set;var offscreenSubtreeIsHidden=!1,offscreenSubtreeWasHidden=!1,PossiblyWeakSet="function"===
typeof WeakSet?WeakSet:Set,nextEffect=null,inProgressLanes=null,inProgressRoot=null,shouldFireAfterActiveInstanceBlur=!1,didWarnWrongReturnPointer=!1,COMPONENT_TYPE=0,HAS_PSEUDO_CLASS_TYPE=1,ROLE_TYPE=2,TEST_NAME_TYPE=3,TEXT_TYPE=4;if("function"===typeof Symbol&&Symbol.for){var symbolFor=Symbol.for;COMPONENT_TYPE=symbolFor("selector.component");HAS_PSEUDO_CLASS_TYPE=symbolFor("selector.has_pseudo_class");ROLE_TYPE=symbolFor("selector.role");TEST_NAME_TYPE=symbolFor("selector.test_id");TEXT_TYPE=symbolFor("selector.text")}var commitHooks=
[],ReactCurrentActQueue=ReactSharedInternals.ReactCurrentActQueue,ceil=Math.ceil,ReactCurrentDispatcher$2=ReactSharedInternals.ReactCurrentDispatcher,ReactCurrentOwner$2=ReactSharedInternals.ReactCurrentOwner,ReactCurrentBatchConfig$2=ReactSharedInternals.ReactCurrentBatchConfig,ReactCurrentActQueue$1=ReactSharedInternals.ReactCurrentActQueue,NoContext=0,RenderContext=2,CommitContext=4,RootInProgress=0,RootFatalErrored=1,RootErrored=2,RootSuspended=3,RootSuspendedWithDelay=4,RootCompleted=5,RootDidNotComplete=
6,executionContext=NoContext,workInProgressRoot=null,workInProgress$jscomp$0=null,workInProgressRootRenderLanes=0,subtreeRenderLanes=0,subtreeRenderLanesCursor=createCursor(0),workInProgressRootExitStatus=RootInProgress,workInProgressRootFatalError=null,workInProgressRootSkippedLanes=0,workInProgressRootInterleavedUpdatedLanes=0,workInProgressRootPingedLanes=0,workInProgressRootConcurrentErrors=null,workInProgressRootRecoverableErrors=null,globalMostRecentFallbackTime=0,FALLBACK_THROTTLE_MS=500,workInProgressRootRenderTargetTime=
Infinity,RENDER_TIMEOUT_MS=500,hasUncaughtError=!1,firstUncaughtError=null,legacyErrorBoundariesThatAlreadyFailed=null,rootDoesHavePassiveEffects=!1,rootWithPendingPassiveEffects=null,pendingPassiveEffectsLanes=0,pendingPassiveProfilerEffects=[],NESTED_UPDATE_LIMIT=50,nestedUpdateCount=0,rootWithNestedUpdates=null,NESTED_PASSIVE_UPDATE_LIMIT=50,nestedPassiveUpdateCount=0,currentEventTime=-1,currentEventTransitionLane=0,didWarnStateUpdateForNotYetMountedComponent=null;var beginWork$1=function(current,
unitOfWork,lanes){var originalWorkInProgressCopy=assignFiberPropertiesInDEV(null,unitOfWork);try{return beginWork(current,unitOfWork,lanes)}catch(originalError){if(null!==originalError&&"object"===typeof originalError&&"function"===typeof originalError.then)throw originalError;resetContextDependencies();resetHooksAfterThrow();unwindInterruptedWork(current,unitOfWork);assignFiberPropertiesInDEV(unitOfWork,originalWorkInProgressCopy);unitOfWork.mode&2&&startProfilerTimer(unitOfWork);invokeGuardedCallback(null,
beginWork,null,current,unitOfWork,lanes);hasError&&(current=clearCaughtError(),"object"===typeof current&&null!==current&&current._suppressLogging&&"object"===typeof originalError&&null!==originalError&&!originalError._suppressLogging&&(originalError._suppressLogging=!0));throw originalError;}};var didWarnAboutUpdateInRender=!1;var didWarnAboutUpdateInRenderForAnotherComponent=new Set;var fakeActCallbackNode={},resolveFamily=null,failedBoundaries=null,setRefreshHandler=function(handler){resolveFamily=
handler},scheduleRefresh=function(root,update){if(null!==resolveFamily){var staleFamilies=update.staleFamilies,updatedFamilies=update.updatedFamilies;flushPassiveEffects();flushSync(function(){scheduleFibersWithFamiliesRecursively(root.current,updatedFamilies,staleFamilies)})}},scheduleRoot=function(root,element){root.context===emptyContextObject&&(flushPassiveEffects(),flushSync(function(){updateContainer(element,root,null,null)}))},findHostInstancesForRefresh=function(root,families){var hostInstances=
new Set;families=new Set(families.map(function(family){return family.current}));findHostInstancesForMatchingFibersRecursively(root.current,families,hostInstances);return hostInstances};var hasBadMapPolyfill=!1;try{var nonExtensibleObject=Object.preventExtensions({});new Map([[nonExtensibleObject,null]]);new Set([nonExtensibleObject])}catch(e){hasBadMapPolyfill=!0}var createFiber=function(tag,pendingProps,key,mode){return new FiberNode(tag,pendingProps,key,mode)};var didWarnAboutNestedUpdates=!1;var didWarnAboutFindNodeInStrictMode=
{};var shouldErrorImpl=function(fiber){return null},shouldSuspendImpl=function(fiber){return!1},overrideHookState=null,overrideHookStateDeletePath=null,overrideHookStateRenamePath=null,overrideProps=null,overridePropsDeletePath=null,overridePropsRenamePath=null,scheduleUpdate=null,setErrorHandler=null,setSuspenseHandler=null,copyWithDeleteImpl=function(obj,path,index){var key=path[index],updated=isArrayImpl(obj)?obj.slice():assign({},obj);if(index+1===path.length)return isArrayImpl(updated)?updated.splice(key,
1):delete updated[key],updated;updated[key]=copyWithDeleteImpl(obj[key],path,index+1);return updated},copyWithRenameImpl=function(obj,oldPath,newPath,index){var oldKey=oldPath[index],updated=isArrayImpl(obj)?obj.slice():assign({},obj);index+1===oldPath.length?(updated[newPath[index]]=updated[oldKey],isArrayImpl(updated)?updated.splice(oldKey,1):delete updated[oldKey]):updated[oldKey]=copyWithRenameImpl(obj[oldKey],oldPath,newPath,index+1);return updated},copyWithRename=function(obj,oldPath,newPath){if(oldPath.length!==
newPath.length)warn("copyWithRename() expects paths of the same length");else{for(var i=0;i<newPath.length-1;i++)if(oldPath[i]!==newPath[i]){warn("copyWithRename() expects paths to be the same except for the deepest key");return}return copyWithRenameImpl(obj,oldPath,newPath,0)}},copyWithSetImpl=function(obj,path,index,value){if(index>=path.length)return value;var key=path[index],updated=isArrayImpl(obj)?obj.slice():assign({},obj);updated[key]=copyWithSetImpl(obj[key],path,index+1,value);return updated},
findHook=function(fiber,id){for(fiber=fiber.memoizedState;null!==fiber&&0<id;)fiber=fiber.next,id--;return fiber};overrideHookState=function(fiber,id,path,value){id=findHook(fiber,id);null!==id&&(path=copyWithSetImpl(id.memoizedState,path,0,value),id.memoizedState=path,id.baseState=path,fiber.memoizedProps=assign({},fiber.memoizedProps),scheduleUpdateOnFiber(fiber,1,-1))};overrideHookStateDeletePath=function(fiber,id,path){id=findHook(fiber,id);null!==id&&(path=copyWithDeleteImpl(id.memoizedState,
path,0),id.memoizedState=path,id.baseState=path,fiber.memoizedProps=assign({},fiber.memoizedProps),scheduleUpdateOnFiber(fiber,1,-1))};overrideHookStateRenamePath=function(fiber,id,oldPath,newPath){id=findHook(fiber,id);null!==id&&(oldPath=copyWithRename(id.memoizedState,oldPath,newPath),id.memoizedState=oldPath,id.baseState=oldPath,fiber.memoizedProps=assign({},fiber.memoizedProps),scheduleUpdateOnFiber(fiber,1,-1))};overrideProps=function(fiber,path,value){fiber.pendingProps=copyWithSetImpl(fiber.memoizedProps,
path,0,value);fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps);scheduleUpdateOnFiber(fiber,1,-1)};overridePropsDeletePath=function(fiber,path){fiber.pendingProps=copyWithDeleteImpl(fiber.memoizedProps,path,0);fiber.alternate&&(fiber.alternate.pendingProps=fiber.pendingProps);scheduleUpdateOnFiber(fiber,1,-1)};overridePropsRenamePath=function(fiber,oldPath,newPath){fiber.pendingProps=copyWithRename(fiber.memoizedProps,oldPath,newPath);fiber.alternate&&(fiber.alternate.pendingProps=
fiber.pendingProps);scheduleUpdateOnFiber(fiber,1,-1)};scheduleUpdate=function(fiber){scheduleUpdateOnFiber(fiber,1,-1)};setErrorHandler=function(newShouldErrorImpl){shouldErrorImpl=newShouldErrorImpl};setSuspenseHandler=function(newShouldSuspendImpl){shouldSuspendImpl=newShouldSuspendImpl};exports.attemptContinuousHydration=function(fiber){if(13===fiber.tag){var eventTime=requestEventTime();scheduleUpdateOnFiber(fiber,134217728,eventTime);markRetryLaneIfNotHydrated(fiber,134217728)}};exports.attemptHydrationAtCurrentPriority=
function(fiber){if(13===fiber.tag){var eventTime=requestEventTime(),lane=requestUpdateLane(fiber);scheduleUpdateOnFiber(fiber,lane,eventTime);markRetryLaneIfNotHydrated(fiber,lane)}};exports.attemptSynchronousHydration=function(fiber){switch(fiber.tag){case 3:var root=fiber.stateNode;if(root.current.memoizedState.isDehydrated){var lanes=getHighestPriorityLanes(root.pendingLanes);flushRoot(root,lanes)}break;case 13:var eventTime=requestEventTime();flushSync(function(){return scheduleUpdateOnFiber(fiber,
1,eventTime)});markRetryLaneIfNotHydrated(fiber,1)}};exports.batchedUpdates=function(fn,a){var prevExecutionContext=executionContext;executionContext|=1;try{return fn(a)}finally{executionContext=prevExecutionContext,executionContext!==NoContext||ReactCurrentActQueue$1.isBatchingLegacy||(resetRenderTimer(),includesLegacySyncCallbacks&&flushSyncCallbacks())}};exports.createComponentSelector=function(component){return{$$typeof:COMPONENT_TYPE,value:component}};exports.createContainer=function(containerInfo,
tag,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){return createFiberRoot(containerInfo,tag,!1,null,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError)};exports.createHasPseudoClassSelector=function(selectors){return{$$typeof:HAS_PSEUDO_CLASS_TYPE,value:selectors}};exports.createHydrationContainer=function(initialChildren,callback,containerInfo,tag,hydrationCallbacks,isStrictMode,
concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError,transitionCallbacks){initialChildren=createFiberRoot(containerInfo,tag,!0,initialChildren,hydrationCallbacks,isStrictMode,concurrentUpdatesByDefaultOverride,identifierPrefix,onRecoverableError);initialChildren.context=getContextForSubtree(null);containerInfo=initialChildren.current;tag=requestEventTime();hydrationCallbacks=requestUpdateLane(containerInfo);isStrictMode=createUpdate(tag,hydrationCallbacks);isStrictMode.callback=
void 0!==callback&&null!==callback?callback:null;enqueueUpdate(containerInfo,isStrictMode);initialChildren.current.lanes=hydrationCallbacks;markRootUpdated(initialChildren,hydrationCallbacks,tag);ensureRootIsScheduled(initialChildren,tag);return initialChildren};exports.createPortal=function(children,containerInfo,implementation){var key=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:REACT_PORTAL_TYPE,key:null==key?null:""+key,children,containerInfo,implementation}};exports.createRoleSelector=
function(role){return{$$typeof:ROLE_TYPE,value:role}};exports.createTestNameSelector=function(id){return{$$typeof:TEST_NAME_TYPE,value:id}};exports.createTextSelector=function(text){return{$$typeof:TEXT_TYPE,value:text}};exports.deferredUpdates=function(fn){var previousPriority=currentUpdatePriority,prevTransition=ReactCurrentBatchConfig$2.transition;try{return ReactCurrentBatchConfig$2.transition=null,currentUpdatePriority=16,fn()}finally{currentUpdatePriority=previousPriority,ReactCurrentBatchConfig$2.transition=
prevTransition}};exports.discreteUpdates=function(fn,a,b,c,d){var previousPriority=currentUpdatePriority,prevTransition=ReactCurrentBatchConfig$2.transition;try{return ReactCurrentBatchConfig$2.transition=null,currentUpdatePriority=1,fn(a,b,c,d)}finally{currentUpdatePriority=previousPriority,ReactCurrentBatchConfig$2.transition=prevTransition,executionContext===NoContext&&resetRenderTimer()}};exports.findAllNodes=findAllNodes;exports.findBoundingRects=function(hostRoot,selectors){if(!supportsTestSelectors)throw Error("Test selector API is not supported by this renderer.");
selectors=findAllNodes(hostRoot,selectors);hostRoot=[];for(var i=0;i<selectors.length;i++)hostRoot.push(getBoundingRect(selectors[i]));for(selectors=hostRoot.length-1;0<selectors;selectors--){i=hostRoot[selectors];for(var targetLeft=i.x,targetRight=targetLeft+i.width,targetTop=i.y,targetBottom=targetTop+i.height,j=selectors-1;0<=j;j--)if(selectors!==j){var otherRect=hostRoot[j],otherLeft=otherRect.x,otherRight=otherLeft+otherRect.width,otherTop=otherRect.y,otherBottom=otherTop+otherRect.height;if(targetLeft>=
otherLeft&&targetTop>=otherTop&&targetRight<=otherRight&&targetBottom<=otherBottom){hostRoot.splice(selectors,1);break}else if(!(targetLeft!==otherLeft||i.width!==otherRect.width||otherBottom<targetTop||otherTop>targetBottom)){otherTop>targetTop&&(otherRect.height+=otherTop-targetTop,otherRect.y=targetTop);otherBottom<targetBottom&&(otherRect.height=targetBottom-otherTop);hostRoot.splice(selectors,1);break}else if(!(targetTop!==otherTop||i.height!==otherRect.height||otherRight<targetLeft||otherLeft>
targetRight)){otherLeft>targetLeft&&(otherRect.width+=otherLeft-targetLeft,otherRect.x=targetLeft);otherRight<targetRight&&(otherRect.width=targetRight-otherLeft);hostRoot.splice(selectors,1);break}}}return hostRoot};exports.findHostInstance=function(component){var fiber=component._reactInternals;if(void 0===fiber){if("function"===typeof component.render)throw Error("Unable to find node on an unmounted component.");component=Object.keys(component).join(",");throw Error("Argument appears to not be a ReactComponent. Keys: "+
component);}component=findCurrentHostFiber(fiber);return null===component?null:component.stateNode};exports.findHostInstanceWithNoPortals=function(fiber){fiber=findCurrentFiberUsingSlowPath(fiber);fiber=null!==fiber?findCurrentHostFiberWithNoPortalsImpl(fiber):null;return null===fiber?null:fiber.stateNode};exports.findHostInstanceWithWarning=function(component,methodName){var fiber=component._reactInternals;if(void 0===fiber){if("function"===typeof component.render)throw Error("Unable to find node on an unmounted component.");
methodName=Object.keys(component).join(",");throw Error("Argument appears to not be a ReactComponent. Keys: "+methodName);}component=findCurrentHostFiber(fiber);if(null===component)return null;if(component.mode&8){var componentName=getComponentNameFromFiber(fiber)||"Component";if(!didWarnAboutFindNodeInStrictMode[componentName]){didWarnAboutFindNodeInStrictMode[componentName]=!0;var previousFiber=current$jscomp$1;try{setCurrentFiber(component),fiber.mode&8?error$jscomp$0("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",
methodName,methodName,componentName):error$jscomp$0("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node",methodName,methodName,componentName)}finally{previousFiber?setCurrentFiber(previousFiber):resetCurrentFiber()}}}return component.stateNode};exports.flushControlled=function(fn){var prevExecutionContext=
executionContext;executionContext|=1;var prevTransition=ReactCurrentBatchConfig$2.transition,previousPriority=currentUpdatePriority;try{ReactCurrentBatchConfig$2.transition=null,currentUpdatePriority=1,fn()}finally{currentUpdatePriority=previousPriority,ReactCurrentBatchConfig$2.transition=prevTransition,executionContext=prevExecutionContext,executionContext===NoContext&&(resetRenderTimer(),flushSyncCallbacks())}};exports.flushPassiveEffects=flushPassiveEffects;exports.flushSync=flushSync;exports.focusWithin=
function(hostRoot,selectors){if(!supportsTestSelectors)throw Error("Test selector API is not supported by this renderer.");hostRoot=findFiberRootForHostRoot(hostRoot);selectors=findPaths(hostRoot,selectors);selectors=Array.from(selectors);for(hostRoot=0;hostRoot<selectors.length;){var fiber=selectors[hostRoot++];if(!isHiddenSubtree(fiber)){if(5===fiber.tag&&setFocusIfFocusable(fiber.stateNode))return!0;for(fiber=fiber.child;null!==fiber;)selectors.push(fiber),fiber=fiber.sibling}}return!1};exports.getCurrentUpdatePriority=
function(){return currentUpdatePriority};exports.getFindAllNodesFailureDescription=function(hostRoot,selectors){if(!supportsTestSelectors)throw Error("Test selector API is not supported by this renderer.");var maxSelectorIndex=0,matchedNames=[];hostRoot=[findFiberRootForHostRoot(hostRoot),0];for(var index=0;index<hostRoot.length;){var fiber=hostRoot[index++],selectorIndex=hostRoot[index++],selector=selectors[selectorIndex];if(5!==fiber.tag||!isHiddenSubtree(fiber))if(matchSelector(fiber,selector)&&
(matchedNames.push(selectorToString(selector)),selectorIndex++,selectorIndex>maxSelectorIndex&&(maxSelectorIndex=selectorIndex)),selectorIndex<selectors.length)for(fiber=fiber.child;null!==fiber;)hostRoot.push(fiber,selectorIndex),fiber=fiber.sibling}if(maxSelectorIndex<selectors.length){for(hostRoot=[];maxSelectorIndex<selectors.length;maxSelectorIndex++)hostRoot.push(selectorToString(selectors[maxSelectorIndex]));return"findAllNodes was able to match part of the selector:\n  "+(matchedNames.join(" \x3e ")+
"\n\nNo matching component was found for:\n  ")+hostRoot.join(" \x3e ")}return null};exports.getPublicRootInstance=function(container){container=container.current;if(!container.child)return null;switch(container.child.tag){case 5:return getPublicInstance(container.child.stateNode);default:return container.child.stateNode}};exports.injectIntoDevTools=function(devToolsConfig){return injectInternals({bundleType:devToolsConfig.bundleType,version:devToolsConfig.version,rendererPackageName:devToolsConfig.rendererPackageName,
rendererConfig:devToolsConfig.rendererConfig,overrideHookState,overrideHookStateDeletePath,overrideHookStateRenamePath,overrideProps,overridePropsDeletePath,overridePropsRenamePath,setErrorHandler,setSuspenseHandler,scheduleUpdate,currentDispatcherRef:ReactSharedInternals.ReactCurrentDispatcher,findHostInstanceByFiber,findFiberByHostInstance:devToolsConfig.findFiberByHostInstance||emptyFindFiberByHostInstance,findHostInstancesForRefresh,scheduleRefresh,scheduleRoot,setRefreshHandler,getCurrentFiber:getCurrentFiberForDevTools,
reconcilerVersion:"18.0.0-fc46dba67-20220329"})};exports.isAlreadyRendering=function(){return(executionContext&(RenderContext|CommitContext))!==NoContext};exports.observeVisibleRects=function(hostRoot,selectors,callback,options){if(!supportsTestSelectors)throw Error("Test selector API is not supported by this renderer.");var instanceRoots=findAllNodes(hostRoot,selectors);callback=setupIntersectionObserver(instanceRoots,callback,options);var disconnect=callback.disconnect,observe=callback.observe,
unobserve=callback.unobserve,commitHook=function(){var nextInstanceRoots=findAllNodes(hostRoot,selectors);instanceRoots.forEach(function(target){0>nextInstanceRoots.indexOf(target)&&unobserve(target)});nextInstanceRoots.forEach(function(target){0>instanceRoots.indexOf(target)&&observe(target)})};commitHooks.push(commitHook);return{disconnect:function(){var index=commitHooks.indexOf(commitHook);0<=index&&commitHooks.splice(index,1);disconnect()}}};exports.registerMutableSourceForHydration=function(root,
mutableSource){var getVersion=mutableSource._getVersion;getVersion=getVersion(mutableSource._source);null==root.mutableSourceEagerHydrationData?root.mutableSourceEagerHydrationData=[mutableSource,getVersion]:root.mutableSourceEagerHydrationData.push(mutableSource,getVersion)};exports.runWithPriority=function(priority,fn){var previousPriority=currentUpdatePriority;try{return currentUpdatePriority=priority,fn()}finally{currentUpdatePriority=previousPriority}};exports.shouldError=function(fiber){return shouldErrorImpl(fiber)};
exports.shouldSuspend=function(fiber){return shouldSuspendImpl(fiber)};exports.updateContainer=updateContainer;return exports}}
//# sourceMappingURL=module$node_modules$react_reconciler$cjs$react_reconciler_development.js.map
